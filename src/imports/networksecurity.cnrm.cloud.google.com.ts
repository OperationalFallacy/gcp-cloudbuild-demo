// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema NetworkSecurityAuthorizationPolicy
 */
export class NetworkSecurityAuthorizationPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkSecurityAuthorizationPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networksecurity.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkSecurityAuthorizationPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkSecurityAuthorizationPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkSecurityAuthorizationPolicyProps): any {
    return {
      ...NetworkSecurityAuthorizationPolicy.GVK,
      ...toJson_NetworkSecurityAuthorizationPolicyProps(props),
    };
  }

  /**
   * Defines a "NetworkSecurityAuthorizationPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkSecurityAuthorizationPolicyProps) {
    super(scope, id, {
      ...NetworkSecurityAuthorizationPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkSecurityAuthorizationPolicy.GVK,
      ...toJson_NetworkSecurityAuthorizationPolicyProps(resolved),
    };
  }
}

/**
 * @schema NetworkSecurityAuthorizationPolicy
 */
export interface NetworkSecurityAuthorizationPolicyProps {
  /**
   * @schema NetworkSecurityAuthorizationPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkSecurityAuthorizationPolicy#spec
   */
  readonly spec: NetworkSecurityAuthorizationPolicySpec;

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicyProps(obj: NetworkSecurityAuthorizationPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkSecurityAuthorizationPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityAuthorizationPolicySpec
 */
export interface NetworkSecurityAuthorizationPolicySpec {
  /**
   * Required. The action to take when a rule match is found. Possible values are "ALLOW" or "DENY". Possible values: ACTION_UNSPECIFIED, ALLOW, DENY
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#action
   */
  readonly action: string;

  /**
   * Optional. Free-text description of the resource.
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#location
   */
  readonly location: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#projectRef
   */
  readonly projectRef: NetworkSecurityAuthorizationPolicySpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Optional. List of rules to match. If not set, the action specified in the ‘action’ field will be applied without any additional rule checks.
   *
   * @schema NetworkSecurityAuthorizationPolicySpec#rules
   */
  readonly rules?: NetworkSecurityAuthorizationPolicySpecRules[];

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpec(obj: NetworkSecurityAuthorizationPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'location': obj.location,
    'projectRef': toJson_NetworkSecurityAuthorizationPolicySpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rules': obj.rules?.map(y => toJson_NetworkSecurityAuthorizationPolicySpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkSecurityAuthorizationPolicySpecProjectRef
 */
export interface NetworkSecurityAuthorizationPolicySpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkSecurityAuthorizationPolicySpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkSecurityAuthorizationPolicySpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkSecurityAuthorizationPolicySpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpecProjectRef(obj: NetworkSecurityAuthorizationPolicySpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityAuthorizationPolicySpecRules
 */
export interface NetworkSecurityAuthorizationPolicySpecRules {
  /**
   * Optional. List of attributes for the traffic destination. If not set, the action specified in the ‘action’ field will be applied without any rule checks for the destination.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRules#destinations
   */
  readonly destinations?: NetworkSecurityAuthorizationPolicySpecRulesDestinations[];

  /**
   * Optional. List of attributes for the traffic source. If not set, the action specified in the ‘action’ field will be applied without any rule checks for the source.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRules#sources
   */
  readonly sources?: NetworkSecurityAuthorizationPolicySpecRulesSources[];

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpecRules(obj: NetworkSecurityAuthorizationPolicySpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinations': obj.destinations?.map(y => toJson_NetworkSecurityAuthorizationPolicySpecRulesDestinations(y)),
    'sources': obj.sources?.map(y => toJson_NetworkSecurityAuthorizationPolicySpecRulesSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinations
 */
export interface NetworkSecurityAuthorizationPolicySpecRulesDestinations {
  /**
   * Required. List of host names to match. Matched against HOST header in http requests. Each host can be an exact match, or a prefix match (example, “mydomain.*”) or a suffix match (example, *.myorg.com”) or a presence(any) match “*”.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinations#hosts
   */
  readonly hosts: string[];

  /**
   * Optional. Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinations#httpHeaderMatch
   */
  readonly httpHeaderMatch?: NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch;

  /**
   * Optional. A list of HTTP methods to match. Should not be set for gRPC services.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinations#methods
   */
  readonly methods?: string[];

  /**
   * Required. List of destination ports to match.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinations#ports
   */
  readonly ports: number[];

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpecRulesDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpecRulesDestinations(obj: NetworkSecurityAuthorizationPolicySpecRulesDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hosts': obj.hosts?.map(y => y),
    'httpHeaderMatch': toJson_NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch(obj.httpHeaderMatch),
    'methods': obj.methods?.map(y => y),
    'ports': obj.ports?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityAuthorizationPolicySpecRulesSources
 */
export interface NetworkSecurityAuthorizationPolicySpecRulesSources {
  /**
   * Optional. List of CIDR ranges to match based on source IP address. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesSources#ipBlocks
   */
  readonly ipBlocks?: string[];

  /**
   * Optional. List of peer identities to match for authorization. Each peer can be an exact match, or a prefix match (example, “namespace/*”) or a suffix match (example, _/service-account”) or a presence match “*”.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesSources#principals
   */
  readonly principals?: string[];

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpecRulesSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpecRulesSources(obj: NetworkSecurityAuthorizationPolicySpecRulesSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipBlocks': obj.ipBlocks?.map(y => y),
    'principals': obj.principals?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases.
 *
 * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch
 */
export interface NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch {
  /**
   * Required. The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch#headerName
   */
  readonly headerName: string;

  /**
   * Required. The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
   *
   * @schema NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch#regexMatch
   */
  readonly regexMatch: string;

}

/**
 * Converts an object of type 'NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch(obj: NetworkSecurityAuthorizationPolicySpecRulesDestinationsHttpHeaderMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'regexMatch': obj.regexMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkSecurityClientTLSPolicy
 */
export class NetworkSecurityClientTlsPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkSecurityClientTLSPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networksecurity.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkSecurityClientTLSPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkSecurityClientTLSPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkSecurityClientTlsPolicyProps): any {
    return {
      ...NetworkSecurityClientTlsPolicy.GVK,
      ...toJson_NetworkSecurityClientTlsPolicyProps(props),
    };
  }

  /**
   * Defines a "NetworkSecurityClientTLSPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkSecurityClientTlsPolicyProps) {
    super(scope, id, {
      ...NetworkSecurityClientTlsPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkSecurityClientTlsPolicy.GVK,
      ...toJson_NetworkSecurityClientTlsPolicyProps(resolved),
    };
  }
}

/**
 * @schema NetworkSecurityClientTLSPolicy
 */
export interface NetworkSecurityClientTlsPolicyProps {
  /**
   * @schema NetworkSecurityClientTLSPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkSecurityClientTLSPolicy#spec
   */
  readonly spec: NetworkSecurityClientTlsPolicySpec;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicyProps(obj: NetworkSecurityClientTlsPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkSecurityClientTlsPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityClientTlsPolicySpec
 */
export interface NetworkSecurityClientTlsPolicySpec {
  /**
   * Optional. Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
   *
   * @schema NetworkSecurityClientTlsPolicySpec#clientCertificate
   */
  readonly clientCertificate?: NetworkSecurityClientTlsPolicySpecClientCertificate;

  /**
   * Optional. Free-text description of the resource.
   *
   * @schema NetworkSecurityClientTlsPolicySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkSecurityClientTlsPolicySpec#location
   */
  readonly location: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkSecurityClientTlsPolicySpec#projectRef
   */
  readonly projectRef?: NetworkSecurityClientTlsPolicySpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkSecurityClientTlsPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Required. Defines the mechanism to obtain the Certificate Authority certificate to validate the server certificate.
   *
   * @schema NetworkSecurityClientTlsPolicySpec#serverValidationCa
   */
  readonly serverValidationCa?: NetworkSecurityClientTlsPolicySpecServerValidationCa[];

  /**
   * Optional. Server Name Indication string to present to the server during TLS handshake. E.g: "secure.example.com".
   *
   * @schema NetworkSecurityClientTlsPolicySpec#sni
   */
  readonly sni?: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpec(obj: NetworkSecurityClientTlsPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_NetworkSecurityClientTlsPolicySpecClientCertificate(obj.clientCertificate),
    'description': obj.description,
    'location': obj.location,
    'projectRef': toJson_NetworkSecurityClientTlsPolicySpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'serverValidationCa': obj.serverValidationCa?.map(y => toJson_NetworkSecurityClientTlsPolicySpecServerValidationCa(y)),
    'sni': obj.sni,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Defines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
 *
 * @schema NetworkSecurityClientTlsPolicySpecClientCertificate
 */
export interface NetworkSecurityClientTlsPolicySpecClientCertificate {
  /**
   * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
   *
   * @schema NetworkSecurityClientTlsPolicySpecClientCertificate#certificateProviderInstance
   */
  readonly certificateProviderInstance?: NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance;

  /**
   * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
   *
   * @schema NetworkSecurityClientTlsPolicySpecClientCertificate#grpcEndpoint
   */
  readonly grpcEndpoint?: NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecClientCertificate(obj: NetworkSecurityClientTlsPolicySpecClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateProviderInstance': toJson_NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance(obj.certificateProviderInstance),
    'grpcEndpoint': toJson_NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint(obj.grpcEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkSecurityClientTlsPolicySpecProjectRef
 */
export interface NetworkSecurityClientTlsPolicySpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkSecurityClientTlsPolicySpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkSecurityClientTlsPolicySpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkSecurityClientTlsPolicySpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecProjectRef(obj: NetworkSecurityClientTlsPolicySpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityClientTlsPolicySpecServerValidationCa
 */
export interface NetworkSecurityClientTlsPolicySpecServerValidationCa {
  /**
   * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
   *
   * @schema NetworkSecurityClientTlsPolicySpecServerValidationCa#certificateProviderInstance
   */
  readonly certificateProviderInstance?: NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance;

  /**
   * gRPC specific configuration to access the gRPC server to obtain the CA certificate.
   *
   * @schema NetworkSecurityClientTlsPolicySpecServerValidationCa#grpcEndpoint
   */
  readonly grpcEndpoint?: NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecServerValidationCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecServerValidationCa(obj: NetworkSecurityClientTlsPolicySpecServerValidationCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateProviderInstance': toJson_NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance(obj.certificateProviderInstance),
    'grpcEndpoint': toJson_NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint(obj.grpcEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
 *
 * @schema NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance
 */
export interface NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance {
  /**
   * Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
   *
   * @schema NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance#pluginInstance
   */
  readonly pluginInstance: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance(obj: NetworkSecurityClientTlsPolicySpecClientCertificateCertificateProviderInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pluginInstance': obj.pluginInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
 *
 * @schema NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint
 */
export interface NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint {
  /**
   * Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with “unix:”.
   *
   * @schema NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint#targetUri
   */
  readonly targetUri: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint(obj: NetworkSecurityClientTlsPolicySpecClientCertificateGrpcEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetUri': obj.targetUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
 *
 * @schema NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance
 */
export interface NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance {
  /**
   * Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
   *
   * @schema NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance#pluginInstance
   */
  readonly pluginInstance: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance(obj: NetworkSecurityClientTlsPolicySpecServerValidationCaCertificateProviderInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pluginInstance': obj.pluginInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gRPC specific configuration to access the gRPC server to obtain the CA certificate.
 *
 * @schema NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint
 */
export interface NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint {
  /**
   * Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with “unix:”.
   *
   * @schema NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint#targetUri
   */
  readonly targetUri: string;

}

/**
 * Converts an object of type 'NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint(obj: NetworkSecurityClientTlsPolicySpecServerValidationCaGrpcEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetUri': obj.targetUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkSecurityServerTLSPolicy
 */
export class NetworkSecurityServerTlsPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkSecurityServerTLSPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networksecurity.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkSecurityServerTLSPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkSecurityServerTLSPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkSecurityServerTlsPolicyProps): any {
    return {
      ...NetworkSecurityServerTlsPolicy.GVK,
      ...toJson_NetworkSecurityServerTlsPolicyProps(props),
    };
  }

  /**
   * Defines a "NetworkSecurityServerTLSPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkSecurityServerTlsPolicyProps) {
    super(scope, id, {
      ...NetworkSecurityServerTlsPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkSecurityServerTlsPolicy.GVK,
      ...toJson_NetworkSecurityServerTlsPolicyProps(resolved),
    };
  }
}

/**
 * @schema NetworkSecurityServerTLSPolicy
 */
export interface NetworkSecurityServerTlsPolicyProps {
  /**
   * @schema NetworkSecurityServerTLSPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkSecurityServerTLSPolicy#spec
   */
  readonly spec: NetworkSecurityServerTlsPolicySpec;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicyProps(obj: NetworkSecurityServerTlsPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkSecurityServerTlsPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityServerTlsPolicySpec
 */
export interface NetworkSecurityServerTlsPolicySpec {
  /**
   * Optional. Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allow_open and mtls_policy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#allowOpen
   */
  readonly allowOpen?: boolean;

  /**
   * Optional. Free-text description of the resource.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkSecurityServerTlsPolicySpec#location
   */
  readonly location: string;

  /**
   * Optional. Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allow_open and mtls_policy are set, server allows both plain text and mTLS connections.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#mtlsPolicy
   */
  readonly mtlsPolicy?: NetworkSecurityServerTlsPolicySpecMtlsPolicy;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#projectRef
   */
  readonly projectRef?: NetworkSecurityServerTlsPolicySpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Optional. Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allow_open as a permissive mode that allows both plain text and TLS is not supported.
   *
   * @schema NetworkSecurityServerTlsPolicySpec#serverCertificate
   */
  readonly serverCertificate?: NetworkSecurityServerTlsPolicySpecServerCertificate;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpec(obj: NetworkSecurityServerTlsPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowOpen': obj.allowOpen,
    'description': obj.description,
    'location': obj.location,
    'mtlsPolicy': toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicy(obj.mtlsPolicy),
    'projectRef': toJson_NetworkSecurityServerTlsPolicySpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'serverCertificate': toJson_NetworkSecurityServerTlsPolicySpecServerCertificate(obj.serverCertificate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allow_open and mtls_policy are set, server allows both plain text and mTLS connections.
 *
 * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicy
 */
export interface NetworkSecurityServerTlsPolicySpecMtlsPolicy {
  /**
   * Required. Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
   *
   * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicy#clientValidationCa
   */
  readonly clientValidationCa: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa[];

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecMtlsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicy(obj: NetworkSecurityServerTlsPolicySpecMtlsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientValidationCa': obj.clientValidationCa?.map(y => toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkSecurityServerTlsPolicySpecProjectRef
 */
export interface NetworkSecurityServerTlsPolicySpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkSecurityServerTlsPolicySpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkSecurityServerTlsPolicySpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkSecurityServerTlsPolicySpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecProjectRef(obj: NetworkSecurityServerTlsPolicySpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allow_open as a permissive mode that allows both plain text and TLS is not supported.
 *
 * @schema NetworkSecurityServerTlsPolicySpecServerCertificate
 */
export interface NetworkSecurityServerTlsPolicySpecServerCertificate {
  /**
   * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
   *
   * @schema NetworkSecurityServerTlsPolicySpecServerCertificate#certificateProviderInstance
   */
  readonly certificateProviderInstance?: NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance;

  /**
   * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
   *
   * @schema NetworkSecurityServerTlsPolicySpecServerCertificate#grpcEndpoint
   */
  readonly grpcEndpoint?: NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecServerCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecServerCertificate(obj: NetworkSecurityServerTlsPolicySpecServerCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateProviderInstance': toJson_NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance(obj.certificateProviderInstance),
    'grpcEndpoint': toJson_NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint(obj.grpcEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa
 */
export interface NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa {
  /**
   * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
   *
   * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa#certificateProviderInstance
   */
  readonly certificateProviderInstance?: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance;

  /**
   * gRPC specific configuration to access the gRPC server to obtain the CA certificate.
   *
   * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa#grpcEndpoint
   */
  readonly grpcEndpoint?: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa(obj: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateProviderInstance': toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance(obj.certificateProviderInstance),
    'grpcEndpoint': toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint(obj.grpcEndpoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
 *
 * @schema NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance
 */
export interface NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance {
  /**
   * Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
   *
   * @schema NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance#pluginInstance
   */
  readonly pluginInstance: string;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance(obj: NetworkSecurityServerTlsPolicySpecServerCertificateCertificateProviderInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pluginInstance': obj.pluginInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gRPC specific configuration to access the gRPC server to obtain the cert and private key.
 *
 * @schema NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint
 */
export interface NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint {
  /**
   * Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with “unix:”.
   *
   * @schema NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint#targetUri
   */
  readonly targetUri: string;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint(obj: NetworkSecurityServerTlsPolicySpecServerCertificateGrpcEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetUri': obj.targetUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
 *
 * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance
 */
export interface NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance {
  /**
   * Required. Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
   *
   * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance#pluginInstance
   */
  readonly pluginInstance: string;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance(obj: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaCertificateProviderInstance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pluginInstance': obj.pluginInstance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gRPC specific configuration to access the gRPC server to obtain the CA certificate.
 *
 * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint
 */
export interface NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint {
  /**
   * Required. The target URI of the gRPC endpoint. Only UDS path is supported, and should start with “unix:”.
   *
   * @schema NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint#targetUri
   */
  readonly targetUri: string;

}

/**
 * Converts an object of type 'NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint(obj: NetworkSecurityServerTlsPolicySpecMtlsPolicyClientValidationCaGrpcEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetUri': obj.targetUri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

