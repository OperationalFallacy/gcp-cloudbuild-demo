// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema ComputeAddress
 */
export class ComputeAddress extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeAddress"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeAddress',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeAddress".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeAddressProps): any {
    return {
      ...ComputeAddress.GVK,
      ...toJson_ComputeAddressProps(props),
    };
  }

  /**
   * Defines a "ComputeAddress" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeAddressProps) {
    super(scope, id, {
      ...ComputeAddress.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeAddress.GVK,
      ...toJson_ComputeAddressProps(resolved),
    };
  }
}

/**
 * @schema ComputeAddress
 */
export interface ComputeAddressProps {
  /**
   * @schema ComputeAddress#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeAddress#spec
   */
  readonly spec: ComputeAddressSpec;

}

/**
 * Converts an object of type 'ComputeAddressProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeAddressProps(obj: ComputeAddressProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeAddressSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeAddressSpec
 */
export interface ComputeAddressSpec {
  /**
   * Immutable. The static external IP address represented by this resource. Only
   * IPv4 is supported. An address may only be specified for INTERNAL
   * address types. The IP address must be inside the specified subnetwork,
   * if any. Set by the API if undefined.
   *
   * @schema ComputeAddressSpec#address
   */
  readonly address?: string;

  /**
   * Immutable. The type of address to reserve.
   * Note: if you set this argument's value as 'INTERNAL' you need to leave the 'network_tier' argument unset in that resource block. Default value: "EXTERNAL" Possible values: ["INTERNAL", "EXTERNAL"].
   *
   * @schema ComputeAddressSpec#addressType
   */
  readonly addressType?: string;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeAddressSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The IP Version that will be used by this address. The default value is 'IPV4'. Possible values: ["IPV4", "IPV6"]. This field can only be specified for a global address.
   *
   * @schema ComputeAddressSpec#ipVersion
   */
  readonly ipVersion?: string;

  /**
   * Location represents the geographical location of the ComputeAddress. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeAddressSpec#location
   */
  readonly location: string;

  /**
   * The network in which to reserve the address. If global, the address
   * must be within the RFC1918 IP space. The network cannot be deleted
   * if there are any reserved IP ranges referring to it. This field can
   * only be used with INTERNAL type with the VPC_PEERING and
   * IPSEC_INTERCONNECT purposes.
   *
   * @schema ComputeAddressSpec#networkRef
   */
  readonly networkRef?: ComputeAddressSpecNetworkRef;

  /**
   * Immutable. The networking tier used for configuring this address. If this field is not
   * specified, it is assumed to be PREMIUM.
   * This argument should not be used when configuring Internal addresses, because [network tier cannot be set for internal traffic; it's always Premium](https://cloud.google.com/network-tiers/docs/overview). Possible values: ["PREMIUM", "STANDARD"].
   *
   * @schema ComputeAddressSpec#networkTier
   */
  readonly networkTier?: string;

  /**
   * Immutable. The prefix length if the resource represents an IP range.
   *
   * @schema ComputeAddressSpec#prefixLength
   */
  readonly prefixLength?: number;

  /**
   * Immutable. The purpose of this resource, which can be one of the following values.
   *
   * * GCE_ENDPOINT for addresses that are used by VM instances, alias IP
   * ranges, load balancers, and similar resources.
   *
   * * SHARED_LOADBALANCER_VIP for an address that can be used by multiple
   * internal load balancers.
   *
   * * VPC_PEERING for addresses that are reserved for VPC peer networks.
   *
   * * IPSEC_INTERCONNECT for addresses created from a private IP range that
   * are reserved for a VLAN attachment in an HA VPN over Cloud Interconnect
   * configuration. These addresses are regional resources.
   *
   * * PRIVATE_SERVICE_CONNECT for a private network address that is used to
   * configure Private Service Connect. Only global internal addresses can use
   * this purpose.
   *
   *
   * This should only be set when using an Internal address.
   *
   * @schema ComputeAddressSpec#purpose
   */
  readonly purpose?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeAddressSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The subnetwork in which to reserve the address. If an IP address is
   * specified, it must be within the subnetwork's IP range.  This field
   * can only be used with INTERNAL type with GCE_ENDPOINT/DNS_RESOLVER
   * purposes.
   *
   * @schema ComputeAddressSpec#subnetworkRef
   */
  readonly subnetworkRef?: ComputeAddressSpecSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeAddressSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeAddressSpec(obj: ComputeAddressSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'addressType': obj.addressType,
    'description': obj.description,
    'ipVersion': obj.ipVersion,
    'location': obj.location,
    'networkRef': toJson_ComputeAddressSpecNetworkRef(obj.networkRef),
    'networkTier': obj.networkTier,
    'prefixLength': obj.prefixLength,
    'purpose': obj.purpose,
    'resourceID': obj.resourceId,
    'subnetworkRef': toJson_ComputeAddressSpecSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network in which to reserve the address. If global, the address
 * must be within the RFC1918 IP space. The network cannot be deleted
 * if there are any reserved IP ranges referring to it. This field can
 * only be used with INTERNAL type with the VPC_PEERING and
 * IPSEC_INTERCONNECT purposes.
 *
 * @schema ComputeAddressSpecNetworkRef
 */
export interface ComputeAddressSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeAddressSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeAddressSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeAddressSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeAddressSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeAddressSpecNetworkRef(obj: ComputeAddressSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The subnetwork in which to reserve the address. If an IP address is
 * specified, it must be within the subnetwork's IP range.  This field
 * can only be used with INTERNAL type with GCE_ENDPOINT/DNS_RESOLVER
 * purposes.
 *
 * @schema ComputeAddressSpecSubnetworkRef
 */
export interface ComputeAddressSpecSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeAddressSpecSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeAddressSpecSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeAddressSpecSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeAddressSpecSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeAddressSpecSubnetworkRef(obj: ComputeAddressSpecSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeBackendBucket
 */
export class ComputeBackendBucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeBackendBucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeBackendBucket',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeBackendBucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeBackendBucketProps): any {
    return {
      ...ComputeBackendBucket.GVK,
      ...toJson_ComputeBackendBucketProps(props),
    };
  }

  /**
   * Defines a "ComputeBackendBucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeBackendBucketProps) {
    super(scope, id, {
      ...ComputeBackendBucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeBackendBucket.GVK,
      ...toJson_ComputeBackendBucketProps(resolved),
    };
  }
}

/**
 * @schema ComputeBackendBucket
 */
export interface ComputeBackendBucketProps {
  /**
   * @schema ComputeBackendBucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeBackendBucket#spec
   */
  readonly spec: ComputeBackendBucketSpec;

}

/**
 * Converts an object of type 'ComputeBackendBucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketProps(obj: ComputeBackendBucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeBackendBucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendBucketSpec
 */
export interface ComputeBackendBucketSpec {
  /**
   * Reference to the bucket.
   *
   * @schema ComputeBackendBucketSpec#bucketRef
   */
  readonly bucketRef: ComputeBackendBucketSpecBucketRef;

  /**
   * Cloud CDN configuration for this Backend Bucket.
   *
   * @schema ComputeBackendBucketSpec#cdnPolicy
   */
  readonly cdnPolicy?: ComputeBackendBucketSpecCdnPolicy;

  /**
   * Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header. Possible values: ["AUTOMATIC", "DISABLED"].
   *
   * @schema ComputeBackendBucketSpec#compressionMode
   */
  readonly compressionMode?: string;

  /**
   * Headers that the HTTP/S load balancer should add to proxied responses.
   *
   * @schema ComputeBackendBucketSpec#customResponseHeaders
   */
  readonly customResponseHeaders?: string[];

  /**
   * An optional textual description of the resource; provided by the
   * client when the resource is created.
   *
   * @schema ComputeBackendBucketSpec#description
   */
  readonly description?: string;

  /**
   * The security policy associated with this backend bucket.
   *
   * @schema ComputeBackendBucketSpec#edgeSecurityPolicy
   */
  readonly edgeSecurityPolicy?: string;

  /**
   * If true, enable Cloud CDN for this BackendBucket.
   *
   * @schema ComputeBackendBucketSpec#enableCdn
   */
  readonly enableCdn?: boolean;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeBackendBucketSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeBackendBucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpec(obj: ComputeBackendBucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketRef': toJson_ComputeBackendBucketSpecBucketRef(obj.bucketRef),
    'cdnPolicy': toJson_ComputeBackendBucketSpecCdnPolicy(obj.cdnPolicy),
    'compressionMode': obj.compressionMode,
    'customResponseHeaders': obj.customResponseHeaders?.map(y => y),
    'description': obj.description,
    'edgeSecurityPolicy': obj.edgeSecurityPolicy,
    'enableCdn': obj.enableCdn,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the bucket.
 *
 * @schema ComputeBackendBucketSpecBucketRef
 */
export interface ComputeBackendBucketSpecBucketRef {
  /**
   * Allowed value: The `name` field of a `StorageBucket` resource.
   *
   * @schema ComputeBackendBucketSpecBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendBucketSpecBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendBucketSpecBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendBucketSpecBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpecBucketRef(obj: ComputeBackendBucketSpecBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloud CDN configuration for this Backend Bucket.
 *
 * @schema ComputeBackendBucketSpecCdnPolicy
 */
export interface ComputeBackendBucketSpecCdnPolicy {
  /**
   * Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#bypassCacheOnRequestHeaders
   */
  readonly bypassCacheOnRequestHeaders?: ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders[];

  /**
   * The CacheKeyPolicy for this CdnPolicy.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#cacheKeyPolicy
   */
  readonly cacheKeyPolicy?: ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy;

  /**
   * Specifies the cache setting for all responses from this backend.
   * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"].
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#cacheMode
   */
  readonly cacheMode?: string;

  /**
   * Specifies the maximum allowed TTL for cached content served by this origin.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#clientTtl
   */
  readonly clientTtl?: number;

  /**
   * Specifies the default TTL for cached content served by this origin for responses
   * that do not have an existing valid TTL (max-age or s-max-age).
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Specifies the maximum allowed TTL for cached content served by this origin.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#negativeCaching
   */
  readonly negativeCaching?: boolean;

  /**
   * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
   * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#negativeCachingPolicy
   */
  readonly negativeCachingPolicy?: ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy[];

  /**
   * If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#requestCoalescing
   */
  readonly requestCoalescing?: boolean;

  /**
   * Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#serveWhileStale
   */
  readonly serveWhileStale?: number;

  /**
   * Maximum number of seconds the response to a signed URL request will
   * be considered fresh. After this time period,
   * the response will be revalidated before being served.
   * When serving responses to signed URL requests,
   * Cloud CDN will internally behave as though
   * all responses from this backend had a "Cache-Control: public,
   * max-age=[TTL]" header, regardless of any existing Cache-Control
   * header. The actual headers served in responses will not be altered.
   *
   * @schema ComputeBackendBucketSpecCdnPolicy#signedUrlCacheMaxAgeSec
   */
  readonly signedUrlCacheMaxAgeSec?: number;

}

/**
 * Converts an object of type 'ComputeBackendBucketSpecCdnPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpecCdnPolicy(obj: ComputeBackendBucketSpecCdnPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassCacheOnRequestHeaders': obj.bypassCacheOnRequestHeaders?.map(y => toJson_ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders(y)),
    'cacheKeyPolicy': toJson_ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy(obj.cacheKeyPolicy),
    'cacheMode': obj.cacheMode,
    'clientTtl': obj.clientTtl,
    'defaultTtl': obj.defaultTtl,
    'maxTtl': obj.maxTtl,
    'negativeCaching': obj.negativeCaching,
    'negativeCachingPolicy': obj.negativeCachingPolicy?.map(y => toJson_ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy(y)),
    'requestCoalescing': obj.requestCoalescing,
    'serveWhileStale': obj.serveWhileStale,
    'signedUrlCacheMaxAgeSec': obj.signedUrlCacheMaxAgeSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders
 */
export interface ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders {
  /**
   * The header field name to match on when bypassing cache. Values are case-insensitive.
   *
   * @schema ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders(obj: ComputeBackendBucketSpecCdnPolicyBypassCacheOnRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CacheKeyPolicy for this CdnPolicy.
 *
 * @schema ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy
 */
export interface ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy {
  /**
   * Allows HTTP request headers (by name) to be used in the
   * cache key.
   *
   * @schema ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy#includeHttpHeaders
   */
  readonly includeHttpHeaders?: string[];

  /**
   * Names of query string parameters to include in cache keys.
   * Default parameters are always included. '&' and '=' will
   * be percent encoded and not treated as delimiters.
   *
   * @schema ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy#queryStringWhitelist
   */
  readonly queryStringWhitelist?: string[];

}

/**
 * Converts an object of type 'ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy(obj: ComputeBackendBucketSpecCdnPolicyCacheKeyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includeHttpHeaders': obj.includeHttpHeaders?.map(y => y),
    'queryStringWhitelist': obj.queryStringWhitelist?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy
 */
export interface ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy {
  /**
   * The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
   * can be specified as values, and you cannot specify a status code more than once.
   *
   * @schema ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy#code
   */
  readonly code?: number;

  /**
   * The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
   * (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
   *
   * @schema ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy(obj: ComputeBackendBucketSpecCdnPolicyNegativeCachingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeBackendService
 */
export class ComputeBackendService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeBackendService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeBackendService',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeBackendService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeBackendServiceProps): any {
    return {
      ...ComputeBackendService.GVK,
      ...toJson_ComputeBackendServiceProps(props),
    };
  }

  /**
   * Defines a "ComputeBackendService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeBackendServiceProps) {
    super(scope, id, {
      ...ComputeBackendService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeBackendService.GVK,
      ...toJson_ComputeBackendServiceProps(resolved),
    };
  }
}

/**
 * @schema ComputeBackendService
 */
export interface ComputeBackendServiceProps {
  /**
   * @schema ComputeBackendService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeBackendService#spec
   */
  readonly spec: ComputeBackendServiceSpec;

}

/**
 * Converts an object of type 'ComputeBackendServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceProps(obj: ComputeBackendServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeBackendServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpec
 */
export interface ComputeBackendServiceSpec {
  /**
   * Lifetime of cookies in seconds if session_affinity is
   * GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
   * only until the end of the browser session (or equivalent). The
   * maximum allowed value for TTL is one day.
   *
   * When the load balancing scheme is INTERNAL, this field is not used.
   *
   * @schema ComputeBackendServiceSpec#affinityCookieTtlSec
   */
  readonly affinityCookieTtlSec?: number;

  /**
   * The set of backends that serve this BackendService.
   *
   * @schema ComputeBackendServiceSpec#backend
   */
  readonly backend?: ComputeBackendServiceSpecBackend[];

  /**
   * Cloud CDN configuration for this BackendService.
   *
   * @schema ComputeBackendServiceSpec#cdnPolicy
   */
  readonly cdnPolicy?: ComputeBackendServiceSpecCdnPolicy;

  /**
   * Settings controlling the volume of connections to a backend service. This field
   * is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeBackendServiceSpec#circuitBreakers
   */
  readonly circuitBreakers?: ComputeBackendServiceSpecCircuitBreakers;

  /**
   * Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header. Possible values: ["AUTOMATIC", "DISABLED"].
   *
   * @schema ComputeBackendServiceSpec#compressionMode
   */
  readonly compressionMode?: string;

  /**
   * Time for which instance will be drained (not accept new
   * connections, but still work to finish started).
   *
   * @schema ComputeBackendServiceSpec#connectionDrainingTimeoutSec
   */
  readonly connectionDrainingTimeoutSec?: number;

  /**
   * Connection Tracking configuration for this BackendService.
   * This is available only for Layer 4 Internal Load Balancing and
   * Network Load Balancing.
   *
   * @schema ComputeBackendServiceSpec#connectionTrackingPolicy
   */
  readonly connectionTrackingPolicy?: ComputeBackendServiceSpecConnectionTrackingPolicy;

  /**
   * Consistent Hash-based load balancing can be used to provide soft session
   * affinity based on HTTP headers, cookies or other properties. This load balancing
   * policy is applicable only for HTTP connections. The affinity to a particular
   * destination host will be lost when one or more hosts are added/removed from the
   * destination service. This field specifies parameters that control consistent
   * hashing. This field only applies if the load_balancing_scheme is set to
   * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
   * set to MAGLEV or RING_HASH.
   *
   * @schema ComputeBackendServiceSpec#consistentHash
   */
  readonly consistentHash?: ComputeBackendServiceSpecConsistentHash;

  /**
   * Headers that the HTTP/S load balancer should add to proxied
   * requests.
   *
   * @schema ComputeBackendServiceSpec#customRequestHeaders
   */
  readonly customRequestHeaders?: string[];

  /**
   * Headers that the HTTP/S load balancer should add to proxied
   * responses.
   *
   * @schema ComputeBackendServiceSpec#customResponseHeaders
   */
  readonly customResponseHeaders?: string[];

  /**
   * An optional description of this resource.
   *
   * @schema ComputeBackendServiceSpec#description
   */
  readonly description?: string;

  /**
   * The resource URL for the edge security policy associated with this
   * backend service.
   *
   * @schema ComputeBackendServiceSpec#edgeSecurityPolicyRef
   */
  readonly edgeSecurityPolicyRef?: ComputeBackendServiceSpecEdgeSecurityPolicyRef;

  /**
   * If true, enable Cloud CDN for this BackendService.
   *
   * @schema ComputeBackendServiceSpec#enableCdn
   */
  readonly enableCdn?: boolean;

  /**
   * Policy for failovers.
   *
   * @schema ComputeBackendServiceSpec#failoverPolicy
   */
  readonly failoverPolicy?: ComputeBackendServiceSpecFailoverPolicy;

  /**
   * @schema ComputeBackendServiceSpec#healthChecks
   */
  readonly healthChecks?: ComputeBackendServiceSpecHealthChecks[];

  /**
   * Settings for enabling Cloud Identity Aware Proxy.
   *
   * @schema ComputeBackendServiceSpec#iap
   */
  readonly iap?: ComputeBackendServiceSpecIap;

  /**
   * Immutable. Indicates whether the backend service will be used with internal or
   * external load balancing. A backend service created for one type of
   * load balancing cannot be used with the other. For more information, refer to
   * [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service). Default value: "EXTERNAL" Possible values: ["EXTERNAL", "INTERNAL_SELF_MANAGED", "EXTERNAL_MANAGED"].
   *
   * @schema ComputeBackendServiceSpec#loadBalancingScheme
   */
  readonly loadBalancingScheme?: string;

  /**
   * A list of locality load balancing policies to be used in order of
   * preference. Either the policy or the customPolicy field should be set.
   * Overrides any value set in the localityLbPolicy field.
   *
   * localityLbPolicies is only supported when the BackendService is referenced
   * by a URL Map that is referenced by a target gRPC proxy that has the
   * validateForProxyless field set to true.
   *
   * @schema ComputeBackendServiceSpec#localityLbPolicies
   */
  readonly localityLbPolicies?: ComputeBackendServiceSpecLocalityLbPolicies[];

  /**
   * The load balancing algorithm used within the scope of the locality.
   * The possible values are:
   *
   * * 'ROUND_ROBIN': This is a simple policy in which each healthy backend
   * is selected in round robin order.
   *
   * * 'LEAST_REQUEST': An O(1) algorithm which selects two random healthy
   * hosts and picks the host which has fewer active requests.
   *
   * * 'RING_HASH': The ring/modulo hash load balancer implements consistent
   * hashing to backends. The algorithm has the property that the
   * addition/removal of a host from a set of N hosts only affects
   * 1/N of the requests.
   *
   * * 'RANDOM': The load balancer selects a random healthy host.
   *
   * * 'ORIGINAL_DESTINATION': Backend host is selected based on the client
   * connection metadata, i.e., connections are opened
   * to the same address as the destination address of
   * the incoming connection before the connection
   * was redirected to the load balancer.
   *
   * * 'MAGLEV': used as a drop in replacement for the ring hash load balancer.
   * Maglev is not as stable as ring hash but has faster table lookup
   * build times and host selection times. For more information about
   * Maglev, refer to https://ai.google/research/pubs/pub44824
   *
   * * 'WEIGHTED_MAGLEV': Per-instance weighted Load Balancing via health check
   * reported weights. If set, the Backend Service must
   * configure a non legacy HTTP-based Health Check, and
   * health check replies are expected to contain
   * non-standard HTTP response header field
   * X-Load-Balancing-Endpoint-Weight to specify the
   * per-instance weights. If set, Load Balancing is weight
   * based on the per-instance weights reported in the last
   * processed health check replies, as long as every
   * instance either reported a valid weight or had
   * UNAVAILABLE_WEIGHT. Otherwise, Load Balancing remains
   * equal-weight.
   *
   *
   * This field is applicable to either:
   *
   * * A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2,
   * and loadBalancingScheme set to INTERNAL_MANAGED.
   * * A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   * * A regional backend service with loadBalancingScheme set to EXTERNAL (External Network
   * Load Balancing). Only MAGLEV and WEIGHTED_MAGLEV values are possible for External
   * Network Load Balancing. The default is MAGLEV.
   *
   *
   * If session_affinity is not NONE, and this field is not set to MAGLEV, WEIGHTED_MAGLEV,
   * or RING_HASH, session affinity settings will not take effect.
   *
   * Only ROUND_ROBIN and RING_HASH are supported when the backend service is referenced
   * by a URL map that is bound to target gRPC proxy that has validate_for_proxyless
   * field set to true. Possible values: ["ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM", "ORIGINAL_DESTINATION", "MAGLEV", "WEIGHTED_MAGLEV"].
   *
   * @schema ComputeBackendServiceSpec#localityLbPolicy
   */
  readonly localityLbPolicy?: string;

  /**
   * Location represents the geographical location of the ComputeBackendService. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeBackendServiceSpec#location
   */
  readonly location: string;

  /**
   * This field denotes the logging options for the load balancer traffic served by this backend service.
   * If logging is enabled, logs will be exported to Stackdriver.
   *
   * @schema ComputeBackendServiceSpec#logConfig
   */
  readonly logConfig?: ComputeBackendServiceSpecLogConfig;

  /**
   * The network to which this backend service belongs.  This field can
   * only be specified when the load balancing scheme is set to
   * INTERNAL.
   *
   * @schema ComputeBackendServiceSpec#networkRef
   */
  readonly networkRef?: ComputeBackendServiceSpecNetworkRef;

  /**
   * Settings controlling eviction of unhealthy hosts from the load balancing pool.
   * This field is applicable only when the load_balancing_scheme is set
   * to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeBackendServiceSpec#outlierDetection
   */
  readonly outlierDetection?: ComputeBackendServiceSpecOutlierDetection;

  /**
   * Name of backend port. The same name should appear in the instance
   * groups referenced by this service. Required when the load balancing
   * scheme is EXTERNAL.
   *
   * @schema ComputeBackendServiceSpec#portName
   */
  readonly portName?: string;

  /**
   * The protocol this BackendService uses to communicate with backends.
   * The default is HTTP. **NOTE**: HTTP2 is only valid for beta HTTP/2 load balancer
   * types and may result in errors if used with the GA API. Possible values: ["HTTP", "HTTPS", "HTTP2", "TCP", "SSL", "GRPC"].
   *
   * @schema ComputeBackendServiceSpec#protocol
   */
  readonly protocol?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeBackendServiceSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The security policy associated with this backend service.
   *
   * @schema ComputeBackendServiceSpec#securityPolicyRef
   */
  readonly securityPolicyRef?: ComputeBackendServiceSpecSecurityPolicyRef;

  /**
   * The security settings that apply to this backend service. This field is applicable to either
   * a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
   * load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
   * load_balancing_scheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeBackendServiceSpec#securitySettings
   */
  readonly securitySettings?: ComputeBackendServiceSpecSecuritySettings;

  /**
   * Type of session affinity to use. The default is NONE. Session affinity is
   * not applicable if the protocol is UDP. Possible values: ["NONE", "CLIENT_IP", "CLIENT_IP_PORT_PROTO", "CLIENT_IP_PROTO", "GENERATED_COOKIE", "HEADER_FIELD", "HTTP_COOKIE"].
   *
   * @schema ComputeBackendServiceSpec#sessionAffinity
   */
  readonly sessionAffinity?: string;

  /**
   * Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing and Internal HTTP(S) load balancing.
   *
   * @schema ComputeBackendServiceSpec#subsetting
   */
  readonly subsetting?: ComputeBackendServiceSpecSubsetting;

  /**
   * How many seconds to wait for the backend before considering it a
   * failed request. Default is 30 seconds. Valid range is [1, 86400].
   *
   * @default 30 seconds. Valid range is [1, 86400].
   * @schema ComputeBackendServiceSpec#timeoutSec
   */
  readonly timeoutSec?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpec(obj: ComputeBackendServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinityCookieTtlSec': obj.affinityCookieTtlSec,
    'backend': obj.backend?.map(y => toJson_ComputeBackendServiceSpecBackend(y)),
    'cdnPolicy': toJson_ComputeBackendServiceSpecCdnPolicy(obj.cdnPolicy),
    'circuitBreakers': toJson_ComputeBackendServiceSpecCircuitBreakers(obj.circuitBreakers),
    'compressionMode': obj.compressionMode,
    'connectionDrainingTimeoutSec': obj.connectionDrainingTimeoutSec,
    'connectionTrackingPolicy': toJson_ComputeBackendServiceSpecConnectionTrackingPolicy(obj.connectionTrackingPolicy),
    'consistentHash': toJson_ComputeBackendServiceSpecConsistentHash(obj.consistentHash),
    'customRequestHeaders': obj.customRequestHeaders?.map(y => y),
    'customResponseHeaders': obj.customResponseHeaders?.map(y => y),
    'description': obj.description,
    'edgeSecurityPolicyRef': toJson_ComputeBackendServiceSpecEdgeSecurityPolicyRef(obj.edgeSecurityPolicyRef),
    'enableCdn': obj.enableCdn,
    'failoverPolicy': toJson_ComputeBackendServiceSpecFailoverPolicy(obj.failoverPolicy),
    'healthChecks': obj.healthChecks?.map(y => toJson_ComputeBackendServiceSpecHealthChecks(y)),
    'iap': toJson_ComputeBackendServiceSpecIap(obj.iap),
    'loadBalancingScheme': obj.loadBalancingScheme,
    'localityLbPolicies': obj.localityLbPolicies?.map(y => toJson_ComputeBackendServiceSpecLocalityLbPolicies(y)),
    'localityLbPolicy': obj.localityLbPolicy,
    'location': obj.location,
    'logConfig': toJson_ComputeBackendServiceSpecLogConfig(obj.logConfig),
    'networkRef': toJson_ComputeBackendServiceSpecNetworkRef(obj.networkRef),
    'outlierDetection': toJson_ComputeBackendServiceSpecOutlierDetection(obj.outlierDetection),
    'portName': obj.portName,
    'protocol': obj.protocol,
    'resourceID': obj.resourceId,
    'securityPolicyRef': toJson_ComputeBackendServiceSpecSecurityPolicyRef(obj.securityPolicyRef),
    'securitySettings': toJson_ComputeBackendServiceSpecSecuritySettings(obj.securitySettings),
    'sessionAffinity': obj.sessionAffinity,
    'subsetting': toJson_ComputeBackendServiceSpecSubsetting(obj.subsetting),
    'timeoutSec': obj.timeoutSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecBackend
 */
export interface ComputeBackendServiceSpecBackend {
  /**
   * Specifies the balancing mode for this backend.
   *
   * For global HTTP(S) or TCP/SSL load balancing, the default is
   * UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
   * and CONNECTION (for TCP/SSL).
   *
   * See the [Backend Services Overview](https://cloud.google.com/load-balancing/docs/backend-service#balancing-mode)
   * for an explanation of load balancing modes. Default value: "UTILIZATION" Possible values: ["UTILIZATION", "RATE", "CONNECTION"].
   *
   * @schema ComputeBackendServiceSpecBackend#balancingMode
   */
  readonly balancingMode?: string;

  /**
   * A multiplier applied to the group's maximum servicing capacity
   * (based on UTILIZATION, RATE or CONNECTION).
   *
   * Default value is 1, which means the group will serve up to 100%
   * of its configured capacity (depending on balancingMode). A
   * setting of 0 means the group is completely drained, offering
   * 0% of its available Capacity. Valid range is [0.0,1.0].
   *
   * @schema ComputeBackendServiceSpecBackend#capacityScaler
   */
  readonly capacityScaler?: number;

  /**
   * An optional description of this resource.
   * Provide this property when you create the resource.
   *
   * @schema ComputeBackendServiceSpecBackend#description
   */
  readonly description?: string;

  /**
   * This field designates whether this is a failover backend. More
   * than one failover backend can be configured for a given RegionBackendService.
   *
   * @schema ComputeBackendServiceSpecBackend#failover
   */
  readonly failover?: boolean;

  /**
   * Reference to a ComputeInstanceGroup or ComputeNetworkEndpointGroup
   * resource. In case of instance group this defines the list of
   * instances that serve traffic. Member virtual machine instances from
   * each instance group must live in the same zone as the instance
   * group itself. No two backends in a backend service are allowed to
   * use same Instance Group resource.
   *
   * For Network Endpoint Groups this defines list of endpoints. All
   * endpoints of Network Endpoint Group must be hosted on instances
   * located in the same zone as the Network Endpoint Group.
   *
   * Backend services cannot mix Instance Group and Network Endpoint
   * Group backends.
   *
   * When the 'load_balancing_scheme' is INTERNAL, only instance groups
   * are supported.
   *
   * @schema ComputeBackendServiceSpecBackend#group
   */
  readonly group: ComputeBackendServiceSpecBackendGroup;

  /**
   * The max number of simultaneous connections for the group. Can
   * be used with either CONNECTION or UTILIZATION balancing modes.
   *
   * For CONNECTION mode, either maxConnections or one
   * of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
   * as appropriate for group type, must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The max number of simultaneous connections that a single backend
   * network endpoint can handle. This is used to calculate the
   * capacity of the group. Can be used in either CONNECTION or
   * UTILIZATION balancing modes.
   *
   * For CONNECTION mode, either
   * maxConnections or maxConnectionsPerEndpoint must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxConnectionsPerEndpoint
   */
  readonly maxConnectionsPerEndpoint?: number;

  /**
   * The max number of simultaneous connections that a single
   * backend instance can handle. This is used to calculate the
   * capacity of the group. Can be used in either CONNECTION or
   * UTILIZATION balancing modes.
   *
   * For CONNECTION mode, either maxConnections or
   * maxConnectionsPerInstance must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxConnectionsPerInstance
   */
  readonly maxConnectionsPerInstance?: number;

  /**
   * The max requests per second (RPS) of the group.
   *
   * Can be used with either RATE or UTILIZATION balancing modes,
   * but required if RATE mode. For RATE mode, either maxRate or one
   * of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
   * group type, must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxRate
   */
  readonly maxRate?: number;

  /**
   * The max requests per second (RPS) that a single backend network
   * endpoint can handle. This is used to calculate the capacity of
   * the group. Can be used in either balancing mode. For RATE mode,
   * either maxRate or maxRatePerEndpoint must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxRatePerEndpoint
   */
  readonly maxRatePerEndpoint?: number;

  /**
   * The max requests per second (RPS) that a single backend
   * instance can handle. This is used to calculate the capacity of
   * the group. Can be used in either balancing mode. For RATE mode,
   * either maxRate or maxRatePerInstance must be set.
   *
   * @schema ComputeBackendServiceSpecBackend#maxRatePerInstance
   */
  readonly maxRatePerInstance?: number;

  /**
   * Used when balancingMode is UTILIZATION. This ratio defines the
   * CPU utilization target for the group. Valid range is [0.0, 1.0].
   *
   * @schema ComputeBackendServiceSpecBackend#maxUtilization
   */
  readonly maxUtilization?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecBackend' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecBackend(obj: ComputeBackendServiceSpecBackend | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'balancingMode': obj.balancingMode,
    'capacityScaler': obj.capacityScaler,
    'description': obj.description,
    'failover': obj.failover,
    'group': toJson_ComputeBackendServiceSpecBackendGroup(obj.group),
    'maxConnections': obj.maxConnections,
    'maxConnectionsPerEndpoint': obj.maxConnectionsPerEndpoint,
    'maxConnectionsPerInstance': obj.maxConnectionsPerInstance,
    'maxRate': obj.maxRate,
    'maxRatePerEndpoint': obj.maxRatePerEndpoint,
    'maxRatePerInstance': obj.maxRatePerInstance,
    'maxUtilization': obj.maxUtilization,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloud CDN configuration for this BackendService.
 *
 * @schema ComputeBackendServiceSpecCdnPolicy
 */
export interface ComputeBackendServiceSpecCdnPolicy {
  /**
   * Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
   * The cache is bypassed for all cdnPolicy.cacheMode settings.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#bypassCacheOnRequestHeaders
   */
  readonly bypassCacheOnRequestHeaders?: ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders[];

  /**
   * The CacheKeyPolicy for this CdnPolicy.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#cacheKeyPolicy
   */
  readonly cacheKeyPolicy?: ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy;

  /**
   * Specifies the cache setting for all responses from this backend.
   * The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"].
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#cacheMode
   */
  readonly cacheMode?: string;

  /**
   * Specifies the maximum allowed TTL for cached content served by this origin.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#clientTtl
   */
  readonly clientTtl?: number;

  /**
   * Specifies the default TTL for cached content served by this origin for responses
   * that do not have an existing valid TTL (max-age or s-max-age).
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#defaultTtl
   */
  readonly defaultTtl?: number;

  /**
   * Specifies the maximum allowed TTL for cached content served by this origin.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#maxTtl
   */
  readonly maxTtl?: number;

  /**
   * Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#negativeCaching
   */
  readonly negativeCaching?: boolean;

  /**
   * Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
   * Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#negativeCachingPolicy
   */
  readonly negativeCachingPolicy?: ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy[];

  /**
   * Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#serveWhileStale
   */
  readonly serveWhileStale?: number;

  /**
   * Maximum number of seconds the response to a signed URL request
   * will be considered fresh, defaults to 1hr (3600s). After this
   * time period, the response will be revalidated before
   * being served.
   *
   * When serving responses to signed URL requests, Cloud CDN will
   * internally behave as though all responses from this backend had a
   * "Cache-Control: public, max-age=[TTL]" header, regardless of any
   * existing Cache-Control header. The actual headers served in
   * responses will not be altered.
   *
   * @schema ComputeBackendServiceSpecCdnPolicy#signedUrlCacheMaxAgeSec
   */
  readonly signedUrlCacheMaxAgeSec?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCdnPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCdnPolicy(obj: ComputeBackendServiceSpecCdnPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bypassCacheOnRequestHeaders': obj.bypassCacheOnRequestHeaders?.map(y => toJson_ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders(y)),
    'cacheKeyPolicy': toJson_ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy(obj.cacheKeyPolicy),
    'cacheMode': obj.cacheMode,
    'clientTtl': obj.clientTtl,
    'defaultTtl': obj.defaultTtl,
    'maxTtl': obj.maxTtl,
    'negativeCaching': obj.negativeCaching,
    'negativeCachingPolicy': obj.negativeCachingPolicy?.map(y => toJson_ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy(y)),
    'serveWhileStale': obj.serveWhileStale,
    'signedUrlCacheMaxAgeSec': obj.signedUrlCacheMaxAgeSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling the volume of connections to a backend service. This field
 * is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
 *
 * @schema ComputeBackendServiceSpecCircuitBreakers
 */
export interface ComputeBackendServiceSpecCircuitBreakers {
  /**
   * The timeout for new network connections to hosts.
   *
   * @schema ComputeBackendServiceSpecCircuitBreakers#connectTimeout
   */
  readonly connectTimeout?: ComputeBackendServiceSpecCircuitBreakersConnectTimeout;

  /**
   * The maximum number of connections to the backend cluster.
   * Defaults to 1024.
   *
   * @default 1024.
   * @schema ComputeBackendServiceSpecCircuitBreakers#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The maximum number of pending requests to the backend cluster.
   * Defaults to 1024.
   *
   * @default 1024.
   * @schema ComputeBackendServiceSpecCircuitBreakers#maxPendingRequests
   */
  readonly maxPendingRequests?: number;

  /**
   * The maximum number of parallel requests to the backend cluster.
   * Defaults to 1024.
   *
   * @default 1024.
   * @schema ComputeBackendServiceSpecCircuitBreakers#maxRequests
   */
  readonly maxRequests?: number;

  /**
   * Maximum requests for a single backend connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 implementations. If
   * not specified, there is no limit. Setting this parameter to 1
   * will effectively disable keep alive.
   *
   * @schema ComputeBackendServiceSpecCircuitBreakers#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * The maximum number of parallel retries to the backend cluster.
   * Defaults to 3.
   *
   * @default 3.
   * @schema ComputeBackendServiceSpecCircuitBreakers#maxRetries
   */
  readonly maxRetries?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCircuitBreakers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCircuitBreakers(obj: ComputeBackendServiceSpecCircuitBreakers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': toJson_ComputeBackendServiceSpecCircuitBreakersConnectTimeout(obj.connectTimeout),
    'maxConnections': obj.maxConnections,
    'maxPendingRequests': obj.maxPendingRequests,
    'maxRequests': obj.maxRequests,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Connection Tracking configuration for this BackendService.
 * This is available only for Layer 4 Internal Load Balancing and
 * Network Load Balancing.
 *
 * @schema ComputeBackendServiceSpecConnectionTrackingPolicy
 */
export interface ComputeBackendServiceSpecConnectionTrackingPolicy {
  /**
   * Specifies connection persistence when backends are unhealthy.
   *
   * If set to 'DEFAULT_FOR_PROTOCOL', the existing connections persist on
   * unhealthy backends only for connection-oriented protocols (TCP and SCTP)
   * and only if the Tracking Mode is PER_CONNECTION (default tracking mode)
   * or the Session Affinity is configured for 5-tuple. They do not persist
   * for UDP.
   *
   * If set to 'NEVER_PERSIST', after a backend becomes unhealthy, the existing
   * connections on the unhealthy backend are never persisted on the unhealthy
   * backend. They are always diverted to newly selected healthy backends
   * (unless all backends are unhealthy).
   *
   * If set to 'ALWAYS_PERSIST', existing connections always persist on
   * unhealthy backends regardless of protocol and session affinity. It is
   * generally not recommended to use this mode overriding the default. Default value: "DEFAULT_FOR_PROTOCOL" Possible values: ["DEFAULT_FOR_PROTOCOL", "NEVER_PERSIST", "ALWAYS_PERSIST"].
   *
   * @schema ComputeBackendServiceSpecConnectionTrackingPolicy#connectionPersistenceOnUnhealthyBackends
   */
  readonly connectionPersistenceOnUnhealthyBackends?: string;

  /**
   * Specifies how long to keep a Connection Tracking entry while there is
   * no matching traffic (in seconds).
   *
   * For L4 ILB the minimum(default) is 10 minutes and maximum is 16 hours.
   *
   * For NLB the minimum(default) is 60 seconds and the maximum is 16 hours.
   *
   * @schema ComputeBackendServiceSpecConnectionTrackingPolicy#idleTimeoutSec
   */
  readonly idleTimeoutSec?: number;

  /**
   * Specifies the key used for connection tracking. There are two options:
   * 'PER_CONNECTION': The Connection Tracking is performed as per the
   * Connection Key (default Hash Method) for the specific protocol.
   *
   * 'PER_SESSION': The Connection Tracking is performed as per the
   * configured Session Affinity. It matches the configured Session Affinity. Default value: "PER_CONNECTION" Possible values: ["PER_CONNECTION", "PER_SESSION"].
   *
   * @schema ComputeBackendServiceSpecConnectionTrackingPolicy#trackingMode
   */
  readonly trackingMode?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecConnectionTrackingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecConnectionTrackingPolicy(obj: ComputeBackendServiceSpecConnectionTrackingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPersistenceOnUnhealthyBackends': obj.connectionPersistenceOnUnhealthyBackends,
    'idleTimeoutSec': obj.idleTimeoutSec,
    'trackingMode': obj.trackingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Consistent Hash-based load balancing can be used to provide soft session
 * affinity based on HTTP headers, cookies or other properties. This load balancing
 * policy is applicable only for HTTP connections. The affinity to a particular
 * destination host will be lost when one or more hosts are added/removed from the
 * destination service. This field specifies parameters that control consistent
 * hashing. This field only applies if the load_balancing_scheme is set to
 * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
 * set to MAGLEV or RING_HASH.
 *
 * @schema ComputeBackendServiceSpecConsistentHash
 */
export interface ComputeBackendServiceSpecConsistentHash {
  /**
   * Hash is based on HTTP Cookie. This field describes a HTTP cookie
   * that will be used as the hash key for the consistent hash load
   * balancer. If the cookie is not present, it will be generated.
   * This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
   *
   * @schema ComputeBackendServiceSpecConsistentHash#httpCookie
   */
  readonly httpCookie?: ComputeBackendServiceSpecConsistentHashHttpCookie;

  /**
   * The hash based on the value of the specified header field.
   * This field is applicable if the sessionAffinity is set to HEADER_FIELD.
   *
   * @schema ComputeBackendServiceSpecConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * The minimum number of virtual nodes to use for the hash ring.
   * Larger ring sizes result in more granular load
   * distributions. If the number of hosts in the load balancing pool
   * is larger than the ring size, each host will be assigned a single
   * virtual node.
   * Defaults to 1024.
   *
   * @default 1024.
   * @schema ComputeBackendServiceSpecConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecConsistentHash(obj: ComputeBackendServiceSpecConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_ComputeBackendServiceSpecConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The resource URL for the edge security policy associated with this
 * backend service.
 *
 * @schema ComputeBackendServiceSpecEdgeSecurityPolicyRef
 */
export interface ComputeBackendServiceSpecEdgeSecurityPolicyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSecurityPolicy` resource.
   *
   * @schema ComputeBackendServiceSpecEdgeSecurityPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecEdgeSecurityPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecEdgeSecurityPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecEdgeSecurityPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecEdgeSecurityPolicyRef(obj: ComputeBackendServiceSpecEdgeSecurityPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy for failovers.
 *
 * @schema ComputeBackendServiceSpecFailoverPolicy
 */
export interface ComputeBackendServiceSpecFailoverPolicy {
  /**
   * On failover or failback, this field indicates whether connection drain
   * will be honored. Setting this to true has the following effect: connections
   * to the old active pool are not drained. Connections to the new active pool
   * use the timeout of 10 min (currently fixed). Setting to false has the
   * following effect: both old and new connections will have a drain timeout
   * of 10 min.
   * This can be set to true only if the protocol is TCP.
   * The default is false.
   *
   * @schema ComputeBackendServiceSpecFailoverPolicy#disableConnectionDrainOnFailover
   */
  readonly disableConnectionDrainOnFailover?: boolean;

  /**
   * This option is used only when no healthy VMs are detected in the primary
   * and backup instance groups. When set to true, traffic is dropped. When
   * set to false, new connections are sent across all VMs in the primary group.
   * The default is false.
   *
   * @schema ComputeBackendServiceSpecFailoverPolicy#dropTrafficIfUnhealthy
   */
  readonly dropTrafficIfUnhealthy?: boolean;

  /**
   * The value of the field must be in [0, 1]. If the ratio of the healthy
   * VMs in the primary backend is at or below this number, traffic arriving
   * at the load-balanced IP will be directed to the failover backend.
   * In case where 'failoverRatio' is not set or all the VMs in the backup
   * backend are unhealthy, the traffic will be directed back to the primary
   * backend in the "force" mode, where traffic will be spread to the healthy
   * VMs with the best effort, or to all VMs when no VM is healthy.
   * This field is only used with l4 load balancing.
   *
   * @schema ComputeBackendServiceSpecFailoverPolicy#failoverRatio
   */
  readonly failoverRatio?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecFailoverPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecFailoverPolicy(obj: ComputeBackendServiceSpecFailoverPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableConnectionDrainOnFailover': obj.disableConnectionDrainOnFailover,
    'dropTrafficIfUnhealthy': obj.dropTrafficIfUnhealthy,
    'failoverRatio': obj.failoverRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The health check resources for health checking this
 * ComputeBackendService. Currently at most one health check can be
 * specified, and a health check is required.
 *
 * @schema ComputeBackendServiceSpecHealthChecks
 */
export interface ComputeBackendServiceSpecHealthChecks {
  /**
   * @schema ComputeBackendServiceSpecHealthChecks#healthCheckRef
   */
  readonly healthCheckRef?: ComputeBackendServiceSpecHealthChecksHealthCheckRef;

  /**
   * @schema ComputeBackendServiceSpecHealthChecks#httpHealthCheckRef
   */
  readonly httpHealthCheckRef?: ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecHealthChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecHealthChecks(obj: ComputeBackendServiceSpecHealthChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckRef': toJson_ComputeBackendServiceSpecHealthChecksHealthCheckRef(obj.healthCheckRef),
    'httpHealthCheckRef': toJson_ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef(obj.httpHealthCheckRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings for enabling Cloud Identity Aware Proxy.
 *
 * @schema ComputeBackendServiceSpecIap
 */
export interface ComputeBackendServiceSpecIap {
  /**
   * DEPRECATED. Although this field is still available, there is limited support. We recommend that you use `spec.iap.oauth2ClientIdRef` instead.
   *
   * @schema ComputeBackendServiceSpecIap#oauth2ClientId
   */
  readonly oauth2ClientId?: string;

  /**
   * OAuth2 Client ID for IAP.
   *
   * @schema ComputeBackendServiceSpecIap#oauth2ClientIdRef
   */
  readonly oauth2ClientIdRef?: ComputeBackendServiceSpecIapOauth2ClientIdRef;

  /**
   * OAuth2 Client Secret for IAP.
   *
   * @schema ComputeBackendServiceSpecIap#oauth2ClientSecret
   */
  readonly oauth2ClientSecret?: ComputeBackendServiceSpecIapOauth2ClientSecret;

  /**
   * OAuth2 Client Secret SHA-256 for IAP.
   *
   * @schema ComputeBackendServiceSpecIap#oauth2ClientSecretSha256
   */
  readonly oauth2ClientSecretSha256?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecIap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecIap(obj: ComputeBackendServiceSpecIap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oauth2ClientId': obj.oauth2ClientId,
    'oauth2ClientIdRef': toJson_ComputeBackendServiceSpecIapOauth2ClientIdRef(obj.oauth2ClientIdRef),
    'oauth2ClientSecret': toJson_ComputeBackendServiceSpecIapOauth2ClientSecret(obj.oauth2ClientSecret),
    'oauth2ClientSecretSha256': obj.oauth2ClientSecretSha256,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecLocalityLbPolicies
 */
export interface ComputeBackendServiceSpecLocalityLbPolicies {
  /**
   * The configuration for a custom policy implemented by the user and
   * deployed with the client.
   *
   * @schema ComputeBackendServiceSpecLocalityLbPolicies#customPolicy
   */
  readonly customPolicy?: ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy;

  /**
   * The configuration for a built-in load balancing policy.
   *
   * @schema ComputeBackendServiceSpecLocalityLbPolicies#policy
   */
  readonly policy?: ComputeBackendServiceSpecLocalityLbPoliciesPolicy;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecLocalityLbPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecLocalityLbPolicies(obj: ComputeBackendServiceSpecLocalityLbPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customPolicy': toJson_ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy(obj.customPolicy),
    'policy': toJson_ComputeBackendServiceSpecLocalityLbPoliciesPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field denotes the logging options for the load balancer traffic served by this backend service.
 * If logging is enabled, logs will be exported to Stackdriver.
 *
 * @schema ComputeBackendServiceSpecLogConfig
 */
export interface ComputeBackendServiceSpecLogConfig {
  /**
   * Whether to enable logging for the load balancer traffic served by this backend service.
   *
   * @schema ComputeBackendServiceSpecLogConfig#enable
   */
  readonly enable?: boolean;

  /**
   * This field can only be specified if logging is enabled for this backend service. The value of
   * the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
   * where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
   * The default value is 1.0.
   *
   * @schema ComputeBackendServiceSpecLogConfig#sampleRate
   */
  readonly sampleRate?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecLogConfig(obj: ComputeBackendServiceSpecLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'sampleRate': obj.sampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network to which this backend service belongs.  This field can
 * only be specified when the load balancing scheme is set to
 * INTERNAL.
 *
 * @schema ComputeBackendServiceSpecNetworkRef
 */
export interface ComputeBackendServiceSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeBackendServiceSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecNetworkRef(obj: ComputeBackendServiceSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Settings controlling eviction of unhealthy hosts from the load balancing pool.
 * This field is applicable only when the load_balancing_scheme is set
 * to INTERNAL_SELF_MANAGED.
 *
 * @schema ComputeBackendServiceSpecOutlierDetection
 */
export interface ComputeBackendServiceSpecOutlierDetection {
  /**
   * The base time that a host is ejected for. The real time is equal to the base
   * time multiplied by the number of times the host has been ejected. Defaults to
   * 30000ms or 30s.
   *
   * @default 30000ms or 30s.
   * @schema ComputeBackendServiceSpecOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime;

  /**
   * Number of errors before a host is ejected from the connection pool. When the
   * backend host is accessed over HTTP, a 5xx return code qualifies as an error.
   * Defaults to 5.
   *
   * @default 5.
   * @schema ComputeBackendServiceSpecOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * The number of consecutive gateway failures (502, 503, 504 status or connection
   * errors that are mapped to one of those status codes) before a consecutive
   * gateway failure ejection occurs. Defaults to 5.
   *
   * @default 5.
   * @schema ComputeBackendServiceSpecOutlierDetection#consecutiveGatewayFailure
   */
  readonly consecutiveGatewayFailure?: number;

  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through consecutive 5xx. This setting can be used to disable
   * ejection or to ramp it up slowly. Defaults to 100.
   *
   * @default 100.
   * @schema ComputeBackendServiceSpecOutlierDetection#enforcingConsecutiveErrors
   */
  readonly enforcingConsecutiveErrors?: number;

  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through consecutive gateway failures. This setting can be
   * used to disable ejection or to ramp it up slowly. Defaults to 0.
   *
   * @default 0.
   * @schema ComputeBackendServiceSpecOutlierDetection#enforcingConsecutiveGatewayFailure
   */
  readonly enforcingConsecutiveGatewayFailure?: number;

  /**
   * The percentage chance that a host will be actually ejected when an outlier
   * status is detected through success rate statistics. This setting can be used to
   * disable ejection or to ramp it up slowly. Defaults to 100.
   *
   * @default 100.
   * @schema ComputeBackendServiceSpecOutlierDetection#enforcingSuccessRate
   */
  readonly enforcingSuccessRate?: number;

  /**
   * Time interval between ejection sweep analysis. This can result in both new
   * ejections as well as hosts being returned to service. Defaults to 10 seconds.
   *
   * @default 10 seconds.
   * @schema ComputeBackendServiceSpecOutlierDetection#interval
   */
  readonly interval?: ComputeBackendServiceSpecOutlierDetectionInterval;

  /**
   * Maximum percentage of hosts in the load balancing pool for the backend service
   * that can be ejected. Defaults to 10%.
   *
   * @default 10%.
   * @schema ComputeBackendServiceSpecOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * The number of hosts in a cluster that must have enough request volume to detect
   * success rate outliers. If the number of hosts is less than this setting, outlier
   * detection via success rate statistics is not performed for any host in the
   * cluster. Defaults to 5.
   *
   * @default 5.
   * @schema ComputeBackendServiceSpecOutlierDetection#successRateMinimumHosts
   */
  readonly successRateMinimumHosts?: number;

  /**
   * The minimum number of total requests that must be collected in one interval (as
   * defined by the interval duration above) to include this host in success rate
   * based outlier detection. If the volume is lower than this setting, outlier
   * detection via success rate statistics is not performed for that host. Defaults
   * to 100.
   *
   * @default 100.
   * @schema ComputeBackendServiceSpecOutlierDetection#successRateRequestVolume
   */
  readonly successRateRequestVolume?: number;

  /**
   * This factor is used to determine the ejection threshold for success rate outlier
   * ejection. The ejection threshold is the difference between the mean success
   * rate, and the product of this factor and the standard deviation of the mean
   * success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
   * by a thousand to get a double. That is, if the desired factor is 1.9, the
   * runtime value should be 1900. Defaults to 1900.
   *
   * @default 1900.
   * @schema ComputeBackendServiceSpecOutlierDetection#successRateStdevFactor
   */
  readonly successRateStdevFactor?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecOutlierDetection(obj: ComputeBackendServiceSpecOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': toJson_ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime(obj.baseEjectionTime),
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayFailure': obj.consecutiveGatewayFailure,
    'enforcingConsecutiveErrors': obj.enforcingConsecutiveErrors,
    'enforcingConsecutiveGatewayFailure': obj.enforcingConsecutiveGatewayFailure,
    'enforcingSuccessRate': obj.enforcingSuccessRate,
    'interval': toJson_ComputeBackendServiceSpecOutlierDetectionInterval(obj.interval),
    'maxEjectionPercent': obj.maxEjectionPercent,
    'successRateMinimumHosts': obj.successRateMinimumHosts,
    'successRateRequestVolume': obj.successRateRequestVolume,
    'successRateStdevFactor': obj.successRateStdevFactor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The security policy associated with this backend service.
 *
 * @schema ComputeBackendServiceSpecSecurityPolicyRef
 */
export interface ComputeBackendServiceSpecSecurityPolicyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSecurityPolicy` resource.
   *
   * @schema ComputeBackendServiceSpecSecurityPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecSecurityPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecSecurityPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecSecurityPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecSecurityPolicyRef(obj: ComputeBackendServiceSpecSecurityPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The security settings that apply to this backend service. This field is applicable to either
 * a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
 * load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
 * load_balancing_scheme set to INTERNAL_SELF_MANAGED.
 *
 * @schema ComputeBackendServiceSpecSecuritySettings
 */
export interface ComputeBackendServiceSpecSecuritySettings {
  /**
   * ClientTlsPolicy is a resource that specifies how a client should
   * authenticate connections to backends of a service. This resource itself
   * does not affect configuration unless it is attached to a backend
   * service resource.
   *
   * @schema ComputeBackendServiceSpecSecuritySettings#clientTLSPolicyRef
   */
  readonly clientTlsPolicyRef: ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   * If specified, the client will verify that the server certificate's subject
   * alt name matches one of the specified values.
   *
   * @schema ComputeBackendServiceSpecSecuritySettings#subjectAltNames
   */
  readonly subjectAltNames: string[];

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecSecuritySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecSecuritySettings(obj: ComputeBackendServiceSpecSecuritySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientTLSPolicyRef': toJson_ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef(obj.clientTlsPolicyRef),
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing and Internal HTTP(S) load balancing.
 *
 * @schema ComputeBackendServiceSpecSubsetting
 */
export interface ComputeBackendServiceSpecSubsetting {
  /**
   * The algorithm used for subsetting. Possible values: ["CONSISTENT_HASH_SUBSETTING"].
   *
   * @schema ComputeBackendServiceSpecSubsetting#policy
   */
  readonly policy: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecSubsetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecSubsetting(obj: ComputeBackendServiceSpecSubsetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ComputeInstanceGroup or ComputeNetworkEndpointGroup
 * resource. In case of instance group this defines the list of
 * instances that serve traffic. Member virtual machine instances from
 * each instance group must live in the same zone as the instance
 * group itself. No two backends in a backend service are allowed to
 * use same Instance Group resource.
 *
 * For Network Endpoint Groups this defines list of endpoints. All
 * endpoints of Network Endpoint Group must be hosted on instances
 * located in the same zone as the Network Endpoint Group.
 *
 * Backend services cannot mix Instance Group and Network Endpoint
 * Group backends.
 *
 * When the 'load_balancing_scheme' is INTERNAL, only instance groups
 * are supported.
 *
 * @schema ComputeBackendServiceSpecBackendGroup
 */
export interface ComputeBackendServiceSpecBackendGroup {
  /**
   * @schema ComputeBackendServiceSpecBackendGroup#instanceGroupRef
   */
  readonly instanceGroupRef?: ComputeBackendServiceSpecBackendGroupInstanceGroupRef;

  /**
   * @schema ComputeBackendServiceSpecBackendGroup#networkEndpointGroupRef
   */
  readonly networkEndpointGroupRef?: ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecBackendGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecBackendGroup(obj: ComputeBackendServiceSpecBackendGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceGroupRef': toJson_ComputeBackendServiceSpecBackendGroupInstanceGroupRef(obj.instanceGroupRef),
    'networkEndpointGroupRef': toJson_ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef(obj.networkEndpointGroupRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders
 */
export interface ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders {
  /**
   * The header field name to match on when bypassing cache. Values are case-insensitive.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders#headerName
   */
  readonly headerName: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders(obj: ComputeBackendServiceSpecCdnPolicyBypassCacheOnRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The CacheKeyPolicy for this CdnPolicy.
 *
 * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy
 */
export interface ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy {
  /**
   * If true requests to different hosts will be cached separately.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#includeHost
   */
  readonly includeHost?: boolean;

  /**
   * Allows HTTP request headers (by name) to be used in the
   * cache key.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#includeHttpHeaders
   */
  readonly includeHttpHeaders?: string[];

  /**
   * Names of cookies to include in cache keys.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#includeNamedCookies
   */
  readonly includeNamedCookies?: string[];

  /**
   * If true, http and https requests will be cached separately.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#includeProtocol
   */
  readonly includeProtocol?: boolean;

  /**
   * If true, include query string parameters in the cache key
   * according to query_string_whitelist and
   * query_string_blacklist. If neither is set, the entire query
   * string will be included.
   *
   * If false, the query string will be excluded from the cache
   * key entirely.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#includeQueryString
   */
  readonly includeQueryString?: boolean;

  /**
   * Names of query string parameters to exclude in cache keys.
   *
   * All other parameters will be included. Either specify
   * query_string_whitelist or query_string_blacklist, not both.
   * '&' and '=' will be percent encoded and not treated as
   * delimiters.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#queryStringBlacklist
   */
  readonly queryStringBlacklist?: string[];

  /**
   * Names of query string parameters to include in cache keys.
   *
   * All other parameters will be excluded. Either specify
   * query_string_whitelist or query_string_blacklist, not both.
   * '&' and '=' will be percent encoded and not treated as
   * delimiters.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy#queryStringWhitelist
   */
  readonly queryStringWhitelist?: string[];

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy(obj: ComputeBackendServiceSpecCdnPolicyCacheKeyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includeHost': obj.includeHost,
    'includeHttpHeaders': obj.includeHttpHeaders?.map(y => y),
    'includeNamedCookies': obj.includeNamedCookies?.map(y => y),
    'includeProtocol': obj.includeProtocol,
    'includeQueryString': obj.includeQueryString,
    'queryStringBlacklist': obj.queryStringBlacklist?.map(y => y),
    'queryStringWhitelist': obj.queryStringWhitelist?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy
 */
export interface ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy {
  /**
   * The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
   * can be specified as values, and you cannot specify a status code more than once.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy#code
   */
  readonly code?: number;

  /**
   * The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
   * (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
   *
   * @schema ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy(obj: ComputeBackendServiceSpecCdnPolicyNegativeCachingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The timeout for new network connections to hosts.
 *
 * @schema ComputeBackendServiceSpecCircuitBreakersConnectTimeout
 */
export interface ComputeBackendServiceSpecCircuitBreakersConnectTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond
   * resolution. Durations less than one second are represented
   * with a 0 seconds field and a positive nanos field. Must
   * be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeBackendServiceSpecCircuitBreakersConnectTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second.
   * Must be from 0 to 315,576,000,000 inclusive.
   *
   * @schema ComputeBackendServiceSpecCircuitBreakersConnectTimeout#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecCircuitBreakersConnectTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecCircuitBreakersConnectTimeout(obj: ComputeBackendServiceSpecCircuitBreakersConnectTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hash is based on HTTP Cookie. This field describes a HTTP cookie
 * that will be used as the hash key for the consistent hash load
 * balancer. If the cookie is not present, it will be generated.
 * This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
 *
 * @schema ComputeBackendServiceSpecConsistentHashHttpCookie
 */
export interface ComputeBackendServiceSpecConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema ComputeBackendServiceSpecConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema ComputeBackendServiceSpecConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema ComputeBackendServiceSpecConsistentHashHttpCookie#ttl
   */
  readonly ttl?: ComputeBackendServiceSpecConsistentHashHttpCookieTtl;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecConsistentHashHttpCookie(obj: ComputeBackendServiceSpecConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': toJson_ComputeBackendServiceSpecConsistentHashHttpCookieTtl(obj.ttl),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecHealthChecksHealthCheckRef
 */
export interface ComputeBackendServiceSpecHealthChecksHealthCheckRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeHealthCheck` resource.
   *
   * @schema ComputeBackendServiceSpecHealthChecksHealthCheckRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecHealthChecksHealthCheckRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecHealthChecksHealthCheckRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecHealthChecksHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecHealthChecksHealthCheckRef(obj: ComputeBackendServiceSpecHealthChecksHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef
 */
export interface ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeHTTPHealthCheck` resource.
   *
   * @schema ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef(obj: ComputeBackendServiceSpecHealthChecksHttpHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 Client ID for IAP.
 *
 * @schema ComputeBackendServiceSpecIapOauth2ClientIdRef
 */
export interface ComputeBackendServiceSpecIapOauth2ClientIdRef {
  /**
   * Allowed value: The `name` field of an `IAPIdentityAwareProxyClient` resource.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientIdRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientIdRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientIdRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecIapOauth2ClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecIapOauth2ClientIdRef(obj: ComputeBackendServiceSpecIapOauth2ClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 Client Secret for IAP.
 *
 * @schema ComputeBackendServiceSpecIapOauth2ClientSecret
 */
export interface ComputeBackendServiceSpecIapOauth2ClientSecret {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientSecret#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientSecret#valueFrom
   */
  readonly valueFrom?: ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecIapOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecIapOauth2ClientSecret(obj: ComputeBackendServiceSpecIapOauth2ClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for a custom policy implemented by the user and
 * deployed with the client.
 *
 * @schema ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy
 */
export interface ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy {
  /**
   * An optional, arbitrary JSON object with configuration data, understood
   * by a locally installed custom policy implementation.
   *
   * @schema ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy#data
   */
  readonly data?: string;

  /**
   * Identifies the custom policy.
   *
   * The value should match the type the custom implementation is registered
   * with on the gRPC clients. It should follow protocol buffer
   * message naming conventions and include the full path (e.g.
   * myorg.CustomLbPolicy). The maximum length is 256 characters.
   *
   * Note that specifying the same custom policy more than once for a
   * backend is not a valid configuration and will be rejected.
   *
   * @schema ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy(obj: ComputeBackendServiceSpecLocalityLbPoliciesCustomPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration for a built-in load balancing policy.
 *
 * @schema ComputeBackendServiceSpecLocalityLbPoliciesPolicy
 */
export interface ComputeBackendServiceSpecLocalityLbPoliciesPolicy {
  /**
   * The name of a locality load balancer policy to be used. The value
   * should be one of the predefined ones as supported by localityLbPolicy,
   * although at the moment only ROUND_ROBIN is supported.
   *
   * This field should only be populated when the customPolicy field is not
   * used.
   *
   * Note that specifying the same policy more than once for a backend is
   * not a valid configuration and will be rejected.
   *
   * The possible values are:
   *
   * * 'ROUND_ROBIN': This is a simple policy in which each healthy backend
   * is selected in round robin order.
   *
   * * 'LEAST_REQUEST': An O(1) algorithm which selects two random healthy
   * hosts and picks the host which has fewer active requests.
   *
   * * 'RING_HASH': The ring/modulo hash load balancer implements consistent
   * hashing to backends. The algorithm has the property that the
   * addition/removal of a host from a set of N hosts only affects
   * 1/N of the requests.
   *
   * * 'RANDOM': The load balancer selects a random healthy host.
   *
   * * 'ORIGINAL_DESTINATION': Backend host is selected based on the client
   * connection metadata, i.e., connections are opened
   * to the same address as the destination address of
   * the incoming connection before the connection
   * was redirected to the load balancer.
   *
   * * 'MAGLEV': used as a drop in replacement for the ring hash load balancer.
   * Maglev is not as stable as ring hash but has faster table lookup
   * build times and host selection times. For more information about
   * Maglev, refer to https://ai.google/research/pubs/pub44824 Possible values: ["ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM", "ORIGINAL_DESTINATION", "MAGLEV"].
   *
   * @schema ComputeBackendServiceSpecLocalityLbPoliciesPolicy#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecLocalityLbPoliciesPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecLocalityLbPoliciesPolicy(obj: ComputeBackendServiceSpecLocalityLbPoliciesPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The base time that a host is ejected for. The real time is equal to the base
 * time multiplied by the number of times the host has been ejected. Defaults to
 * 30000ms or 30s.
 *
 * @default 30000ms or 30s.
 * @schema ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime
 */
export interface ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime(obj: ComputeBackendServiceSpecOutlierDetectionBaseEjectionTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Time interval between ejection sweep analysis. This can result in both new
 * ejections as well as hosts being returned to service. Defaults to 10 seconds.
 *
 * @default 10 seconds.
 * @schema ComputeBackendServiceSpecOutlierDetectionInterval
 */
export interface ComputeBackendServiceSpecOutlierDetectionInterval {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeBackendServiceSpecOutlierDetectionInterval#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeBackendServiceSpecOutlierDetectionInterval#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecOutlierDetectionInterval' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecOutlierDetectionInterval(obj: ComputeBackendServiceSpecOutlierDetectionInterval | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientTlsPolicy is a resource that specifies how a client should
 * authenticate connections to backends of a service. This resource itself
 * does not affect configuration unless it is attached to a backend
 * service resource.
 *
 * @schema ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef
 */
export interface ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef {
  /**
   * Allowed value: The `name` field of a `NetworkSecurityClientTLSPolicy` resource.
   *
   * @schema ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef(obj: ComputeBackendServiceSpecSecuritySettingsClientTlsPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecBackendGroupInstanceGroupRef
 */
export interface ComputeBackendServiceSpecBackendGroupInstanceGroupRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstanceGroup` resource.
   *
   * @schema ComputeBackendServiceSpecBackendGroupInstanceGroupRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecBackendGroupInstanceGroupRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecBackendGroupInstanceGroupRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecBackendGroupInstanceGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecBackendGroupInstanceGroupRef(obj: ComputeBackendServiceSpecBackendGroupInstanceGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef
 */
export interface ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetworkEndpointGroup` resource.
   *
   * @schema ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef(obj: ComputeBackendServiceSpecBackendGroupNetworkEndpointGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lifetime of the cookie.
 *
 * @schema ComputeBackendServiceSpecConsistentHashHttpCookieTtl
 */
export interface ComputeBackendServiceSpecConsistentHashHttpCookieTtl {
  /**
   * Span of time that's a fraction of a second at nanosecond
   * resolution. Durations less than one second are represented
   * with a 0 seconds field and a positive nanos field. Must
   * be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeBackendServiceSpecConsistentHashHttpCookieTtl#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second.
   * Must be from 0 to 315,576,000,000 inclusive.
   *
   * @schema ComputeBackendServiceSpecConsistentHashHttpCookieTtl#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecConsistentHashHttpCookieTtl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecConsistentHashHttpCookieTtl(obj: ComputeBackendServiceSpecConsistentHashHttpCookieTtl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom
 */
export interface ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom(obj: ComputeBackendServiceSpecIapOauth2ClientSecretValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef
 */
export interface ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef(obj: ComputeBackendServiceSpecIapOauth2ClientSecretValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeDisk
 */
export class ComputeDisk extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeDisk"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeDisk',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeDisk".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeDiskProps): any {
    return {
      ...ComputeDisk.GVK,
      ...toJson_ComputeDiskProps(props),
    };
  }

  /**
   * Defines a "ComputeDisk" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeDiskProps) {
    super(scope, id, {
      ...ComputeDisk.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeDisk.GVK,
      ...toJson_ComputeDiskProps(resolved),
    };
  }
}

/**
 * @schema ComputeDisk
 */
export interface ComputeDiskProps {
  /**
   * @schema ComputeDisk#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeDisk#spec
   */
  readonly spec: ComputeDiskSpec;

}

/**
 * Converts an object of type 'ComputeDiskProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskProps(obj: ComputeDiskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeDiskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeDiskSpec
 */
export interface ComputeDiskSpec {
  /**
   * Immutable. A nested object resource.
   *
   * @schema ComputeDiskSpec#asyncPrimaryDisk
   */
  readonly asyncPrimaryDisk?: ComputeDiskSpecAsyncPrimaryDisk;

  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeDiskSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Encrypts the disk using a customer-supplied encryption key.
   *
   * After you encrypt a disk with a customer-supplied key, you must
   * provide the same key if you use the disk later (e.g. to create a disk
   * snapshot or an image, or to attach the disk to a virtual machine).
   *
   * Customer-supplied encryption keys do not protect access to metadata of
   * the disk.
   *
   * If you do not provide an encryption key when creating the disk, then
   * the disk will be encrypted using an automatically generated key and
   * you do not need to provide a key to use the disk later.
   *
   * @schema ComputeDiskSpec#diskEncryptionKey
   */
  readonly diskEncryptionKey?: ComputeDiskSpecDiskEncryptionKey;

  /**
   * Immutable. Whether this disk is using confidential compute mode.
   * Note: Only supported on hyperdisk skus, disk_encryption_key is required when setting to true.
   *
   * @schema ComputeDiskSpec#enableConfidentialCompute
   */
  readonly enableConfidentialCompute?: boolean;

  /**
   * Immutable. A list of features to enable on the guest operating system.
   * Applicable only for bootable disks.
   *
   * @schema ComputeDiskSpec#guestOsFeatures
   */
  readonly guestOsFeatures?: ComputeDiskSpecGuestOsFeatures[];

  /**
   * The image from which to initialize this disk.
   *
   * @schema ComputeDiskSpec#imageRef
   */
  readonly imageRef?: ComputeDiskSpecImageRef;

  /**
   * DEPRECATED. This field is no longer in use, disk interfaces will be automatically determined on attachment. To resolve this issue, remove this field from your config. Immutable. Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
   *
   * @schema ComputeDiskSpec#interface
   */
  readonly interface?: string;

  /**
   * Immutable. Any applicable license URI.
   *
   * @schema ComputeDiskSpec#licenses
   */
  readonly licenses?: string[];

  /**
   * Location represents the geographical location of the ComputeDisk. Specify a region name or a zone name. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeDiskSpec#location
   */
  readonly location: string;

  /**
   * Immutable. Indicates whether or not the disk can be read/write attached to more than one instance.
   *
   * @schema ComputeDiskSpec#multiWriter
   */
  readonly multiWriter?: boolean;

  /**
   * Immutable. Physical block size of the persistent disk, in bytes. If not present
   * in a request, a default value is used. Currently supported sizes
   * are 4096 and 16384, other sizes may be added in the future.
   * If an unsupported value is requested, the error message will list
   * the supported values for the caller's project.
   *
   * @schema ComputeDiskSpec#physicalBlockSizeBytes
   */
  readonly physicalBlockSizeBytes?: number;

  /**
   * The project that this resource belongs to.
   *
   * @schema ComputeDiskSpec#projectRef
   */
  readonly projectRef?: ComputeDiskSpecProjectRef;

  /**
   * Indicates how many IOPS must be provisioned for the disk.
   * Note: Updating currently is only supported by hyperdisk skus without the need to delete and recreate the disk, hyperdisk
   * allows for an update of IOPS every 4 hours. To update your hyperdisk more frequently, you'll need to manually delete and recreate it.
   *
   * @schema ComputeDiskSpec#provisionedIops
   */
  readonly provisionedIops?: number;

  /**
   * Indicates how much Throughput must be provisioned for the disk.
   * Note: Updating currently is only supported by hyperdisk skus without the need to delete and recreate the disk, hyperdisk
   * allows for an update of Throughput every 4 hours. To update your hyperdisk more frequently, you'll need to manually delete and recreate it.
   *
   * @schema ComputeDiskSpec#provisionedThroughput
   */
  readonly provisionedThroughput?: number;

  /**
   * Immutable. URLs of the zones where the disk should be replicated to.
   *
   * @schema ComputeDiskSpec#replicaZones
   */
  readonly replicaZones?: string[];

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeDiskSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeDiskSpec#resourcePolicies
   */
  readonly resourcePolicies?: ComputeDiskSpecResourcePolicies[];

  /**
   * Size of the persistent disk, specified in GB. You can specify this
   * field when creating a persistent disk using the 'image' or
   * 'snapshot' parameter, or specify it alone to create an empty
   * persistent disk.
   *
   * If you specify this field along with 'image' or 'snapshot',
   * the value must not be less than the size of the image
   * or the size of the snapshot.
   *
   * Upsizing the disk is mutable, but downsizing the disk
   * requires re-creating the resource.
   *
   * @schema ComputeDiskSpec#size
   */
  readonly size?: number;

  /**
   * The source snapshot used to create this disk.
   *
   * @schema ComputeDiskSpec#snapshotRef
   */
  readonly snapshotRef?: ComputeDiskSpecSnapshotRef;

  /**
   * The source disk used to create this disk.
   *
   * @schema ComputeDiskSpec#sourceDiskRef
   */
  readonly sourceDiskRef?: ComputeDiskSpecSourceDiskRef;

  /**
   * Immutable. The customer-supplied encryption key of the source image. Required if
   * the source image is protected by a customer-supplied encryption key.
   *
   * @schema ComputeDiskSpec#sourceImageEncryptionKey
   */
  readonly sourceImageEncryptionKey?: ComputeDiskSpecSourceImageEncryptionKey;

  /**
   * Immutable. The customer-supplied encryption key of the source snapshot. Required
   * if the source snapshot is protected by a customer-supplied encryption
   * key.
   *
   * @schema ComputeDiskSpec#sourceSnapshotEncryptionKey
   */
  readonly sourceSnapshotEncryptionKey?: ComputeDiskSpecSourceSnapshotEncryptionKey;

  /**
   * Immutable. URL of the disk type resource describing which disk type to use to
   * create the disk. Provide this when creating the disk.
   *
   * @schema ComputeDiskSpec#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpec(obj: ComputeDiskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'asyncPrimaryDisk': toJson_ComputeDiskSpecAsyncPrimaryDisk(obj.asyncPrimaryDisk),
    'description': obj.description,
    'diskEncryptionKey': toJson_ComputeDiskSpecDiskEncryptionKey(obj.diskEncryptionKey),
    'enableConfidentialCompute': obj.enableConfidentialCompute,
    'guestOsFeatures': obj.guestOsFeatures?.map(y => toJson_ComputeDiskSpecGuestOsFeatures(y)),
    'imageRef': toJson_ComputeDiskSpecImageRef(obj.imageRef),
    'interface': obj.interface,
    'licenses': obj.licenses?.map(y => y),
    'location': obj.location,
    'multiWriter': obj.multiWriter,
    'physicalBlockSizeBytes': obj.physicalBlockSizeBytes,
    'projectRef': toJson_ComputeDiskSpecProjectRef(obj.projectRef),
    'provisionedIops': obj.provisionedIops,
    'provisionedThroughput': obj.provisionedThroughput,
    'replicaZones': obj.replicaZones?.map(y => y),
    'resourceID': obj.resourceId,
    'resourcePolicies': obj.resourcePolicies?.map(y => toJson_ComputeDiskSpecResourcePolicies(y)),
    'size': obj.size,
    'snapshotRef': toJson_ComputeDiskSpecSnapshotRef(obj.snapshotRef),
    'sourceDiskRef': toJson_ComputeDiskSpecSourceDiskRef(obj.sourceDiskRef),
    'sourceImageEncryptionKey': toJson_ComputeDiskSpecSourceImageEncryptionKey(obj.sourceImageEncryptionKey),
    'sourceSnapshotEncryptionKey': toJson_ComputeDiskSpecSourceSnapshotEncryptionKey(obj.sourceSnapshotEncryptionKey),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. A nested object resource.
 *
 * @schema ComputeDiskSpecAsyncPrimaryDisk
 */
export interface ComputeDiskSpecAsyncPrimaryDisk {
  /**
   * Immutable. Primary disk for asynchronous disk replication.
   *
   * @schema ComputeDiskSpecAsyncPrimaryDisk#diskRef
   */
  readonly diskRef: ComputeDiskSpecAsyncPrimaryDiskDiskRef;

}

/**
 * Converts an object of type 'ComputeDiskSpecAsyncPrimaryDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecAsyncPrimaryDisk(obj: ComputeDiskSpecAsyncPrimaryDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskRef': toJson_ComputeDiskSpecAsyncPrimaryDiskDiskRef(obj.diskRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Encrypts the disk using a customer-supplied encryption key.
 *
 * After you encrypt a disk with a customer-supplied key, you must
 * provide the same key if you use the disk later (e.g. to create a disk
 * snapshot or an image, or to attach the disk to a virtual machine).
 *
 * Customer-supplied encryption keys do not protect access to metadata of
 * the disk.
 *
 * If you do not provide an encryption key when creating the disk, then
 * the disk will be encrypted using an automatically generated key and
 * you do not need to provide a key to use the disk later.
 *
 * @schema ComputeDiskSpecDiskEncryptionKey
 */
export interface ComputeDiskSpecDiskEncryptionKey {
  /**
   * The encryption key used to encrypt the disk. Your project's Compute
   * Engine System service account
   * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
   * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
   * feature. See
   * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
   *
   * @schema ComputeDiskSpecDiskEncryptionKey#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeDiskSpecDiskEncryptionKeyKmsKeyRef;

  /**
   * The service account used for the encryption request for the given KMS key.
   * If absent, the Compute Engine Service Agent service account is used.
   *
   * @schema ComputeDiskSpecDiskEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef;

  /**
   * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
   * RFC 4648 base64 to either encrypt or decrypt this resource.
   *
   * @schema ComputeDiskSpecDiskEncryptionKey#rawKey
   */
  readonly rawKey?: ComputeDiskSpecDiskEncryptionKeyRawKey;

  /**
   * Immutable. Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
   * customer-supplied encryption key to either encrypt or decrypt
   * this resource. You can provide either the rawKey or the rsaEncryptedKey.
   *
   * @schema ComputeDiskSpecDiskEncryptionKey#rsaEncryptedKey
   */
  readonly rsaEncryptedKey?: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
   * encryption key that protects this resource.
   *
   * @schema ComputeDiskSpecDiskEncryptionKey#sha256
   */
  readonly sha256?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKey(obj: ComputeDiskSpecDiskEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyRef': toJson_ComputeDiskSpecDiskEncryptionKeyKmsKeyRef(obj.kmsKeyRef),
    'kmsKeyServiceAccountRef': toJson_ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
    'rawKey': toJson_ComputeDiskSpecDiskEncryptionKeyRawKey(obj.rawKey),
    'rsaEncryptedKey': toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey(obj.rsaEncryptedKey),
    'sha256': obj.sha256,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeDiskSpecGuestOsFeatures
 */
export interface ComputeDiskSpecGuestOsFeatures {
  /**
   * Immutable. The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options. Possible values: ["MULTI_IP_SUBNET", "SECURE_BOOT", "SEV_CAPABLE", "UEFI_COMPATIBLE", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "GVNIC", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "SUSPEND_RESUME_COMPATIBLE", "TDX_CAPABLE"].
   *
   * @schema ComputeDiskSpecGuestOsFeatures#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecGuestOsFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecGuestOsFeatures(obj: ComputeDiskSpecGuestOsFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The image from which to initialize this disk.
 *
 * @schema ComputeDiskSpecImageRef
 */
export interface ComputeDiskSpecImageRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeImage` resource.
   *
   * @schema ComputeDiskSpecImageRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecImageRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecImageRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecImageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecImageRef(obj: ComputeDiskSpecImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The project that this resource belongs to.
 *
 * @schema ComputeDiskSpecProjectRef
 */
export interface ComputeDiskSpecProjectRef {
  /**
   * Allowed value: The `name` field of a `Project` resource.
   *
   * @schema ComputeDiskSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecProjectRef(obj: ComputeDiskSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resource policies applied to this disk for automatic snapshot creations.
 *
 * @schema ComputeDiskSpecResourcePolicies
 */
export interface ComputeDiskSpecResourcePolicies {
  /**
   * Allowed value: The `selfLink` field of a `ComputeResourcePolicy` resource.
   *
   * @schema ComputeDiskSpecResourcePolicies#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecResourcePolicies#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecResourcePolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecResourcePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecResourcePolicies(obj: ComputeDiskSpecResourcePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source snapshot used to create this disk.
 *
 * @schema ComputeDiskSpecSnapshotRef
 */
export interface ComputeDiskSpecSnapshotRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSnapshot` resource.
   *
   * @schema ComputeDiskSpecSnapshotRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSnapshotRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSnapshotRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSnapshotRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSnapshotRef(obj: ComputeDiskSpecSnapshotRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source disk used to create this disk.
 *
 * @schema ComputeDiskSpecSourceDiskRef
 */
export interface ComputeDiskSpecSourceDiskRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeDisk` resource.
   *
   * @schema ComputeDiskSpecSourceDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSourceDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSourceDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceDiskRef(obj: ComputeDiskSpecSourceDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The customer-supplied encryption key of the source image. Required if
 * the source image is protected by a customer-supplied encryption key.
 *
 * @schema ComputeDiskSpecSourceImageEncryptionKey
 */
export interface ComputeDiskSpecSourceImageEncryptionKey {
  /**
   * The encryption key used to encrypt the disk. Your project's Compute
   * Engine System service account
   * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
   * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
   * feature. See
   * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKey#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef;

  /**
   * The service account used for the encryption request for the given KMS key.
   * If absent, the Compute Engine Service Agent service account is used.
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef;

  /**
   * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
   * RFC 4648 base64 to either encrypt or decrypt this resource.
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKey#rawKey
   */
  readonly rawKey?: string;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
   * encryption key that protects this resource.
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKey#sha256
   */
  readonly sha256?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceImageEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceImageEncryptionKey(obj: ComputeDiskSpecSourceImageEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyRef': toJson_ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef(obj.kmsKeyRef),
    'kmsKeyServiceAccountRef': toJson_ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
    'rawKey': obj.rawKey,
    'sha256': obj.sha256,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The customer-supplied encryption key of the source snapshot. Required
 * if the source snapshot is protected by a customer-supplied encryption
 * key.
 *
 * @schema ComputeDiskSpecSourceSnapshotEncryptionKey
 */
export interface ComputeDiskSpecSourceSnapshotEncryptionKey {
  /**
   * The encryption key used to encrypt the disk. Your project's Compute
   * Engine System service account
   * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
   * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
   * feature. See
   * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKey#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef;

  /**
   * The service account used for the encryption request for the given KMS key.
   * If absent, the Compute Engine Service Agent service account is used.
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef;

  /**
   * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
   * RFC 4648 base64 to either encrypt or decrypt this resource.
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKey#rawKey
   */
  readonly rawKey?: string;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
   * encryption key that protects this resource.
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKey#sha256
   */
  readonly sha256?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceSnapshotEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceSnapshotEncryptionKey(obj: ComputeDiskSpecSourceSnapshotEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyRef': toJson_ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef(obj.kmsKeyRef),
    'kmsKeyServiceAccountRef': toJson_ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
    'rawKey': obj.rawKey,
    'sha256': obj.sha256,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Primary disk for asynchronous disk replication.
 *
 * @schema ComputeDiskSpecAsyncPrimaryDiskDiskRef
 */
export interface ComputeDiskSpecAsyncPrimaryDiskDiskRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeDisk` resource.
   *
   * @schema ComputeDiskSpecAsyncPrimaryDiskDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecAsyncPrimaryDiskDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecAsyncPrimaryDiskDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecAsyncPrimaryDiskDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecAsyncPrimaryDiskDiskRef(obj: ComputeDiskSpecAsyncPrimaryDiskDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption key used to encrypt the disk. Your project's Compute
 * Engine System service account
 * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
 * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
 * feature. See
 * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyRef
 */
export interface ComputeDiskSpecDiskEncryptionKeyKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyKmsKeyRef(obj: ComputeDiskSpecDiskEncryptionKeyKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account used for the encryption request for the given KMS key.
 * If absent, the Compute Engine Service Agent service account is used.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeDiskSpecDiskEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
 * RFC 4648 base64 to either encrypt or decrypt this resource.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRawKey
 */
export interface ComputeDiskSpecDiskEncryptionKeyRawKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRawKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRawKey#valueFrom
   */
  readonly valueFrom?: ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRawKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRawKey(obj: ComputeDiskSpecDiskEncryptionKeyRawKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
 * customer-supplied encryption key to either encrypt or decrypt
 * this resource. You can provide either the rawKey or the rsaEncryptedKey.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey
 */
export interface ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey#valueFrom
   */
  readonly valueFrom?: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey(obj: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption key used to encrypt the disk. Your project's Compute
 * Engine System service account
 * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
 * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
 * feature. See
 * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
 *
 * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef
 */
export interface ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef(obj: ComputeDiskSpecSourceImageEncryptionKeyKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account used for the encryption request for the given KMS key.
 * If absent, the Compute Engine Service Agent service account is used.
 *
 * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeDiskSpecSourceImageEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption key used to encrypt the disk. Your project's Compute
 * Engine System service account
 * ('service-{{PROJECT_NUMBER}}@compute-system.iam.gserviceaccount.com')
 * must have 'roles/cloudkms.cryptoKeyEncrypterDecrypter' to use this
 * feature. See
 * https://cloud.google.com/compute/docs/disks/customer-managed-encryption#encrypt_a_new_persistent_disk_with_your_own_keys
 *
 * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef
 */
export interface ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef(obj: ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account used for the encryption request for the given KMS key.
 * If absent, the Compute Engine Service Agent service account is used.
 *
 * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeDiskSpecSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom
 */
export interface ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom(obj: ComputeDiskSpecDiskEncryptionKeyRawKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom
 */
export interface ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom(obj: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef
 */
export interface ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef(obj: ComputeDiskSpecDiskEncryptionKeyRawKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef
 */
export interface ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef(obj: ComputeDiskSpecDiskEncryptionKeyRsaEncryptedKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeExternalVPNGateway
 */
export class ComputeExternalVpnGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeExternalVPNGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeExternalVPNGateway',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeExternalVPNGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeExternalVpnGatewayProps = {}): any {
    return {
      ...ComputeExternalVpnGateway.GVK,
      ...toJson_ComputeExternalVpnGatewayProps(props),
    };
  }

  /**
   * Defines a "ComputeExternalVPNGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeExternalVpnGatewayProps = {}) {
    super(scope, id, {
      ...ComputeExternalVpnGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeExternalVpnGateway.GVK,
      ...toJson_ComputeExternalVpnGatewayProps(resolved),
    };
  }
}

/**
 * @schema ComputeExternalVPNGateway
 */
export interface ComputeExternalVpnGatewayProps {
  /**
   * @schema ComputeExternalVPNGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeExternalVPNGateway#spec
   */
  readonly spec?: ComputeExternalVpnGatewaySpec;

}

/**
 * Converts an object of type 'ComputeExternalVpnGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeExternalVpnGatewayProps(obj: ComputeExternalVpnGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeExternalVpnGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeExternalVpnGatewaySpec
 */
export interface ComputeExternalVpnGatewaySpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeExternalVpnGatewaySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. A list of interfaces on this external VPN gateway.
   *
   * @schema ComputeExternalVpnGatewaySpec#interface
   */
  readonly interface?: ComputeExternalVpnGatewaySpecInterface[];

  /**
   * Immutable. Indicates the redundancy type of this external VPN gateway Possible values: ["FOUR_IPS_REDUNDANCY", "SINGLE_IP_INTERNALLY_REDUNDANT", "TWO_IPS_REDUNDANCY"].
   *
   * @schema ComputeExternalVpnGatewaySpec#redundancyType
   */
  readonly redundancyType?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeExternalVpnGatewaySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeExternalVpnGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeExternalVpnGatewaySpec(obj: ComputeExternalVpnGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'interface': obj.interface?.map(y => toJson_ComputeExternalVpnGatewaySpecInterface(y)),
    'redundancyType': obj.redundancyType,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeExternalVpnGatewaySpecInterface
 */
export interface ComputeExternalVpnGatewaySpecInterface {
  /**
   * Immutable. The numeric ID for this interface. Allowed values are based on the redundancy type
   * of this external VPN gateway
   * * '0 - SINGLE_IP_INTERNALLY_REDUNDANT'
   * * '0, 1 - TWO_IPS_REDUNDANCY'
   * * '0, 1, 2, 3 - FOUR_IPS_REDUNDANCY'.
   *
   * @schema ComputeExternalVpnGatewaySpecInterface#id
   */
  readonly id?: number;

  /**
   * Immutable. IP address of the interface in the external VPN gateway.
   * Only IPv4 is supported. This IP address can be either from
   * your on-premise gateway or another Cloud provider's VPN gateway,
   * it cannot be an IP address from Google Compute Engine.
   *
   * @schema ComputeExternalVpnGatewaySpecInterface#ipAddress
   */
  readonly ipAddress?: string;

}

/**
 * Converts an object of type 'ComputeExternalVpnGatewaySpecInterface' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeExternalVpnGatewaySpecInterface(obj: ComputeExternalVpnGatewaySpecInterface | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'ipAddress': obj.ipAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeFirewall
 */
export class ComputeFirewall extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeFirewall"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeFirewall',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeFirewall".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeFirewallProps): any {
    return {
      ...ComputeFirewall.GVK,
      ...toJson_ComputeFirewallProps(props),
    };
  }

  /**
   * Defines a "ComputeFirewall" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeFirewallProps) {
    super(scope, id, {
      ...ComputeFirewall.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeFirewall.GVK,
      ...toJson_ComputeFirewallProps(resolved),
    };
  }
}

/**
 * @schema ComputeFirewall
 */
export interface ComputeFirewallProps {
  /**
   * @schema ComputeFirewall#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeFirewall#spec
   */
  readonly spec: ComputeFirewallSpec;

}

/**
 * Converts an object of type 'ComputeFirewallProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallProps(obj: ComputeFirewallProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeFirewallSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallSpec
 */
export interface ComputeFirewallSpec {
  /**
   * The list of ALLOW rules specified by this firewall. Each rule
   * specifies a protocol and port-range tuple that describes a permitted
   * connection.
   *
   * @schema ComputeFirewallSpec#allow
   */
  readonly allow?: ComputeFirewallSpecAllow[];

  /**
   * The list of DENY rules specified by this firewall. Each rule specifies
   * a protocol and port-range tuple that describes a denied connection.
   *
   * @schema ComputeFirewallSpec#deny
   */
  readonly deny?: ComputeFirewallSpecDeny[];

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeFirewallSpec#description
   */
  readonly description?: string;

  /**
   * If destination ranges are specified, the firewall will apply only to
   * traffic that has destination IP address in these ranges. These ranges
   * must be expressed in CIDR format. IPv4 or IPv6 ranges are supported.
   *
   * @schema ComputeFirewallSpec#destinationRanges
   */
  readonly destinationRanges?: string[];

  /**
   * Immutable. Direction of traffic to which this firewall applies; default is
   * INGRESS. Note: For INGRESS traffic, one of 'source_ranges',
   * 'source_tags' or 'source_service_accounts' is required. Possible values: ["INGRESS", "EGRESS"].
   *
   * @schema ComputeFirewallSpec#direction
   */
  readonly direction?: string;

  /**
   * Denotes whether the firewall rule is disabled, i.e not applied to the
   * network it is associated with. When set to true, the firewall rule is
   * not enforced and the network behaves as if it did not exist. If this
   * is unspecified, the firewall rule will be enabled.
   *
   * @schema ComputeFirewallSpec#disabled
   */
  readonly disabled?: boolean;

  /**
   * DEPRECATED. Deprecated in favor of log_config. This field denotes whether to enable logging for a particular firewall rule. If logging is enabled, logs will be exported to Stackdriver.
   *
   * @schema ComputeFirewallSpec#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * This field denotes the logging options for a particular firewall rule.
   * If defined, logging is enabled, and logs will be exported to Cloud Logging.
   *
   * @schema ComputeFirewallSpec#logConfig
   */
  readonly logConfig?: ComputeFirewallSpecLogConfig;

  /**
   * The network to attach this firewall to.
   *
   * @schema ComputeFirewallSpec#networkRef
   */
  readonly networkRef: ComputeFirewallSpecNetworkRef;

  /**
   * Priority for this rule. This is an integer between 0 and 65535, both
   * inclusive. When not specified, the value assumed is 1000. Relative
   * priorities determine precedence of conflicting rules. Lower value of
   * priority implies higher precedence (eg, a rule with priority 0 has
   * higher precedence than a rule with priority 1). DENY rules take
   * precedence over ALLOW rules having equal priority.
   *
   * @schema ComputeFirewallSpec#priority
   */
  readonly priority?: number;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeFirewallSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * If source ranges are specified, the firewall will apply only to
   * traffic that has source IP address in these ranges. These ranges must
   * be expressed in CIDR format. One or both of sourceRanges and
   * sourceTags may be set. If both properties are set, the firewall will
   * apply to traffic that has source IP address within sourceRanges OR the
   * source IP that belongs to a tag listed in the sourceTags property. The
   * connection does not need to match both properties for the firewall to
   * apply. IPv4 or IPv6 ranges are supported. For INGRESS traffic, one of
   * 'source_ranges', 'source_tags' or 'source_service_accounts' is required.
   *
   * @schema ComputeFirewallSpec#sourceRanges
   */
  readonly sourceRanges?: string[];

  /**
   * @schema ComputeFirewallSpec#sourceServiceAccounts
   */
  readonly sourceServiceAccounts?: ComputeFirewallSpecSourceServiceAccounts[];

  /**
   * If source tags are specified, the firewall will apply only to traffic
   * with source IP that belongs to a tag listed in source tags. Source
   * tags cannot be used to control traffic to an instance's external IP
   * address. Because tags are associated with an instance, not an IP
   * address. One or both of sourceRanges and sourceTags may be set. If
   * both properties are set, the firewall will apply to traffic that has
   * source IP address within sourceRanges OR the source IP that belongs to
   * a tag listed in the sourceTags property. The connection does not need
   * to match both properties for the firewall to apply. For INGRESS traffic,
   * one of 'source_ranges', 'source_tags' or 'source_service_accounts' is required.
   *
   * @schema ComputeFirewallSpec#sourceTags
   */
  readonly sourceTags?: string[];

  /**
   * @schema ComputeFirewallSpec#targetServiceAccounts
   */
  readonly targetServiceAccounts?: ComputeFirewallSpecTargetServiceAccounts[];

  /**
   * A list of instance tags indicating sets of instances located in the
   * network that may make network connections as specified in allowed[].
   * If no targetTags are specified, the firewall rule applies to all
   * instances on the specified network.
   *
   * @schema ComputeFirewallSpec#targetTags
   */
  readonly targetTags?: string[];

}

/**
 * Converts an object of type 'ComputeFirewallSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpec(obj: ComputeFirewallSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => toJson_ComputeFirewallSpecAllow(y)),
    'deny': obj.deny?.map(y => toJson_ComputeFirewallSpecDeny(y)),
    'description': obj.description,
    'destinationRanges': obj.destinationRanges?.map(y => y),
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'logConfig': toJson_ComputeFirewallSpecLogConfig(obj.logConfig),
    'networkRef': toJson_ComputeFirewallSpecNetworkRef(obj.networkRef),
    'priority': obj.priority,
    'resourceID': obj.resourceId,
    'sourceRanges': obj.sourceRanges?.map(y => y),
    'sourceServiceAccounts': obj.sourceServiceAccounts?.map(y => toJson_ComputeFirewallSpecSourceServiceAccounts(y)),
    'sourceTags': obj.sourceTags?.map(y => y),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => toJson_ComputeFirewallSpecTargetServiceAccounts(y)),
    'targetTags': obj.targetTags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallSpecAllow
 */
export interface ComputeFirewallSpecAllow {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   *
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema ComputeFirewallSpecAllow#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema ComputeFirewallSpecAllow#protocol
   */
  readonly protocol: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecAllow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecAllow(obj: ComputeFirewallSpecAllow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallSpecDeny
 */
export interface ComputeFirewallSpecDeny {
  /**
   * An optional list of ports to which this rule applies. This field
   * is only applicable for UDP or TCP protocol. Each entry must be
   * either an integer or a range. If not specified, this rule
   * applies to connections through any port.
   *
   * Example inputs include: ["22"], ["80","443"], and
   * ["12345-12349"].
   *
   * @schema ComputeFirewallSpecDeny#ports
   */
  readonly ports?: string[];

  /**
   * The IP protocol to which this rule applies. The protocol type is
   * required when creating a firewall rule. This value can either be
   * one of the following well known protocol strings (tcp, udp,
   * icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
   *
   * @schema ComputeFirewallSpecDeny#protocol
   */
  readonly protocol: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecDeny(obj: ComputeFirewallSpecDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field denotes the logging options for a particular firewall rule.
 * If defined, logging is enabled, and logs will be exported to Cloud Logging.
 *
 * @schema ComputeFirewallSpecLogConfig
 */
export interface ComputeFirewallSpecLogConfig {
  /**
   * This field denotes whether to include or exclude metadata for firewall logs. Possible values: ["EXCLUDE_ALL_METADATA", "INCLUDE_ALL_METADATA"].
   *
   * @schema ComputeFirewallSpecLogConfig#metadata
   */
  readonly metadata: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecLogConfig(obj: ComputeFirewallSpecLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network to attach this firewall to.
 *
 * @schema ComputeFirewallSpecNetworkRef
 */
export interface ComputeFirewallSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeFirewallSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecNetworkRef(obj: ComputeFirewallSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If source service accounts are specified, the firewall will apply only
 * to traffic originating from an instance with a service account in this
 * list. Source service accounts cannot be used to control traffic to an
 * instance's external IP address because service accounts are associated
 * with an instance, not an IP address. sourceRanges can be set at the
 * same time as sourceServiceAccounts. If both are set, the firewall will
 * apply to traffic that has source IP address within sourceRanges OR the
 * source IP belongs to an instance with service account listed in
 * sourceServiceAccount. The connection does not need to match both
 * properties for the firewall to apply. sourceServiceAccounts cannot be
 * used at the same time as sourceTags or targetTags.
 *
 * @schema ComputeFirewallSpecSourceServiceAccounts
 */
export interface ComputeFirewallSpecSourceServiceAccounts {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeFirewallSpecSourceServiceAccounts#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallSpecSourceServiceAccounts#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallSpecSourceServiceAccounts#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecSourceServiceAccounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecSourceServiceAccounts(obj: ComputeFirewallSpecSourceServiceAccounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of service accounts indicating sets of instances located in the
 * network that may make network connections as specified in allowed[].
 * targetServiceAccounts cannot be used at the same time as targetTags or
 * sourceTags. If neither targetServiceAccounts nor targetTags are
 * specified, the firewall rule applies to all instances on the specified
 * network.
 *
 * @schema ComputeFirewallSpecTargetServiceAccounts
 */
export interface ComputeFirewallSpecTargetServiceAccounts {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeFirewallSpecTargetServiceAccounts#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallSpecTargetServiceAccounts#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallSpecTargetServiceAccounts#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallSpecTargetServiceAccounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallSpecTargetServiceAccounts(obj: ComputeFirewallSpecTargetServiceAccounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeFirewallPolicy
 */
export class ComputeFirewallPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeFirewallPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeFirewallPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeFirewallPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeFirewallPolicyProps): any {
    return {
      ...ComputeFirewallPolicy.GVK,
      ...toJson_ComputeFirewallPolicyProps(props),
    };
  }

  /**
   * Defines a "ComputeFirewallPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeFirewallPolicyProps) {
    super(scope, id, {
      ...ComputeFirewallPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeFirewallPolicy.GVK,
      ...toJson_ComputeFirewallPolicyProps(resolved),
    };
  }
}

/**
 * @schema ComputeFirewallPolicy
 */
export interface ComputeFirewallPolicyProps {
  /**
   * @schema ComputeFirewallPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeFirewallPolicy#spec
   */
  readonly spec: ComputeFirewallPolicySpec;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyProps(obj: ComputeFirewallPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeFirewallPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicySpec
 */
export interface ComputeFirewallPolicySpec {
  /**
   * An optional description of this resource. Provide this property when you create the resource.
   *
   * @schema ComputeFirewallPolicySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The Folder that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.
   *
   * @schema ComputeFirewallPolicySpec#folderRef
   */
  readonly folderRef?: ComputeFirewallPolicySpecFolderRef;

  /**
   * Immutable. The Organization that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.
   *
   * @schema ComputeFirewallPolicySpec#organizationRef
   */
  readonly organizationRef?: ComputeFirewallPolicySpecOrganizationRef;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema ComputeFirewallPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. User-provided name of the Organization firewall policy. The name should be unique in the organization in which the firewall policy is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   *
   * @schema ComputeFirewallPolicySpec#shortName
   */
  readonly shortName: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicySpec(obj: ComputeFirewallPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'folderRef': toJson_ComputeFirewallPolicySpecFolderRef(obj.folderRef),
    'organizationRef': toJson_ComputeFirewallPolicySpecOrganizationRef(obj.organizationRef),
    'resourceID': obj.resourceId,
    'shortName': obj.shortName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Folder that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.
 *
 * @schema ComputeFirewallPolicySpecFolderRef
 */
export interface ComputeFirewallPolicySpecFolderRef {
  /**
   * Allowed value: The Google Cloud resource name of a `Folder` resource (format: `folders/{{name}}`).
   *
   * @schema ComputeFirewallPolicySpecFolderRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicySpecFolderRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicySpecFolderRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicySpecFolderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicySpecFolderRef(obj: ComputeFirewallPolicySpecFolderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Organization that this resource belongs to. Only one of [folderRef, organizationRef] may be specified.
 *
 * @schema ComputeFirewallPolicySpecOrganizationRef
 */
export interface ComputeFirewallPolicySpecOrganizationRef {
  /**
   * Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).
   *
   * @schema ComputeFirewallPolicySpecOrganizationRef#external
   */
  readonly external?: string;

  /**
   * [WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicySpecOrganizationRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicySpecOrganizationRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicySpecOrganizationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicySpecOrganizationRef(obj: ComputeFirewallPolicySpecOrganizationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeFirewallPolicyAssociation
 */
export class ComputeFirewallPolicyAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeFirewallPolicyAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeFirewallPolicyAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeFirewallPolicyAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeFirewallPolicyAssociationProps): any {
    return {
      ...ComputeFirewallPolicyAssociation.GVK,
      ...toJson_ComputeFirewallPolicyAssociationProps(props),
    };
  }

  /**
   * Defines a "ComputeFirewallPolicyAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeFirewallPolicyAssociationProps) {
    super(scope, id, {
      ...ComputeFirewallPolicyAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeFirewallPolicyAssociation.GVK,
      ...toJson_ComputeFirewallPolicyAssociationProps(resolved),
    };
  }
}

/**
 * @schema ComputeFirewallPolicyAssociation
 */
export interface ComputeFirewallPolicyAssociationProps {
  /**
   * @schema ComputeFirewallPolicyAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeFirewallPolicyAssociation#spec
   */
  readonly spec: ComputeFirewallPolicyAssociationSpec;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyAssociationProps(obj: ComputeFirewallPolicyAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeFirewallPolicyAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicyAssociationSpec
 */
export interface ComputeFirewallPolicyAssociationSpec {
  /**
   * Immutable.
   *
   * @schema ComputeFirewallPolicyAssociationSpec#attachmentTargetRef
   */
  readonly attachmentTargetRef: ComputeFirewallPolicyAssociationSpecAttachmentTargetRef;

  /**
   * Immutable.
   *
   * @schema ComputeFirewallPolicyAssociationSpec#firewallPolicyRef
   */
  readonly firewallPolicyRef: ComputeFirewallPolicyAssociationSpecFirewallPolicyRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeFirewallPolicyAssociationSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyAssociationSpec(obj: ComputeFirewallPolicyAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachmentTargetRef': toJson_ComputeFirewallPolicyAssociationSpecAttachmentTargetRef(obj.attachmentTargetRef),
    'firewallPolicyRef': toJson_ComputeFirewallPolicyAssociationSpecFirewallPolicyRef(obj.firewallPolicyRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputeFirewallPolicyAssociationSpecAttachmentTargetRef
 */
export interface ComputeFirewallPolicyAssociationSpecAttachmentTargetRef {
  /**
   * The target that the firewall policy is attached to.
   *
   * Allowed values:
   * * The Google Cloud resource name of a `Folder` resource (format: `folders/{{name}}`).
   * * The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).
   *
   * @schema ComputeFirewallPolicyAssociationSpecAttachmentTargetRef#external
   */
  readonly external?: string;

  /**
   * Kind of the referent. Allowed values: Folder
   *
   * @schema ComputeFirewallPolicyAssociationSpecAttachmentTargetRef#kind
   */
  readonly kind?: string;

  /**
   * [WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicyAssociationSpecAttachmentTargetRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicyAssociationSpecAttachmentTargetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyAssociationSpecAttachmentTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyAssociationSpecAttachmentTargetRef(obj: ComputeFirewallPolicyAssociationSpecAttachmentTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputeFirewallPolicyAssociationSpecFirewallPolicyRef
 */
export interface ComputeFirewallPolicyAssociationSpecFirewallPolicyRef {
  /**
   * The firewall policy ID of the association.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeFirewallPolicy` resource (format: `locations/global/firewallPolicies/{{name}}`).
   *
   * @schema ComputeFirewallPolicyAssociationSpecFirewallPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicyAssociationSpecFirewallPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicyAssociationSpecFirewallPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyAssociationSpecFirewallPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyAssociationSpecFirewallPolicyRef(obj: ComputeFirewallPolicyAssociationSpecFirewallPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeFirewallPolicyRule
 */
export class ComputeFirewallPolicyRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeFirewallPolicyRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeFirewallPolicyRule',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeFirewallPolicyRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeFirewallPolicyRuleProps): any {
    return {
      ...ComputeFirewallPolicyRule.GVK,
      ...toJson_ComputeFirewallPolicyRuleProps(props),
    };
  }

  /**
   * Defines a "ComputeFirewallPolicyRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeFirewallPolicyRuleProps) {
    super(scope, id, {
      ...ComputeFirewallPolicyRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeFirewallPolicyRule.GVK,
      ...toJson_ComputeFirewallPolicyRuleProps(resolved),
    };
  }
}

/**
 * @schema ComputeFirewallPolicyRule
 */
export interface ComputeFirewallPolicyRuleProps {
  /**
   * @schema ComputeFirewallPolicyRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeFirewallPolicyRule#spec
   */
  readonly spec: ComputeFirewallPolicyRuleSpec;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleProps(obj: ComputeFirewallPolicyRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeFirewallPolicyRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicyRuleSpec
 */
export interface ComputeFirewallPolicyRuleSpec {
  /**
   * The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny" and "goto_next".
   *
   * @schema ComputeFirewallPolicyRuleSpec#action
   */
  readonly action: string;

  /**
   * An optional description for this resource.
   *
   * @schema ComputeFirewallPolicyRuleSpec#description
   */
  readonly description?: string;

  /**
   * The direction in which this rule applies. Possible values: INGRESS, EGRESS
   *
   * @schema ComputeFirewallPolicyRuleSpec#direction
   */
  readonly direction: string;

  /**
   * Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
   *
   * @schema ComputeFirewallPolicyRuleSpec#disabled
   */
  readonly disabled?: boolean;

  /**
   * Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on "goto_next" rules.
   *
   * @schema ComputeFirewallPolicyRuleSpec#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * Immutable.
   *
   * @schema ComputeFirewallPolicyRuleSpec#firewallPolicyRef
   */
  readonly firewallPolicyRef: ComputeFirewallPolicyRuleSpecFirewallPolicyRef;

  /**
   * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
   *
   * @schema ComputeFirewallPolicyRuleSpec#match
   */
  readonly match: ComputeFirewallPolicyRuleSpecMatch;

  /**
   * Immutable. An integer indicating the priority of a rule in the list. The priority must be a positive value between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
   *
   * @schema ComputeFirewallPolicyRuleSpec#priority
   */
  readonly priority: number;

  /**
   * @schema ComputeFirewallPolicyRuleSpec#targetResources
   */
  readonly targetResources?: ComputeFirewallPolicyRuleSpecTargetResources[];

  /**
   * @schema ComputeFirewallPolicyRuleSpec#targetServiceAccounts
   */
  readonly targetServiceAccounts?: ComputeFirewallPolicyRuleSpecTargetServiceAccounts[];

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpec(obj: ComputeFirewallPolicyRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'direction': obj.direction,
    'disabled': obj.disabled,
    'enableLogging': obj.enableLogging,
    'firewallPolicyRef': toJson_ComputeFirewallPolicyRuleSpecFirewallPolicyRef(obj.firewallPolicyRef),
    'match': toJson_ComputeFirewallPolicyRuleSpecMatch(obj.match),
    'priority': obj.priority,
    'targetResources': obj.targetResources?.map(y => toJson_ComputeFirewallPolicyRuleSpecTargetResources(y)),
    'targetServiceAccounts': obj.targetServiceAccounts?.map(y => toJson_ComputeFirewallPolicyRuleSpecTargetServiceAccounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputeFirewallPolicyRuleSpecFirewallPolicyRef
 */
export interface ComputeFirewallPolicyRuleSpecFirewallPolicyRef {
  /**
   * The firewall policy of the resource.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeFirewallPolicy` resource (format: `locations/global/firewallPolicies/{{name}}`).
   *
   * @schema ComputeFirewallPolicyRuleSpecFirewallPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicyRuleSpecFirewallPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicyRuleSpecFirewallPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpecFirewallPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpecFirewallPolicyRef(obj: ComputeFirewallPolicyRuleSpecFirewallPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
 *
 * @schema ComputeFirewallPolicyRuleSpecMatch
 */
export interface ComputeFirewallPolicyRuleSpecMatch {
  /**
   * Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10. Destination address groups is only supported in Egress rules.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#destAddressGroups
   */
  readonly destAddressGroups?: string[];

  /**
   * Domain names that will be used to match against the resolved domain name of destination of traffic. Can only be specified if DIRECTION is egress.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#destFqdns
   */
  readonly destFqdns?: string[];

  /**
   * CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 256.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#destIPRanges
   */
  readonly destIpRanges?: string[];

  /**
   * The Unicode country codes whose IP addresses will be used to match against the source of traffic. Can only be specified if DIRECTION is egress.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#destRegionCodes
   */
  readonly destRegionCodes?: string[];

  /**
   * Name of the Google Cloud Threat Intelligence list.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#destThreatIntelligences
   */
  readonly destThreatIntelligences?: string[];

  /**
   * Pairs of IP protocols and ports that the rule should match.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#layer4Configs
   */
  readonly layer4Configs: ComputeFirewallPolicyRuleSpecMatchLayer4Configs[];

  /**
   * Address groups which should be matched against the traffic source. Maximum number of source address groups is 10. Source address groups is only supported in Ingress rules.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#srcAddressGroups
   */
  readonly srcAddressGroups?: string[];

  /**
   * Domain names that will be used to match against the resolved domain name of source of traffic. Can only be specified if DIRECTION is ingress.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#srcFqdns
   */
  readonly srcFqdns?: string[];

  /**
   * CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 256.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#srcIPRanges
   */
  readonly srcIpRanges?: string[];

  /**
   * The Unicode country codes whose IP addresses will be used to match against the source of traffic. Can only be specified if DIRECTION is ingress.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#srcRegionCodes
   */
  readonly srcRegionCodes?: string[];

  /**
   * Name of the Google Cloud Threat Intelligence list.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatch#srcThreatIntelligences
   */
  readonly srcThreatIntelligences?: string[];

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpecMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpecMatch(obj: ComputeFirewallPolicyRuleSpecMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destAddressGroups': obj.destAddressGroups?.map(y => y),
    'destFqdns': obj.destFqdns?.map(y => y),
    'destIPRanges': obj.destIpRanges?.map(y => y),
    'destRegionCodes': obj.destRegionCodes?.map(y => y),
    'destThreatIntelligences': obj.destThreatIntelligences?.map(y => y),
    'layer4Configs': obj.layer4Configs?.map(y => toJson_ComputeFirewallPolicyRuleSpecMatchLayer4Configs(y)),
    'srcAddressGroups': obj.srcAddressGroups?.map(y => y),
    'srcFqdns': obj.srcFqdns?.map(y => y),
    'srcIPRanges': obj.srcIpRanges?.map(y => y),
    'srcRegionCodes': obj.srcRegionCodes?.map(y => y),
    'srcThreatIntelligences': obj.srcThreatIntelligences?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicyRuleSpecTargetResources
 */
export interface ComputeFirewallPolicyRuleSpecTargetResources {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetResources#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetResources#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetResources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpecTargetResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpecTargetResources(obj: ComputeFirewallPolicyRuleSpecTargetResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicyRuleSpecTargetServiceAccounts
 */
export interface ComputeFirewallPolicyRuleSpecTargetServiceAccounts {
  /**
   * Allowed value: The Google Cloud resource name of an `IAMServiceAccount` resource (format: `projects/{{project}}/serviceAccounts/{{name}}@{{project}}.iam.gserviceaccount.com`).
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetServiceAccounts#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetServiceAccounts#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeFirewallPolicyRuleSpecTargetServiceAccounts#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpecTargetServiceAccounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpecTargetServiceAccounts(obj: ComputeFirewallPolicyRuleSpecTargetServiceAccounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeFirewallPolicyRuleSpecMatchLayer4Configs
 */
export interface ComputeFirewallPolicyRuleSpecMatchLayer4Configs {
  /**
   * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (`tcp`, `udp`, `icmp`, `esp`, `ah`, `ipip`, `sctp`), or the IP protocol number.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatchLayer4Configs#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ``.
   *
   * @schema ComputeFirewallPolicyRuleSpecMatchLayer4Configs#ports
   */
  readonly ports?: string[];

}

/**
 * Converts an object of type 'ComputeFirewallPolicyRuleSpecMatchLayer4Configs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeFirewallPolicyRuleSpecMatchLayer4Configs(obj: ComputeFirewallPolicyRuleSpecMatchLayer4Configs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipProtocol': obj.ipProtocol,
    'ports': obj.ports?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeForwardingRule
 */
export class ComputeForwardingRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeForwardingRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeForwardingRule',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeForwardingRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeForwardingRuleProps): any {
    return {
      ...ComputeForwardingRule.GVK,
      ...toJson_ComputeForwardingRuleProps(props),
    };
  }

  /**
   * Defines a "ComputeForwardingRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeForwardingRuleProps) {
    super(scope, id, {
      ...ComputeForwardingRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeForwardingRule.GVK,
      ...toJson_ComputeForwardingRuleProps(resolved),
    };
  }
}

/**
 * @schema ComputeForwardingRule
 */
export interface ComputeForwardingRuleProps {
  /**
   * @schema ComputeForwardingRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeForwardingRule#spec
   */
  readonly spec: ComputeForwardingRuleSpec;

}

/**
 * Converts an object of type 'ComputeForwardingRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleProps(obj: ComputeForwardingRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeForwardingRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpec
 */
export interface ComputeForwardingRuleSpec {
  /**
   * Immutable. This field can only be used:
   * * If 'IPProtocol' is one of TCP, UDP, or SCTP.
   * * By internal TCP/UDP load balancers, backend service-based network load
   * balancers, and internal and external protocol forwarding.
   *
   *
   * Set this field to true to allow packets addressed to any port or packets
   * lacking destination port information (for example, UDP fragments after the
   * first fragment) to be forwarded to the backends configured with this
   * forwarding rule.
   *
   * The 'ports', 'port_range', and
   * 'allPorts' fields are mutually exclusive.
   *
   * @schema ComputeForwardingRuleSpec#allPorts
   */
  readonly allPorts?: boolean;

  /**
   * This field is used along with the 'backend_service' field for
   * internal load balancing or with the 'target' field for internal
   * TargetInstance.
   *
   * If the field is set to 'TRUE', clients can access ILB from all
   * regions.
   *
   * Otherwise only allows access from clients in the same region as the
   * internal load balancer.
   *
   * @schema ComputeForwardingRuleSpec#allowGlobalAccess
   */
  readonly allowGlobalAccess?: boolean;

  /**
   * Immutable. This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
   *
   * @schema ComputeForwardingRuleSpec#allowPscGlobalAccess
   */
  readonly allowPscGlobalAccess?: boolean;

  /**
   * A ComputeBackendService to receive the matched traffic. This is
   * used only for internal load balancing.
   *
   * @schema ComputeForwardingRuleSpec#backendServiceRef
   */
  readonly backendServiceRef?: ComputeForwardingRuleSpecBackendServiceRef;

  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeForwardingRuleSpec#description
   */
  readonly description?: string;

  /**
   * The IP address that this forwarding rule is serving on behalf of.
   *
   * Addresses are restricted based on the forwarding rule's load
   * balancing scheme (EXTERNAL or INTERNAL) and scope (global or
   * regional).
   *
   * When the load balancing scheme is EXTERNAL, for global forwarding
   * rules, the address must be a global IP, and for regional forwarding
   * rules, the address must live in the same region as the forwarding
   * rule. If this field is empty, an ephemeral IPv4 address from the
   * same scope (global or regional) will be assigned. A regional
   * forwarding rule supports IPv4 only. A global forwarding rule
   * supports either IPv4 or IPv6.
   *
   * When the load balancing scheme is INTERNAL, this can only be an RFC
   * 1918 IP address belonging to the network/subnet configured for the
   * forwarding rule. By default, if this field is empty, an ephemeral
   * internal IP address will be automatically allocated from the IP
   * range of the subnet or network configured for this forwarding rule.
   *
   * @schema ComputeForwardingRuleSpec#ipAddress
   */
  readonly ipAddress?: ComputeForwardingRuleSpecIpAddress;

  /**
   * Immutable. The IP protocol to which this rule applies.
   *
   * For protocol forwarding, valid
   * options are 'TCP', 'UDP', 'ESP',
   * 'AH', 'SCTP', 'ICMP' and
   * 'L3_DEFAULT'.
   *
   * The valid IP protocols are different for different load balancing products
   * as described in [Load balancing
   * features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends). Possible values: ["TCP", "UDP", "ESP", "AH", "SCTP", "ICMP", "L3_DEFAULT"].
   *
   * @schema ComputeForwardingRuleSpec#ipProtocol
   */
  readonly ipProtocol?: string;

  /**
   * Immutable. The IP Version that will be used by this global forwarding rule. Possible values: ["IPV4", "IPV6"].
   *
   * @schema ComputeForwardingRuleSpec#ipVersion
   */
  readonly ipVersion?: string;

  /**
   * Immutable. Indicates whether or not this load balancer can be used as a collector for
   * packet mirroring. To prevent mirroring loops, instances behind this
   * load balancer will not have their traffic mirrored even if a
   * 'PacketMirroring' rule applies to them.
   *
   * This can only be set to true for load balancers that have their
   * 'loadBalancingScheme' set to 'INTERNAL'.
   *
   * @schema ComputeForwardingRuleSpec#isMirroringCollector
   */
  readonly isMirroringCollector?: boolean;

  /**
   * Immutable. Specifies the forwarding rule type.
   *
   * For more information about forwarding rules, refer to
   * [Forwarding rule concepts](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts). Default value: "EXTERNAL" Possible values: ["EXTERNAL", "EXTERNAL_MANAGED", "INTERNAL", "INTERNAL_MANAGED"].
   *
   * @schema ComputeForwardingRuleSpec#loadBalancingScheme
   */
  readonly loadBalancingScheme?: string;

  /**
   * Location represents the geographical location of the ComputeForwardingRule. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeForwardingRuleSpec#location
   */
  readonly location: string;

  /**
   * Immutable. Opaque filter criteria used by Loadbalancer to restrict routing
   * configuration to a limited set xDS compliant clients. In their xDS
   * requests to Loadbalancer, xDS clients present node metadata. If a
   * match takes place, the relevant routing configuration is made available
   * to those proxies.
   *
   * For each metadataFilter in this list, if its filterMatchCriteria is set
   * to MATCH_ANY, at least one of the filterLabels must match the
   * corresponding label provided in the metadata. If its filterMatchCriteria
   * is set to MATCH_ALL, then all of its filterLabels must match with
   * corresponding labels in the provided metadata.
   *
   * metadataFilters specified here can be overridden by those specified in
   * the UrlMap that this ForwardingRule references.
   *
   * metadataFilters only applies to Loadbalancers that have their
   * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeForwardingRuleSpec#metadataFilters
   */
  readonly metadataFilters?: ComputeForwardingRuleSpecMetadataFilters[];

  /**
   * This field is not used for external load balancing. For internal
   * load balancing, this field identifies the network that the load
   * balanced IP should belong to for this forwarding rule. If this
   * field is not specified, the default network will be used.
   *
   * @schema ComputeForwardingRuleSpec#networkRef
   */
  readonly networkRef?: ComputeForwardingRuleSpecNetworkRef;

  /**
   * Immutable. This signifies the networking tier used for configuring
   * this load balancer and can only take the following values:
   * 'PREMIUM', 'STANDARD'.
   *
   * For regional ForwardingRule, the valid values are 'PREMIUM' and
   * 'STANDARD'. For GlobalForwardingRule, the valid value is
   * 'PREMIUM'.
   *
   * If this field is not specified, it is assumed to be 'PREMIUM'.
   * If 'IPAddress' is specified, this value must be equal to the
   * networkTier of the Address. Possible values: ["PREMIUM", "STANDARD"].
   *
   * @schema ComputeForwardingRuleSpec#networkTier
   */
  readonly networkTier?: string;

  /**
   * Immutable. This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field.
   *
   * @schema ComputeForwardingRuleSpec#noAutomateDnsZone
   */
  readonly noAutomateDnsZone?: boolean;

  /**
   * Immutable. This field can only be used:
   *
   * * If 'IPProtocol' is one of TCP, UDP, or SCTP.
   * * By backend service-based network load balancers, target pool-based
   * network load balancers, internal proxy load balancers, external proxy load
   * balancers, Traffic Director, external protocol forwarding, and Classic VPN.
   * Some products have restrictions on what ports can be used. See
   * [port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#port_specifications)
   * for details.
   *
   *
   * Only packets addressed to ports in the specified range will be forwarded to
   * the backends configured with this forwarding rule.
   *
   * The 'ports' and 'port_range' fields are mutually exclusive.
   *
   * For external forwarding rules, two or more forwarding rules cannot use the
   * same '[IPAddress, IPProtocol]' pair, and cannot have
   * overlapping 'portRange's.
   *
   * For internal forwarding rules within the same VPC network, two or more
   * forwarding rules cannot use the same '[IPAddress, IPProtocol]'
   * pair, and cannot have overlapping 'portRange's.
   *
   * @schema ComputeForwardingRuleSpec#portRange
   */
  readonly portRange?: string;

  /**
   * Immutable. This field can only be used:
   *
   * * If 'IPProtocol' is one of TCP, UDP, or SCTP.
   * * By internal TCP/UDP load balancers, backend service-based network load
   * balancers, and internal protocol forwarding.
   *
   *
   * You can specify a list of up to five ports by number, separated by commas.
   * The ports can be contiguous or discontiguous. Only packets addressed to
   * these ports will be forwarded to the backends configured with this
   * forwarding rule.
   *
   * For external forwarding rules, two or more forwarding rules cannot use the
   * same '[IPAddress, IPProtocol]' pair, and cannot share any values
   * defined in 'ports'.
   *
   * For internal forwarding rules within the same VPC network, two or more
   * forwarding rules cannot use the same '[IPAddress, IPProtocol]'
   * pair, and cannot share any values defined in 'ports'.
   *
   * The 'ports' and 'port_range' fields are mutually exclusive.
   *
   * @schema ComputeForwardingRuleSpec#ports
   */
  readonly ports?: string[];

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeForwardingRuleSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Service Directory resources to register this forwarding rule with.
   *
   * Currently, only supports a single Service Directory resource.
   *
   * @schema ComputeForwardingRuleSpec#serviceDirectoryRegistrations
   */
  readonly serviceDirectoryRegistrations?: ComputeForwardingRuleSpecServiceDirectoryRegistrations[];

  /**
   * Immutable. An optional prefix to the service name for this Forwarding Rule.
   * If specified, will be the first label of the fully qualified service
   * name.
   *
   * The label must be 1-63 characters long, and comply with RFC1035.
   * Specifically, the label must be 1-63 characters long and match the
   * regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the first
   * character must be a lowercase letter, and all following characters
   * must be a dash, lowercase letter, or digit, except the last
   * character, which cannot be a dash.
   *
   * This field is only used for INTERNAL load balancing.
   *
   * @schema ComputeForwardingRuleSpec#serviceLabel
   */
  readonly serviceLabel?: string;

  /**
   * Immutable. If not empty, this Forwarding Rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a Forwarding Rule can only have up to 64 source IP ranges, and this field can only be used with a regional Forwarding Rule whose scheme is EXTERNAL. Each sourceIpRange entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
   *
   * @schema ComputeForwardingRuleSpec#sourceIpRanges
   */
  readonly sourceIpRanges?: string[];

  /**
   * The subnetwork that the load balanced IP should belong to for this
   * forwarding rule. This field is only used for internal load
   * balancing.
   *
   * If the network specified is in auto subnet mode, this field is
   * optional. However, if the network is in custom subnet mode, a
   * subnetwork must be specified.
   *
   * @schema ComputeForwardingRuleSpec#subnetworkRef
   */
  readonly subnetworkRef?: ComputeForwardingRuleSpecSubnetworkRef;

  /**
   * The target resource to receive the matched traffic. The forwarded
   * traffic must be of a type appropriate to the target object. For
   * INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
   * are valid.
   *
   * @schema ComputeForwardingRuleSpec#target
   */
  readonly target?: ComputeForwardingRuleSpecTarget;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpec(obj: ComputeForwardingRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allPorts': obj.allPorts,
    'allowGlobalAccess': obj.allowGlobalAccess,
    'allowPscGlobalAccess': obj.allowPscGlobalAccess,
    'backendServiceRef': toJson_ComputeForwardingRuleSpecBackendServiceRef(obj.backendServiceRef),
    'description': obj.description,
    'ipAddress': toJson_ComputeForwardingRuleSpecIpAddress(obj.ipAddress),
    'ipProtocol': obj.ipProtocol,
    'ipVersion': obj.ipVersion,
    'isMirroringCollector': obj.isMirroringCollector,
    'loadBalancingScheme': obj.loadBalancingScheme,
    'location': obj.location,
    'metadataFilters': obj.metadataFilters?.map(y => toJson_ComputeForwardingRuleSpecMetadataFilters(y)),
    'networkRef': toJson_ComputeForwardingRuleSpecNetworkRef(obj.networkRef),
    'networkTier': obj.networkTier,
    'noAutomateDnsZone': obj.noAutomateDnsZone,
    'portRange': obj.portRange,
    'ports': obj.ports?.map(y => y),
    'resourceID': obj.resourceId,
    'serviceDirectoryRegistrations': obj.serviceDirectoryRegistrations?.map(y => toJson_ComputeForwardingRuleSpecServiceDirectoryRegistrations(y)),
    'serviceLabel': obj.serviceLabel,
    'sourceIpRanges': obj.sourceIpRanges?.map(y => y),
    'subnetworkRef': toJson_ComputeForwardingRuleSpecSubnetworkRef(obj.subnetworkRef),
    'target': toJson_ComputeForwardingRuleSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ComputeBackendService to receive the matched traffic. This is
 * used only for internal load balancing.
 *
 * @schema ComputeForwardingRuleSpecBackendServiceRef
 */
export interface ComputeForwardingRuleSpecBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeForwardingRuleSpecBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecBackendServiceRef(obj: ComputeForwardingRuleSpecBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The IP address that this forwarding rule is serving on behalf of.
 *
 * Addresses are restricted based on the forwarding rule's load
 * balancing scheme (EXTERNAL or INTERNAL) and scope (global or
 * regional).
 *
 * When the load balancing scheme is EXTERNAL, for global forwarding
 * rules, the address must be a global IP, and for regional forwarding
 * rules, the address must live in the same region as the forwarding
 * rule. If this field is empty, an ephemeral IPv4 address from the
 * same scope (global or regional) will be assigned. A regional
 * forwarding rule supports IPv4 only. A global forwarding rule
 * supports either IPv4 or IPv6.
 *
 * When the load balancing scheme is INTERNAL, this can only be an RFC
 * 1918 IP address belonging to the network/subnet configured for the
 * forwarding rule. By default, if this field is empty, an ephemeral
 * internal IP address will be automatically allocated from the IP
 * range of the subnet or network configured for this forwarding rule.
 *
 * @schema ComputeForwardingRuleSpecIpAddress
 */
export interface ComputeForwardingRuleSpecIpAddress {
  /**
   * @schema ComputeForwardingRuleSpecIpAddress#addressRef
   */
  readonly addressRef?: ComputeForwardingRuleSpecIpAddressAddressRef;

  /**
   * @schema ComputeForwardingRuleSpecIpAddress#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecIpAddress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecIpAddress(obj: ComputeForwardingRuleSpecIpAddress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressRef': toJson_ComputeForwardingRuleSpecIpAddressAddressRef(obj.addressRef),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecMetadataFilters
 */
export interface ComputeForwardingRuleSpecMetadataFilters {
  /**
   * Immutable. The list of label value pairs that must match labels in the
   * provided metadata based on filterMatchCriteria
   *
   * This list must not be empty and can have at the most 64 entries.
   *
   * @schema ComputeForwardingRuleSpecMetadataFilters#filterLabels
   */
  readonly filterLabels: ComputeForwardingRuleSpecMetadataFiltersFilterLabels[];

  /**
   * Immutable. Specifies how individual filterLabel matches within the list of
   * filterLabels contribute towards the overall metadataFilter match.
   *
   * MATCH_ANY - At least one of the filterLabels must have a matching
   * label in the provided metadata.
   * MATCH_ALL - All filterLabels must have matching labels in the
   * provided metadata. Possible values: ["MATCH_ANY", "MATCH_ALL"].
   *
   * @schema ComputeForwardingRuleSpecMetadataFilters#filterMatchCriteria
   */
  readonly filterMatchCriteria: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecMetadataFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecMetadataFilters(obj: ComputeForwardingRuleSpecMetadataFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterLabels': obj.filterLabels?.map(y => toJson_ComputeForwardingRuleSpecMetadataFiltersFilterLabels(y)),
    'filterMatchCriteria': obj.filterMatchCriteria,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field is not used for external load balancing. For internal
 * load balancing, this field identifies the network that the load
 * balanced IP should belong to for this forwarding rule. If this
 * field is not specified, the default network will be used.
 *
 * @schema ComputeForwardingRuleSpecNetworkRef
 */
export interface ComputeForwardingRuleSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeForwardingRuleSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecNetworkRef(obj: ComputeForwardingRuleSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecServiceDirectoryRegistrations
 */
export interface ComputeForwardingRuleSpecServiceDirectoryRegistrations {
  /**
   * Immutable. Service Directory namespace to register the forwarding rule under.
   *
   * @schema ComputeForwardingRuleSpecServiceDirectoryRegistrations#namespace
   */
  readonly namespace?: string;

  /**
   * Immutable. Service Directory service to register the forwarding rule under.
   *
   * @schema ComputeForwardingRuleSpecServiceDirectoryRegistrations#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecServiceDirectoryRegistrations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecServiceDirectoryRegistrations(obj: ComputeForwardingRuleSpecServiceDirectoryRegistrations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The subnetwork that the load balanced IP should belong to for this
 * forwarding rule. This field is only used for internal load
 * balancing.
 *
 * If the network specified is in auto subnet mode, this field is
 * optional. However, if the network is in custom subnet mode, a
 * subnetwork must be specified.
 *
 * @schema ComputeForwardingRuleSpecSubnetworkRef
 */
export interface ComputeForwardingRuleSpecSubnetworkRef {
  /**
   * Allowed value: The `name` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeForwardingRuleSpecSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecSubnetworkRef(obj: ComputeForwardingRuleSpecSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The target resource to receive the matched traffic. The forwarded
 * traffic must be of a type appropriate to the target object. For
 * INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
 * are valid.
 *
 * @schema ComputeForwardingRuleSpecTarget
 */
export interface ComputeForwardingRuleSpecTarget {
  /**
   * @schema ComputeForwardingRuleSpecTarget#targetGRPCProxyRef
   */
  readonly targetGrpcProxyRef?: ComputeForwardingRuleSpecTargetTargetGrpcProxyRef;

  /**
   * @schema ComputeForwardingRuleSpecTarget#targetHTTPProxyRef
   */
  readonly targetHttpProxyRef?: ComputeForwardingRuleSpecTargetTargetHttpProxyRef;

  /**
   * @schema ComputeForwardingRuleSpecTarget#targetHTTPSProxyRef
   */
  readonly targetHttpsProxyRef?: ComputeForwardingRuleSpecTargetTargetHttpsProxyRef;

  /**
   * @schema ComputeForwardingRuleSpecTarget#targetSSLProxyRef
   */
  readonly targetSslProxyRef?: ComputeForwardingRuleSpecTargetTargetSslProxyRef;

  /**
   * @schema ComputeForwardingRuleSpecTarget#targetTCPProxyRef
   */
  readonly targetTcpProxyRef?: ComputeForwardingRuleSpecTargetTargetTcpProxyRef;

  /**
   * @schema ComputeForwardingRuleSpecTarget#targetVPNGatewayRef
   */
  readonly targetVpnGatewayRef?: ComputeForwardingRuleSpecTargetTargetVpnGatewayRef;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTarget(obj: ComputeForwardingRuleSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetGRPCProxyRef': toJson_ComputeForwardingRuleSpecTargetTargetGrpcProxyRef(obj.targetGrpcProxyRef),
    'targetHTTPProxyRef': toJson_ComputeForwardingRuleSpecTargetTargetHttpProxyRef(obj.targetHttpProxyRef),
    'targetHTTPSProxyRef': toJson_ComputeForwardingRuleSpecTargetTargetHttpsProxyRef(obj.targetHttpsProxyRef),
    'targetSSLProxyRef': toJson_ComputeForwardingRuleSpecTargetTargetSslProxyRef(obj.targetSslProxyRef),
    'targetTCPProxyRef': toJson_ComputeForwardingRuleSpecTargetTargetTcpProxyRef(obj.targetTcpProxyRef),
    'targetVPNGatewayRef': toJson_ComputeForwardingRuleSpecTargetTargetVpnGatewayRef(obj.targetVpnGatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecIpAddressAddressRef
 */
export interface ComputeForwardingRuleSpecIpAddressAddressRef {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema ComputeForwardingRuleSpecIpAddressAddressRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecIpAddressAddressRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecIpAddressAddressRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecIpAddressAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecIpAddressAddressRef(obj: ComputeForwardingRuleSpecIpAddressAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecMetadataFiltersFilterLabels
 */
export interface ComputeForwardingRuleSpecMetadataFiltersFilterLabels {
  /**
   * Immutable. Name of the metadata label. The length must be between
   * 1 and 1024 characters, inclusive.
   *
   * @schema ComputeForwardingRuleSpecMetadataFiltersFilterLabels#name
   */
  readonly name: string;

  /**
   * Immutable. The value that the label must match. The value has a maximum
   * length of 1024 characters.
   *
   * @schema ComputeForwardingRuleSpecMetadataFiltersFilterLabels#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecMetadataFiltersFilterLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecMetadataFiltersFilterLabels(obj: ComputeForwardingRuleSpecMetadataFiltersFilterLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetGrpcProxyRef
 */
export interface ComputeForwardingRuleSpecTargetTargetGrpcProxyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetGRPCProxy` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetGrpcProxyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetGrpcProxyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetGrpcProxyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetGrpcProxyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetGrpcProxyRef(obj: ComputeForwardingRuleSpecTargetTargetGrpcProxyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetHttpProxyRef
 */
export interface ComputeForwardingRuleSpecTargetTargetHttpProxyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetHTTPProxy` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpProxyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpProxyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpProxyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetHttpProxyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetHttpProxyRef(obj: ComputeForwardingRuleSpecTargetTargetHttpProxyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetHttpsProxyRef
 */
export interface ComputeForwardingRuleSpecTargetTargetHttpsProxyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetHTTPSProxy` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpsProxyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpsProxyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetHttpsProxyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetHttpsProxyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetHttpsProxyRef(obj: ComputeForwardingRuleSpecTargetTargetHttpsProxyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetSslProxyRef
 */
export interface ComputeForwardingRuleSpecTargetTargetSslProxyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetSSLProxy` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetSslProxyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetSslProxyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetSslProxyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetSslProxyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetSslProxyRef(obj: ComputeForwardingRuleSpecTargetTargetSslProxyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetTcpProxyRef
 */
export interface ComputeForwardingRuleSpecTargetTargetTcpProxyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetTCPProxy` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetTcpProxyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetTcpProxyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetTcpProxyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetTcpProxyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetTcpProxyRef(obj: ComputeForwardingRuleSpecTargetTargetTcpProxyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeForwardingRuleSpecTargetTargetVpnGatewayRef
 */
export interface ComputeForwardingRuleSpecTargetTargetVpnGatewayRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetVPNGateway` resource.
   *
   * @schema ComputeForwardingRuleSpecTargetTargetVpnGatewayRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeForwardingRuleSpecTargetTargetVpnGatewayRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeForwardingRuleSpecTargetTargetVpnGatewayRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeForwardingRuleSpecTargetTargetVpnGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeForwardingRuleSpecTargetTargetVpnGatewayRef(obj: ComputeForwardingRuleSpecTargetTargetVpnGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeHealthCheck
 */
export class ComputeHealthCheck extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeHealthCheck"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeHealthCheck',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeHealthCheck".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeHealthCheckProps): any {
    return {
      ...ComputeHealthCheck.GVK,
      ...toJson_ComputeHealthCheckProps(props),
    };
  }

  /**
   * Defines a "ComputeHealthCheck" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeHealthCheckProps) {
    super(scope, id, {
      ...ComputeHealthCheck.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeHealthCheck.GVK,
      ...toJson_ComputeHealthCheckProps(resolved),
    };
  }
}

/**
 * @schema ComputeHealthCheck
 */
export interface ComputeHealthCheckProps {
  /**
   * @schema ComputeHealthCheck#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeHealthCheck#spec
   */
  readonly spec: ComputeHealthCheckSpec;

}

/**
 * Converts an object of type 'ComputeHealthCheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckProps(obj: ComputeHealthCheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeHealthCheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeHealthCheckSpec
 */
export interface ComputeHealthCheckSpec {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   *
   * @schema ComputeHealthCheckSpec#checkIntervalSec
   */
  readonly checkIntervalSec?: number;

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeHealthCheckSpec#description
   */
  readonly description?: string;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#grpcHealthCheck
   */
  readonly grpcHealthCheck?: ComputeHealthCheckSpecGrpcHealthCheck;

  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   *
   * @schema ComputeHealthCheckSpec#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#http2HealthCheck
   */
  readonly http2HealthCheck?: ComputeHealthCheckSpecHttp2HealthCheck;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#httpHealthCheck
   */
  readonly httpHealthCheck?: ComputeHealthCheckSpecHttpHealthCheck;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#httpsHealthCheck
   */
  readonly httpsHealthCheck?: ComputeHealthCheckSpecHttpsHealthCheck;

  /**
   * Location represents the geographical location of the ComputeHealthCheck. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeHealthCheckSpec#location
   */
  readonly location: string;

  /**
   * Configure logging on this health check.
   *
   * @schema ComputeHealthCheckSpec#logConfig
   */
  readonly logConfig?: ComputeHealthCheckSpecLogConfig;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeHealthCheckSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#sslHealthCheck
   */
  readonly sslHealthCheck?: ComputeHealthCheckSpecSslHealthCheck;

  /**
   * A nested object resource.
   *
   * @schema ComputeHealthCheckSpec#tcpHealthCheck
   */
  readonly tcpHealthCheck?: ComputeHealthCheckSpecTcpHealthCheck;

  /**
   * How long (in seconds) to wait before claiming failure.
   * The default value is 5 seconds.  It is invalid for timeoutSec to have
   * greater value than checkIntervalSec.
   *
   * @schema ComputeHealthCheckSpec#timeoutSec
   */
  readonly timeoutSec?: number;

  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   *
   * @schema ComputeHealthCheckSpec#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpec(obj: ComputeHealthCheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkIntervalSec': obj.checkIntervalSec,
    'description': obj.description,
    'grpcHealthCheck': toJson_ComputeHealthCheckSpecGrpcHealthCheck(obj.grpcHealthCheck),
    'healthyThreshold': obj.healthyThreshold,
    'http2HealthCheck': toJson_ComputeHealthCheckSpecHttp2HealthCheck(obj.http2HealthCheck),
    'httpHealthCheck': toJson_ComputeHealthCheckSpecHttpHealthCheck(obj.httpHealthCheck),
    'httpsHealthCheck': toJson_ComputeHealthCheckSpecHttpsHealthCheck(obj.httpsHealthCheck),
    'location': obj.location,
    'logConfig': toJson_ComputeHealthCheckSpecLogConfig(obj.logConfig),
    'resourceID': obj.resourceId,
    'sslHealthCheck': toJson_ComputeHealthCheckSpecSslHealthCheck(obj.sslHealthCheck),
    'tcpHealthCheck': toJson_ComputeHealthCheckSpecTcpHealthCheck(obj.tcpHealthCheck),
    'timeoutSec': obj.timeoutSec,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecGrpcHealthCheck
 */
export interface ComputeHealthCheckSpecGrpcHealthCheck {
  /**
   * The gRPC service name for the health check.
   * The value of grpcServiceName has the following meanings by convention:
   * - Empty serviceName means the overall status of all services at the backend.
   * - Non-empty serviceName means the health of that gRPC service, as defined by the owner of the service.
   * The grpcServiceName can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecGrpcHealthCheck#grpcServiceName
   */
  readonly grpcServiceName?: string;

  /**
   * The port number for the health check request.
   * Must be specified if portName and portSpecification are not set
   * or if port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
   *
   * @schema ComputeHealthCheckSpecGrpcHealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecGrpcHealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, gRPC health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecGrpcHealthCheck#portSpecification
   */
  readonly portSpecification?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecGrpcHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecGrpcHealthCheck(obj: ComputeHealthCheckSpecGrpcHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcServiceName': obj.grpcServiceName,
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecHttp2HealthCheck
 */
export interface ComputeHealthCheckSpecHttp2HealthCheck {
  /**
   * The value of the host header in the HTTP2 health check request.
   * If left empty (default value), the public IP on behalf of which this health
   * check is performed will be used.
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#host
   */
  readonly host?: string;

  /**
   * The TCP port number for the HTTP2 health check request.
   * The default value is 443.
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, HTTP2 health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#portSpecification
   */
  readonly portSpecification?: string;

  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * The request path of the HTTP2 health check request.
   * The default value is /.
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#requestPath
   */
  readonly requestPath?: string;

  /**
   * The bytes to match against the beginning of the response data. If left empty
   * (the default value), any response will indicate health. The response data
   * can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecHttp2HealthCheck#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecHttp2HealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecHttp2HealthCheck(obj: ComputeHealthCheckSpecHttp2HealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
    'proxyHeader': obj.proxyHeader,
    'requestPath': obj.requestPath,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecHttpHealthCheck
 */
export interface ComputeHealthCheckSpecHttpHealthCheck {
  /**
   * The value of the host header in the HTTP health check request.
   * If left empty (default value), the public IP on behalf of which this health
   * check is performed will be used.
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#host
   */
  readonly host?: string;

  /**
   * The TCP port number for the HTTP health check request.
   * The default value is 80.
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, HTTP health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#portSpecification
   */
  readonly portSpecification?: string;

  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * The request path of the HTTP health check request.
   * The default value is /.
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#requestPath
   */
  readonly requestPath?: string;

  /**
   * The bytes to match against the beginning of the response data. If left empty
   * (the default value), any response will indicate health. The response data
   * can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecHttpHealthCheck#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecHttpHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecHttpHealthCheck(obj: ComputeHealthCheckSpecHttpHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
    'proxyHeader': obj.proxyHeader,
    'requestPath': obj.requestPath,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecHttpsHealthCheck
 */
export interface ComputeHealthCheckSpecHttpsHealthCheck {
  /**
   * The value of the host header in the HTTPS health check request.
   * If left empty (default value), the public IP on behalf of which this health
   * check is performed will be used.
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#host
   */
  readonly host?: string;

  /**
   * The TCP port number for the HTTPS health check request.
   * The default value is 443.
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, HTTPS health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#portSpecification
   */
  readonly portSpecification?: string;

  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * The request path of the HTTPS health check request.
   * The default value is /.
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#requestPath
   */
  readonly requestPath?: string;

  /**
   * The bytes to match against the beginning of the response data. If left empty
   * (the default value), any response will indicate health. The response data
   * can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecHttpsHealthCheck#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecHttpsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecHttpsHealthCheck(obj: ComputeHealthCheckSpecHttpsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
    'proxyHeader': obj.proxyHeader,
    'requestPath': obj.requestPath,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure logging on this health check.
 *
 * @schema ComputeHealthCheckSpecLogConfig
 */
export interface ComputeHealthCheckSpecLogConfig {
  /**
   * Indicates whether or not to export logs. This is false by default,
   * which means no health check logging will be done.
   *
   * @schema ComputeHealthCheckSpecLogConfig#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecLogConfig(obj: ComputeHealthCheckSpecLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecSslHealthCheck
 */
export interface ComputeHealthCheckSpecSslHealthCheck {
  /**
   * The TCP port number for the SSL health check request.
   * The default value is 443.
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, SSL health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#portSpecification
   */
  readonly portSpecification?: string;

  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * The application data to send once the SSL connection has been
   * established (default value is empty). If both request and response are
   * empty, the connection establishment alone will indicate health. The request
   * data can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#request
   */
  readonly request?: string;

  /**
   * The bytes to match against the beginning of the response data. If left empty
   * (the default value), any response will indicate health. The response data
   * can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecSslHealthCheck#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecSslHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecSslHealthCheck(obj: ComputeHealthCheckSpecSslHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
    'proxyHeader': obj.proxyHeader,
    'request': obj.request,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A nested object resource.
 *
 * @schema ComputeHealthCheckSpecTcpHealthCheck
 */
export interface ComputeHealthCheckSpecTcpHealthCheck {
  /**
   * The TCP port number for the TCP health check request.
   * The default value is 443.
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#port
   */
  readonly port?: number;

  /**
   * Port name as defined in InstanceGroup#NamedPort#name. If both port and
   * port_name are defined, port takes precedence.
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#portName
   */
  readonly portName?: string;

  /**
   * Specifies how port is selected for health checking, can be one of the
   * following values:
   *
   * * 'USE_FIXED_PORT': The port number in 'port' is used for health checking.
   *
   * * 'USE_NAMED_PORT': The 'portName' is used for health checking.
   *
   * * 'USE_SERVING_PORT': For NetworkEndpointGroup, the port specified for each
   * network endpoint is used for health checking. For other backends, the
   * port or named port specified in the Backend Service is used for health
   * checking.
   *
   * If not specified, TCP health check follows behavior specified in 'port' and
   * 'portName' fields. Possible values: ["USE_FIXED_PORT", "USE_NAMED_PORT", "USE_SERVING_PORT"].
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#portSpecification
   */
  readonly portSpecification?: string;

  /**
   * Specifies the type of proxy header to append before sending data to the
   * backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * The application data to send once the TCP connection has been
   * established (default value is empty). If both request and response are
   * empty, the connection establishment alone will indicate health. The request
   * data can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#request
   */
  readonly request?: string;

  /**
   * The bytes to match against the beginning of the response data. If left empty
   * (the default value), any response will indicate health. The response data
   * can only be ASCII.
   *
   * @schema ComputeHealthCheckSpecTcpHealthCheck#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ComputeHealthCheckSpecTcpHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHealthCheckSpecTcpHealthCheck(obj: ComputeHealthCheckSpecTcpHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'portName': obj.portName,
    'portSpecification': obj.portSpecification,
    'proxyHeader': obj.proxyHeader,
    'request': obj.request,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeHTTPHealthCheck
 */
export class ComputeHttpHealthCheck extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeHTTPHealthCheck"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeHTTPHealthCheck',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeHTTPHealthCheck".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeHttpHealthCheckProps = {}): any {
    return {
      ...ComputeHttpHealthCheck.GVK,
      ...toJson_ComputeHttpHealthCheckProps(props),
    };
  }

  /**
   * Defines a "ComputeHTTPHealthCheck" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeHttpHealthCheckProps = {}) {
    super(scope, id, {
      ...ComputeHttpHealthCheck.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeHttpHealthCheck.GVK,
      ...toJson_ComputeHttpHealthCheckProps(resolved),
    };
  }
}

/**
 * @schema ComputeHTTPHealthCheck
 */
export interface ComputeHttpHealthCheckProps {
  /**
   * @schema ComputeHTTPHealthCheck#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeHTTPHealthCheck#spec
   */
  readonly spec?: ComputeHttpHealthCheckSpec;

}

/**
 * Converts an object of type 'ComputeHttpHealthCheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHttpHealthCheckProps(obj: ComputeHttpHealthCheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeHttpHealthCheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeHttpHealthCheckSpec
 */
export interface ComputeHttpHealthCheckSpec {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   *
   * @schema ComputeHttpHealthCheckSpec#checkIntervalSec
   */
  readonly checkIntervalSec?: number;

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeHttpHealthCheckSpec#description
   */
  readonly description?: string;

  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   *
   * @schema ComputeHttpHealthCheckSpec#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * The value of the host header in the HTTP health check request. If
   * left empty (default value), the public IP on behalf of which this
   * health check is performed will be used.
   *
   * @schema ComputeHttpHealthCheckSpec#host
   */
  readonly host?: string;

  /**
   * The TCP port number for the HTTP health check request.
   * The default value is 80.
   *
   * @schema ComputeHttpHealthCheckSpec#port
   */
  readonly port?: number;

  /**
   * The request path of the HTTP health check request.
   * The default value is /.
   *
   * @schema ComputeHttpHealthCheckSpec#requestPath
   */
  readonly requestPath?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeHttpHealthCheckSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * How long (in seconds) to wait before claiming failure.
   * The default value is 5 seconds.  It is invalid for timeoutSec to have
   * greater value than checkIntervalSec.
   *
   * @schema ComputeHttpHealthCheckSpec#timeoutSec
   */
  readonly timeoutSec?: number;

  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   *
   * @schema ComputeHttpHealthCheckSpec#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'ComputeHttpHealthCheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHttpHealthCheckSpec(obj: ComputeHttpHealthCheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkIntervalSec': obj.checkIntervalSec,
    'description': obj.description,
    'healthyThreshold': obj.healthyThreshold,
    'host': obj.host,
    'port': obj.port,
    'requestPath': obj.requestPath,
    'resourceID': obj.resourceId,
    'timeoutSec': obj.timeoutSec,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeHTTPSHealthCheck
 */
export class ComputeHttpsHealthCheck extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeHTTPSHealthCheck"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeHTTPSHealthCheck',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeHTTPSHealthCheck".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeHttpsHealthCheckProps = {}): any {
    return {
      ...ComputeHttpsHealthCheck.GVK,
      ...toJson_ComputeHttpsHealthCheckProps(props),
    };
  }

  /**
   * Defines a "ComputeHTTPSHealthCheck" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeHttpsHealthCheckProps = {}) {
    super(scope, id, {
      ...ComputeHttpsHealthCheck.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeHttpsHealthCheck.GVK,
      ...toJson_ComputeHttpsHealthCheckProps(resolved),
    };
  }
}

/**
 * @schema ComputeHTTPSHealthCheck
 */
export interface ComputeHttpsHealthCheckProps {
  /**
   * @schema ComputeHTTPSHealthCheck#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeHTTPSHealthCheck#spec
   */
  readonly spec?: ComputeHttpsHealthCheckSpec;

}

/**
 * Converts an object of type 'ComputeHttpsHealthCheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHttpsHealthCheckProps(obj: ComputeHttpsHealthCheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeHttpsHealthCheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeHttpsHealthCheckSpec
 */
export interface ComputeHttpsHealthCheckSpec {
  /**
   * How often (in seconds) to send a health check. The default value is 5
   * seconds.
   *
   * @schema ComputeHttpsHealthCheckSpec#checkIntervalSec
   */
  readonly checkIntervalSec?: number;

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeHttpsHealthCheckSpec#description
   */
  readonly description?: string;

  /**
   * A so-far unhealthy instance will be marked healthy after this many
   * consecutive successes. The default value is 2.
   *
   * @schema ComputeHttpsHealthCheckSpec#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * The value of the host header in the HTTPS health check request. If
   * left empty (default value), the public IP on behalf of which this
   * health check is performed will be used.
   *
   * @schema ComputeHttpsHealthCheckSpec#host
   */
  readonly host?: string;

  /**
   * The TCP port number for the HTTPS health check request.
   * The default value is 443.
   *
   * @schema ComputeHttpsHealthCheckSpec#port
   */
  readonly port?: number;

  /**
   * The request path of the HTTPS health check request.
   * The default value is /.
   *
   * @schema ComputeHttpsHealthCheckSpec#requestPath
   */
  readonly requestPath?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeHttpsHealthCheckSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * How long (in seconds) to wait before claiming failure.
   * The default value is 5 seconds.  It is invalid for timeoutSec to have
   * greater value than checkIntervalSec.
   *
   * @schema ComputeHttpsHealthCheckSpec#timeoutSec
   */
  readonly timeoutSec?: number;

  /**
   * A so-far healthy instance will be marked unhealthy after this many
   * consecutive failures. The default value is 2.
   *
   * @schema ComputeHttpsHealthCheckSpec#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'ComputeHttpsHealthCheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeHttpsHealthCheckSpec(obj: ComputeHttpsHealthCheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkIntervalSec': obj.checkIntervalSec,
    'description': obj.description,
    'healthyThreshold': obj.healthyThreshold,
    'host': obj.host,
    'port': obj.port,
    'requestPath': obj.requestPath,
    'resourceID': obj.resourceId,
    'timeoutSec': obj.timeoutSec,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeImage
 */
export class ComputeImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeImage',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeImageProps = {}): any {
    return {
      ...ComputeImage.GVK,
      ...toJson_ComputeImageProps(props),
    };
  }

  /**
   * Defines a "ComputeImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeImageProps = {}) {
    super(scope, id, {
      ...ComputeImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeImage.GVK,
      ...toJson_ComputeImageProps(resolved),
    };
  }
}

/**
 * @schema ComputeImage
 */
export interface ComputeImageProps {
  /**
   * @schema ComputeImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeImage#spec
   */
  readonly spec?: ComputeImageSpec;

}

/**
 * Converts an object of type 'ComputeImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageProps(obj: ComputeImageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeImageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeImageSpec
 */
export interface ComputeImageSpec {
  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeImageSpec#description
   */
  readonly description?: string;

  /**
   * The source disk to create this image based on.
   * You must provide either this property or the
   * rawDisk.source property but not both to create an image.
   *
   * @schema ComputeImageSpec#diskRef
   */
  readonly diskRef?: ComputeImageSpecDiskRef;

  /**
   * Immutable. Size of the image when restored onto a persistent disk (in GB).
   *
   * @schema ComputeImageSpec#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Immutable. The name of the image family to which this image belongs. You can
   * create disks by specifying an image family instead of a specific
   * image name. The image family always returns its latest image that is
   * not deprecated. The name of the image family must comply with
   * RFC1035.
   *
   * @schema ComputeImageSpec#family
   */
  readonly family?: string;

  /**
   * Immutable. A list of features to enable on the guest operating system.
   * Applicable only for bootable images.
   *
   * @schema ComputeImageSpec#guestOsFeatures
   */
  readonly guestOsFeatures?: ComputeImageSpecGuestOsFeatures[];

  /**
   * Immutable. Encrypts the image using a customer-supplied encryption key.
   *
   * After you encrypt an image with a customer-supplied key, you must
   * provide the same key if you use the image later (e.g. to create a
   * disk from the image).
   *
   * @schema ComputeImageSpec#imageEncryptionKey
   */
  readonly imageEncryptionKey?: ComputeImageSpecImageEncryptionKey;

  /**
   * Immutable. Any applicable license URI.
   *
   * @schema ComputeImageSpec#licenses
   */
  readonly licenses?: string[];

  /**
   * Immutable. The parameters of the raw disk image.
   *
   * @schema ComputeImageSpec#rawDisk
   */
  readonly rawDisk?: ComputeImageSpecRawDisk;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeImageSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The source image used to create this image.
   *
   * @schema ComputeImageSpec#sourceImageRef
   */
  readonly sourceImageRef?: ComputeImageSpecSourceImageRef;

  /**
   * The source snapshot used to create this image.
   *
   * @schema ComputeImageSpec#sourceSnapshotRef
   */
  readonly sourceSnapshotRef?: ComputeImageSpecSourceSnapshotRef;

  /**
   * Immutable. Cloud Storage bucket storage location of the image
   * (regional or multi-regional).
   * Reference link: https://cloud.google.com/compute/docs/reference/rest/v1/images.
   *
   * @schema ComputeImageSpec#storageLocations
   */
  readonly storageLocations?: string[];

}

/**
 * Converts an object of type 'ComputeImageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpec(obj: ComputeImageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'diskRef': toJson_ComputeImageSpecDiskRef(obj.diskRef),
    'diskSizeGb': obj.diskSizeGb,
    'family': obj.family,
    'guestOsFeatures': obj.guestOsFeatures?.map(y => toJson_ComputeImageSpecGuestOsFeatures(y)),
    'imageEncryptionKey': toJson_ComputeImageSpecImageEncryptionKey(obj.imageEncryptionKey),
    'licenses': obj.licenses?.map(y => y),
    'rawDisk': toJson_ComputeImageSpecRawDisk(obj.rawDisk),
    'resourceID': obj.resourceId,
    'sourceImageRef': toJson_ComputeImageSpecSourceImageRef(obj.sourceImageRef),
    'sourceSnapshotRef': toJson_ComputeImageSpecSourceSnapshotRef(obj.sourceSnapshotRef),
    'storageLocations': obj.storageLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source disk to create this image based on.
 * You must provide either this property or the
 * rawDisk.source property but not both to create an image.
 *
 * @schema ComputeImageSpecDiskRef
 */
export interface ComputeImageSpecDiskRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeDisk` resource.
   *
   * @schema ComputeImageSpecDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeImageSpecDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeImageSpecDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeImageSpecDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecDiskRef(obj: ComputeImageSpecDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeImageSpecGuestOsFeatures
 */
export interface ComputeImageSpecGuestOsFeatures {
  /**
   * Immutable. The type of supported feature. Read [Enabling guest operating system features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features) to see a list of available options. Possible values: ["MULTI_IP_SUBNET", "SECURE_BOOT", "SEV_CAPABLE", "UEFI_COMPATIBLE", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "GVNIC", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "SUSPEND_RESUME_COMPATIBLE", "TDX_CAPABLE"].
   *
   * @schema ComputeImageSpecGuestOsFeatures#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeImageSpecGuestOsFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecGuestOsFeatures(obj: ComputeImageSpecGuestOsFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Encrypts the image using a customer-supplied encryption key.
 *
 * After you encrypt an image with a customer-supplied key, you must
 * provide the same key if you use the image later (e.g. to create a
 * disk from the image).
 *
 * @schema ComputeImageSpecImageEncryptionKey
 */
export interface ComputeImageSpecImageEncryptionKey {
  /**
   * The self link of the encryption key that is stored in Google Cloud
   * KMS.
   *
   * @schema ComputeImageSpecImageEncryptionKey#kmsKeySelfLinkRef
   */
  readonly kmsKeySelfLinkRef?: ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef;

  /**
   * The service account being used for the encryption request for the
   * given KMS key. If absent, the Compute Engine default service account
   * is used.
   *
   * @schema ComputeImageSpecImageEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef;

}

/**
 * Converts an object of type 'ComputeImageSpecImageEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecImageEncryptionKey(obj: ComputeImageSpecImageEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeySelfLinkRef': toJson_ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef(obj.kmsKeySelfLinkRef),
    'kmsKeyServiceAccountRef': toJson_ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The parameters of the raw disk image.
 *
 * @schema ComputeImageSpecRawDisk
 */
export interface ComputeImageSpecRawDisk {
  /**
   * Immutable. The format used to encode and transmit the block device, which
   * should be TAR. This is just a container and transmission format
   * and not a runtime format. Provided by the client when the disk
   * image is created. Default value: "TAR" Possible values: ["TAR"].
   *
   * @schema ComputeImageSpecRawDisk#containerType
   */
  readonly containerType?: string;

  /**
   * Immutable. An optional SHA1 checksum of the disk image before unpackaging.
   * This is provided by the client when the disk image is created.
   *
   * @schema ComputeImageSpecRawDisk#sha1
   */
  readonly sha1?: string;

  /**
   * Immutable. The full Google Cloud Storage URL where disk storage is stored
   * You must provide either this property or the sourceDisk property
   * but not both.
   *
   * @schema ComputeImageSpecRawDisk#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'ComputeImageSpecRawDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecRawDisk(obj: ComputeImageSpecRawDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerType': obj.containerType,
    'sha1': obj.sha1,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source image used to create this image.
 *
 * @schema ComputeImageSpecSourceImageRef
 */
export interface ComputeImageSpecSourceImageRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeImage` resource.
   *
   * @schema ComputeImageSpecSourceImageRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeImageSpecSourceImageRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeImageSpecSourceImageRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeImageSpecSourceImageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecSourceImageRef(obj: ComputeImageSpecSourceImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source snapshot used to create this image.
 *
 * @schema ComputeImageSpecSourceSnapshotRef
 */
export interface ComputeImageSpecSourceSnapshotRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSnapshot` resource.
   *
   * @schema ComputeImageSpecSourceSnapshotRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeImageSpecSourceSnapshotRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeImageSpecSourceSnapshotRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeImageSpecSourceSnapshotRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecSourceSnapshotRef(obj: ComputeImageSpecSourceSnapshotRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The self link of the encryption key that is stored in Google Cloud
 * KMS.
 *
 * @schema ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef
 */
export interface ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef(obj: ComputeImageSpecImageEncryptionKeyKmsKeySelfLinkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account being used for the encryption request for the
 * given KMS key. If absent, the Compute Engine default service account
 * is used.
 *
 * @schema ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeImageSpecImageEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeInstance
 */
export class ComputeInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeInstanceProps): any {
    return {
      ...ComputeInstance.GVK,
      ...toJson_ComputeInstanceProps(props),
    };
  }

  /**
   * Defines a "ComputeInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeInstanceProps) {
    super(scope, id, {
      ...ComputeInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeInstance.GVK,
      ...toJson_ComputeInstanceProps(resolved),
    };
  }
}

/**
 * @schema ComputeInstance
 */
export interface ComputeInstanceProps {
  /**
   * @schema ComputeInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeInstance#spec
   */
  readonly spec: ComputeInstanceSpec;

}

/**
 * Converts an object of type 'ComputeInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceProps(obj: ComputeInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpec
 */
export interface ComputeInstanceSpec {
  /**
   * Controls for advanced machine-related behavior features.
   *
   * @schema ComputeInstanceSpec#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ComputeInstanceSpecAdvancedMachineFeatures;

  /**
   * List of disks attached to the instance.
   *
   * @schema ComputeInstanceSpec#attachedDisk
   */
  readonly attachedDisk?: ComputeInstanceSpecAttachedDisk[];

  /**
   * Immutable. The boot disk for the instance.
   *
   * @schema ComputeInstanceSpec#bootDisk
   */
  readonly bootDisk?: ComputeInstanceSpecBootDisk;

  /**
   * Whether sending and receiving of packets with non-matching source or destination IPs is allowed.
   *
   * @schema ComputeInstanceSpec#canIpForward
   */
  readonly canIpForward?: boolean;

  /**
   * Immutable. The Confidential VM config being used by the instance.  on_host_maintenance has to be set to TERMINATE or this will fail to create.
   *
   * @schema ComputeInstanceSpec#confidentialInstanceConfig
   */
  readonly confidentialInstanceConfig?: ComputeInstanceSpecConfidentialInstanceConfig;

  /**
   * Whether deletion protection is enabled on this instance.
   *
   * @schema ComputeInstanceSpec#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Immutable. A brief description of the resource.
   *
   * @schema ComputeInstanceSpec#description
   */
  readonly description?: string;

  /**
   * Desired status of the instance. Either "RUNNING" or "TERMINATED".
   *
   * @schema ComputeInstanceSpec#desiredStatus
   */
  readonly desiredStatus?: string;

  /**
   * Whether the instance has virtual displays enabled.
   *
   * @schema ComputeInstanceSpec#enableDisplay
   */
  readonly enableDisplay?: boolean;

  /**
   * Immutable. List of the type and count of accelerator cards attached to the instance.
   *
   * @schema ComputeInstanceSpec#guestAccelerator
   */
  readonly guestAccelerator?: ComputeInstanceSpecGuestAccelerator[];

  /**
   * Immutable. A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid. Valid format is a series of labels 1-63 characters long matching the regular expression [a-z]([-a-z0-9]*[a-z0-9]), concatenated with periods. The entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.
   *
   * @schema ComputeInstanceSpec#hostname
   */
  readonly hostname?: string;

  /**
   * @schema ComputeInstanceSpec#instanceTemplateRef
   */
  readonly instanceTemplateRef?: ComputeInstanceSpecInstanceTemplateRef;

  /**
   * The machine type to create.
   *
   * @schema ComputeInstanceSpec#machineType
   */
  readonly machineType?: string;

  /**
   * @schema ComputeInstanceSpec#metadata
   */
  readonly metadata?: ComputeInstanceSpecMetadata[];

  /**
   * Immutable. Metadata startup scripts made available within the instance.
   *
   * @schema ComputeInstanceSpec#metadataStartupScript
   */
  readonly metadataStartupScript?: string;

  /**
   * The minimum CPU platform specified for the VM instance.
   *
   * @schema ComputeInstanceSpec#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Immutable. The networks attached to the instance.
   *
   * @schema ComputeInstanceSpec#networkInterface
   */
  readonly networkInterface?: ComputeInstanceSpecNetworkInterface[];

  /**
   * Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.
   *
   * @schema ComputeInstanceSpec#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ComputeInstanceSpecNetworkPerformanceConfig;

  /**
   * Immutable. Stores additional params passed with the request, but not persisted as part of resource payload.
   *
   * @schema ComputeInstanceSpec#params
   */
  readonly params?: ComputeInstanceSpecParams;

  /**
   * Immutable. Specifies the reservations that this instance can consume from.
   *
   * @schema ComputeInstanceSpec#reservationAffinity
   */
  readonly reservationAffinity?: ComputeInstanceSpecReservationAffinity;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeInstanceSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeInstanceSpec#resourcePolicies
   */
  readonly resourcePolicies?: ComputeInstanceSpecResourcePolicies[];

  /**
   * The scheduling strategy being used by the instance.
   *
   * @schema ComputeInstanceSpec#scheduling
   */
  readonly scheduling?: ComputeInstanceSpecScheduling;

  /**
   * Immutable. The scratch disks attached to the instance.
   *
   * @schema ComputeInstanceSpec#scratchDisk
   */
  readonly scratchDisk?: ComputeInstanceSpecScratchDisk[];

  /**
   * The service account to attach to the instance.
   *
   * @schema ComputeInstanceSpec#serviceAccount
   */
  readonly serviceAccount?: ComputeInstanceSpecServiceAccount;

  /**
   * The shielded vm config being used by the instance.
   *
   * @schema ComputeInstanceSpec#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ComputeInstanceSpecShieldedInstanceConfig;

  /**
   * The list of tags attached to the instance.
   *
   * @schema ComputeInstanceSpec#tags
   */
  readonly tags?: string[];

  /**
   * Immutable. The zone of the instance. If self_link is provided, this value is ignored. If neither self_link nor zone are provided, the provider zone is used.
   *
   * @schema ComputeInstanceSpec#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpec(obj: ComputeInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_ComputeInstanceSpecAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'attachedDisk': obj.attachedDisk?.map(y => toJson_ComputeInstanceSpecAttachedDisk(y)),
    'bootDisk': toJson_ComputeInstanceSpecBootDisk(obj.bootDisk),
    'canIpForward': obj.canIpForward,
    'confidentialInstanceConfig': toJson_ComputeInstanceSpecConfidentialInstanceConfig(obj.confidentialInstanceConfig),
    'deletionProtection': obj.deletionProtection,
    'description': obj.description,
    'desiredStatus': obj.desiredStatus,
    'enableDisplay': obj.enableDisplay,
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ComputeInstanceSpecGuestAccelerator(y)),
    'hostname': obj.hostname,
    'instanceTemplateRef': toJson_ComputeInstanceSpecInstanceTemplateRef(obj.instanceTemplateRef),
    'machineType': obj.machineType,
    'metadata': obj.metadata?.map(y => toJson_ComputeInstanceSpecMetadata(y)),
    'metadataStartupScript': obj.metadataStartupScript,
    'minCpuPlatform': obj.minCpuPlatform,
    'networkInterface': obj.networkInterface?.map(y => toJson_ComputeInstanceSpecNetworkInterface(y)),
    'networkPerformanceConfig': toJson_ComputeInstanceSpecNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'params': toJson_ComputeInstanceSpecParams(obj.params),
    'reservationAffinity': toJson_ComputeInstanceSpecReservationAffinity(obj.reservationAffinity),
    'resourceID': obj.resourceId,
    'resourcePolicies': obj.resourcePolicies?.map(y => toJson_ComputeInstanceSpecResourcePolicies(y)),
    'scheduling': toJson_ComputeInstanceSpecScheduling(obj.scheduling),
    'scratchDisk': obj.scratchDisk?.map(y => toJson_ComputeInstanceSpecScratchDisk(y)),
    'serviceAccount': toJson_ComputeInstanceSpecServiceAccount(obj.serviceAccount),
    'shieldedInstanceConfig': toJson_ComputeInstanceSpecShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'tags': obj.tags?.map(y => y),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Controls for advanced machine-related behavior features.
 *
 * @schema ComputeInstanceSpecAdvancedMachineFeatures
 */
export interface ComputeInstanceSpecAdvancedMachineFeatures {
  /**
   * Whether to enable nested virtualization or not.
   *
   * @schema ComputeInstanceSpecAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ComputeInstanceSpecAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;

  /**
   * The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\'s nominal CPU count and the underlying platform\'s SMT width.
   *
   * @schema ComputeInstanceSpecAdvancedMachineFeatures#visibleCoreCount
   */
  readonly visibleCoreCount?: number;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAdvancedMachineFeatures(obj: ComputeInstanceSpecAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'threadsPerCore': obj.threadsPerCore,
    'visibleCoreCount': obj.visibleCoreCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecAttachedDisk
 */
export interface ComputeInstanceSpecAttachedDisk {
  /**
   * Name with which the attached disk is accessible under /dev/disk/by-id/.
   *
   * @schema ComputeInstanceSpecAttachedDisk#deviceName
   */
  readonly deviceName?: string;

  /**
   * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
   *
   * @schema ComputeInstanceSpecAttachedDisk#diskEncryptionKeyRaw
   */
  readonly diskEncryptionKeyRaw?: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
   *
   * @schema ComputeInstanceSpecAttachedDisk#diskEncryptionKeySha256
   */
  readonly diskEncryptionKeySha256?: string;

  /**
   * @schema ComputeInstanceSpecAttachedDisk#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeInstanceSpecAttachedDiskKmsKeyRef;

  /**
   * Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
   *
   * @schema ComputeInstanceSpecAttachedDisk#mode
   */
  readonly mode?: string;

  /**
   * @schema ComputeInstanceSpecAttachedDisk#sourceDiskRef
   */
  readonly sourceDiskRef: ComputeInstanceSpecAttachedDiskSourceDiskRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDisk(obj: ComputeInstanceSpecAttachedDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'diskEncryptionKeyRaw': toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw(obj.diskEncryptionKeyRaw),
    'diskEncryptionKeySha256': obj.diskEncryptionKeySha256,
    'kmsKeyRef': toJson_ComputeInstanceSpecAttachedDiskKmsKeyRef(obj.kmsKeyRef),
    'mode': obj.mode,
    'sourceDiskRef': toJson_ComputeInstanceSpecAttachedDiskSourceDiskRef(obj.sourceDiskRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The boot disk for the instance.
 *
 * @schema ComputeInstanceSpecBootDisk
 */
export interface ComputeInstanceSpecBootDisk {
  /**
   * Immutable. Whether the disk will be auto-deleted when the instance is deleted.
   *
   * @schema ComputeInstanceSpecBootDisk#autoDelete
   */
  readonly autoDelete?: boolean;

  /**
   * Immutable. Name with which attached disk will be accessible under /dev/disk/by-id/.
   *
   * @schema ComputeInstanceSpecBootDisk#deviceName
   */
  readonly deviceName?: string;

  /**
   * Immutable. A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
   *
   * @schema ComputeInstanceSpecBootDisk#diskEncryptionKeyRaw
   */
  readonly diskEncryptionKeyRaw?: ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
   *
   * @schema ComputeInstanceSpecBootDisk#diskEncryptionKeySha256
   */
  readonly diskEncryptionKeySha256?: string;

  /**
   * Immutable. Parameters with which a disk was created alongside the instance.
   *
   * @schema ComputeInstanceSpecBootDisk#initializeParams
   */
  readonly initializeParams?: ComputeInstanceSpecBootDiskInitializeParams;

  /**
   * @schema ComputeInstanceSpecBootDisk#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeInstanceSpecBootDiskKmsKeyRef;

  /**
   * Immutable. Read/write mode for the disk. One of "READ_ONLY" or "READ_WRITE".
   *
   * @schema ComputeInstanceSpecBootDisk#mode
   */
  readonly mode?: string;

  /**
   * Immutable. The source disk used to create this disk.
   *
   * @schema ComputeInstanceSpecBootDisk#sourceDiskRef
   */
  readonly sourceDiskRef?: ComputeInstanceSpecBootDiskSourceDiskRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDisk(obj: ComputeInstanceSpecBootDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDelete': obj.autoDelete,
    'deviceName': obj.deviceName,
    'diskEncryptionKeyRaw': toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw(obj.diskEncryptionKeyRaw),
    'diskEncryptionKeySha256': obj.diskEncryptionKeySha256,
    'initializeParams': toJson_ComputeInstanceSpecBootDiskInitializeParams(obj.initializeParams),
    'kmsKeyRef': toJson_ComputeInstanceSpecBootDiskKmsKeyRef(obj.kmsKeyRef),
    'mode': obj.mode,
    'sourceDiskRef': toJson_ComputeInstanceSpecBootDiskSourceDiskRef(obj.sourceDiskRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Confidential VM config being used by the instance.  on_host_maintenance has to be set to TERMINATE or this will fail to create.
 *
 * @schema ComputeInstanceSpecConfidentialInstanceConfig
 */
export interface ComputeInstanceSpecConfidentialInstanceConfig {
  /**
   * Defines whether the instance should have confidential compute enabled.
   *
   * @schema ComputeInstanceSpecConfidentialInstanceConfig#enableConfidentialCompute
   */
  readonly enableConfidentialCompute: boolean;

}

/**
 * Converts an object of type 'ComputeInstanceSpecConfidentialInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecConfidentialInstanceConfig(obj: ComputeInstanceSpecConfidentialInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableConfidentialCompute': obj.enableConfidentialCompute,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecGuestAccelerator
 */
export interface ComputeInstanceSpecGuestAccelerator {
  /**
   * Immutable. The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ComputeInstanceSpecGuestAccelerator#count
   */
  readonly count: number;

  /**
   * Immutable. The accelerator type resource exposed to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ComputeInstanceSpecGuestAccelerator#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecGuestAccelerator(obj: ComputeInstanceSpecGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecInstanceTemplateRef
 */
export interface ComputeInstanceSpecInstanceTemplateRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstanceTemplate` resource.
   *
   * @schema ComputeInstanceSpecInstanceTemplateRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecInstanceTemplateRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecInstanceTemplateRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecInstanceTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecInstanceTemplateRef(obj: ComputeInstanceSpecInstanceTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecMetadata
 */
export interface ComputeInstanceSpecMetadata {
  /**
   * @schema ComputeInstanceSpecMetadata#key
   */
  readonly key: string;

  /**
   * @schema ComputeInstanceSpecMetadata#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecMetadata(obj: ComputeInstanceSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterface
 */
export interface ComputeInstanceSpecNetworkInterface {
  /**
   * Access configurations, i.e. IPs via which this instance can be accessed via the Internet.
   *
   * @schema ComputeInstanceSpecNetworkInterface#accessConfig
   */
  readonly accessConfig?: ComputeInstanceSpecNetworkInterfaceAccessConfig[];

  /**
   * An array of alias IP ranges for this network interface.
   *
   * @schema ComputeInstanceSpecNetworkInterface#aliasIpRange
   */
  readonly aliasIpRange?: ComputeInstanceSpecNetworkInterfaceAliasIpRange[];

  /**
   * An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
   *
   * @schema ComputeInstanceSpecNetworkInterface#ipv6AccessConfig
   */
  readonly ipv6AccessConfig?: ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig[];

  /**
   * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
   *
   * @schema ComputeInstanceSpecNetworkInterface#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * The name of the interface.
   *
   * @schema ComputeInstanceSpecNetworkInterface#name
   */
  readonly name?: string;

  /**
   * DEPRECATED. Although this field is still available, there is limited support. We recommend that you use `spec.networkInterface.networkIpRef` instead.
   *
   * @schema ComputeInstanceSpecNetworkInterface#networkIp
   */
  readonly networkIp?: string;

  /**
   * @schema ComputeInstanceSpecNetworkInterface#networkIpRef
   */
  readonly networkIpRef?: ComputeInstanceSpecNetworkInterfaceNetworkIpRef;

  /**
   * @schema ComputeInstanceSpecNetworkInterface#networkRef
   */
  readonly networkRef?: ComputeInstanceSpecNetworkInterfaceNetworkRef;

  /**
   * Immutable. The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET.
   *
   * @schema ComputeInstanceSpecNetworkInterface#nicType
   */
  readonly nicType?: string;

  /**
   * Immutable. The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
   *
   * @schema ComputeInstanceSpecNetworkInterface#queueCount
   */
  readonly queueCount?: number;

  /**
   * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
   *
   * @schema ComputeInstanceSpecNetworkInterface#stackType
   */
  readonly stackType?: string;

  /**
   * The project in which the subnetwork belongs.
   *
   * @schema ComputeInstanceSpecNetworkInterface#subnetworkProject
   */
  readonly subnetworkProject?: string;

  /**
   * @schema ComputeInstanceSpecNetworkInterface#subnetworkRef
   */
  readonly subnetworkRef?: ComputeInstanceSpecNetworkInterfaceSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterface' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterface(obj: ComputeInstanceSpecNetworkInterface | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessConfig': obj.accessConfig?.map(y => toJson_ComputeInstanceSpecNetworkInterfaceAccessConfig(y)),
    'aliasIpRange': obj.aliasIpRange?.map(y => toJson_ComputeInstanceSpecNetworkInterfaceAliasIpRange(y)),
    'ipv6AccessConfig': obj.ipv6AccessConfig?.map(y => toJson_ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig(y)),
    'ipv6AccessType': obj.ipv6AccessType,
    'name': obj.name,
    'networkIp': obj.networkIp,
    'networkIpRef': toJson_ComputeInstanceSpecNetworkInterfaceNetworkIpRef(obj.networkIpRef),
    'networkRef': toJson_ComputeInstanceSpecNetworkInterfaceNetworkRef(obj.networkRef),
    'nicType': obj.nicType,
    'queueCount': obj.queueCount,
    'stackType': obj.stackType,
    'subnetworkProject': obj.subnetworkProject,
    'subnetworkRef': toJson_ComputeInstanceSpecNetworkInterfaceSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.
 *
 * @schema ComputeInstanceSpecNetworkPerformanceConfig
 */
export interface ComputeInstanceSpecNetworkPerformanceConfig {
  /**
   * Immutable. The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT.
   *
   * @schema ComputeInstanceSpecNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkPerformanceConfig(obj: ComputeInstanceSpecNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Stores additional params passed with the request, but not persisted as part of resource payload.
 *
 * @schema ComputeInstanceSpecParams
 */
export interface ComputeInstanceSpecParams {
  /**
   * Immutable. A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
   *
   * @schema ComputeInstanceSpecParams#resourceManagerTags
   */
  readonly resourceManagerTags?: any;

}

/**
 * Converts an object of type 'ComputeInstanceSpecParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecParams(obj: ComputeInstanceSpecParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceManagerTags': obj.resourceManagerTags,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the reservations that this instance can consume from.
 *
 * @schema ComputeInstanceSpecReservationAffinity
 */
export interface ComputeInstanceSpecReservationAffinity {
  /**
   * Immutable. Specifies the label selector for the reservation to use.
   *
   * @schema ComputeInstanceSpecReservationAffinity#specificReservation
   */
  readonly specificReservation?: ComputeInstanceSpecReservationAffinitySpecificReservation;

  /**
   * Immutable. The type of reservation from which this instance can consume resources.
   *
   * @schema ComputeInstanceSpecReservationAffinity#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecReservationAffinity(obj: ComputeInstanceSpecReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'specificReservation': toJson_ComputeInstanceSpecReservationAffinitySpecificReservation(obj.specificReservation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecResourcePolicies
 */
export interface ComputeInstanceSpecResourcePolicies {
  /**
   * Allowed value: The `selfLink` field of a `ComputeResourcePolicy` resource.
   *
   * @schema ComputeInstanceSpecResourcePolicies#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecResourcePolicies#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecResourcePolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecResourcePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecResourcePolicies(obj: ComputeInstanceSpecResourcePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The scheduling strategy being used by the instance.
 *
 * @schema ComputeInstanceSpecScheduling
 */
export interface ComputeInstanceSpecScheduling {
  /**
   * Specifies if the instance should be restarted if it was terminated by Compute Engine (not a user).
   *
   * @schema ComputeInstanceSpecScheduling#automaticRestart
   */
  readonly automaticRestart?: boolean;

  /**
   * Specifies the action GCE should take when SPOT VM is preempted.
   *
   * @schema ComputeInstanceSpecScheduling#instanceTerminationAction
   */
  readonly instanceTerminationAction?: string;

  /**
   * Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC.
   *
   * @schema ComputeInstanceSpecScheduling#maintenanceInterval
   */
  readonly maintenanceInterval?: string;

  /**
   * Immutable. The timeout for new network connections to hosts.
   *
   * @schema ComputeInstanceSpecScheduling#maxRunDuration
   */
  readonly maxRunDuration?: ComputeInstanceSpecSchedulingMaxRunDuration;

  /**
   * @schema ComputeInstanceSpecScheduling#minNodeCpus
   */
  readonly minNodeCpus?: number;

  /**
   * @schema ComputeInstanceSpecScheduling#nodeAffinities
   */
  readonly nodeAffinities?: ComputeInstanceSpecSchedulingNodeAffinities[];

  /**
   * Describes maintenance behavior for the instance. One of MIGRATE or TERMINATE,.
   *
   * @schema ComputeInstanceSpecScheduling#onHostMaintenance
   */
  readonly onHostMaintenance?: string;

  /**
   * Immutable. Whether the instance is preemptible.
   *
   * @schema ComputeInstanceSpecScheduling#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * Immutable. Whether the instance is spot. If this is set as SPOT.
   *
   * @schema ComputeInstanceSpecScheduling#provisioningModel
   */
  readonly provisioningModel?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecScheduling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecScheduling(obj: ComputeInstanceSpecScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automaticRestart': obj.automaticRestart,
    'instanceTerminationAction': obj.instanceTerminationAction,
    'maintenanceInterval': obj.maintenanceInterval,
    'maxRunDuration': toJson_ComputeInstanceSpecSchedulingMaxRunDuration(obj.maxRunDuration),
    'minNodeCpus': obj.minNodeCpus,
    'nodeAffinities': obj.nodeAffinities?.map(y => toJson_ComputeInstanceSpecSchedulingNodeAffinities(y)),
    'onHostMaintenance': obj.onHostMaintenance,
    'preemptible': obj.preemptible,
    'provisioningModel': obj.provisioningModel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecScratchDisk
 */
export interface ComputeInstanceSpecScratchDisk {
  /**
   * The disk interface used for attaching this disk. One of SCSI or NVME.
   *
   * @schema ComputeInstanceSpecScratchDisk#interface
   */
  readonly interface: string;

  /**
   * Immutable. The size of the disk in gigabytes. One of 375 or 3000.
   *
   * @schema ComputeInstanceSpecScratchDisk#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'ComputeInstanceSpecScratchDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecScratchDisk(obj: ComputeInstanceSpecScratchDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interface': obj.interface,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account to attach to the instance.
 *
 * @schema ComputeInstanceSpecServiceAccount
 */
export interface ComputeInstanceSpecServiceAccount {
  /**
   * A list of service scopes.
   *
   * @schema ComputeInstanceSpecServiceAccount#scopes
   */
  readonly scopes: string[];

  /**
   * @schema ComputeInstanceSpecServiceAccount#serviceAccountRef
   */
  readonly serviceAccountRef?: ComputeInstanceSpecServiceAccountServiceAccountRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecServiceAccount(obj: ComputeInstanceSpecServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scopes': obj.scopes?.map(y => y),
    'serviceAccountRef': toJson_ComputeInstanceSpecServiceAccountServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The shielded vm config being used by the instance.
 *
 * @schema ComputeInstanceSpecShieldedInstanceConfig
 */
export interface ComputeInstanceSpecShieldedInstanceConfig {
  /**
   * Whether integrity monitoring is enabled for the instance.
   *
   * @schema ComputeInstanceSpecShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Whether secure boot is enabled for the instance.
   *
   * @schema ComputeInstanceSpecShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;

  /**
   * Whether the instance uses vTPM.
   *
   * @schema ComputeInstanceSpecShieldedInstanceConfig#enableVtpm
   */
  readonly enableVtpm?: boolean;

}

/**
 * Converts an object of type 'ComputeInstanceSpecShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecShieldedInstanceConfig(obj: ComputeInstanceSpecShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
    'enableVtpm': obj.enableVtpm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
 *
 * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw
 */
export interface ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw#valueFrom
   */
  readonly valueFrom?: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw(obj: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRaw | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecAttachedDiskKmsKeyRef
 */
export interface ComputeInstanceSpecAttachedDiskKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeInstanceSpecAttachedDiskKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecAttachedDiskKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecAttachedDiskKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDiskKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDiskKmsKeyRef(obj: ComputeInstanceSpecAttachedDiskKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecAttachedDiskSourceDiskRef
 */
export interface ComputeInstanceSpecAttachedDiskSourceDiskRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeDisk` resource.
   *
   * @schema ComputeInstanceSpecAttachedDiskSourceDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecAttachedDiskSourceDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecAttachedDiskSourceDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDiskSourceDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDiskSourceDiskRef(obj: ComputeInstanceSpecAttachedDiskSourceDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. A 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to encrypt this disk. Only one of kms_key_self_link and disk_encryption_key_raw may be set.
 *
 * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw
 */
export interface ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw#valueFrom
   */
  readonly valueFrom?: ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw(obj: ComputeInstanceSpecBootDiskDiskEncryptionKeyRaw | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Parameters with which a disk was created alongside the instance.
 *
 * @schema ComputeInstanceSpecBootDiskInitializeParams
 */
export interface ComputeInstanceSpecBootDiskInitializeParams {
  /**
   * Immutable. A set of key/value label pairs assigned to the disk.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParams#labels
   */
  readonly labels?: any;

  /**
   * Immutable. A map of resource manager tags. Resource manager tag keys and values have the same definition as resource manager tags. Keys must be in the format tagKeys/{tag_key_id}, and values are in the format tagValues/456. The field is ignored (both PUT & PATCH) when empty.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParams#resourceManagerTags
   */
  readonly resourceManagerTags?: any;

  /**
   * Immutable. The size of the image in gigabytes.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParams#size
   */
  readonly size?: number;

  /**
   * Immutable. The image from which to initialize this disk.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParams#sourceImageRef
   */
  readonly sourceImageRef?: ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef;

  /**
   * Immutable. The Google Compute Engine disk type. Such as pd-standard, pd-ssd or pd-balanced.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParams#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskInitializeParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskInitializeParams(obj: ComputeInstanceSpecBootDiskInitializeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'resourceManagerTags': obj.resourceManagerTags,
    'size': obj.size,
    'sourceImageRef': toJson_ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef(obj.sourceImageRef),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecBootDiskKmsKeyRef
 */
export interface ComputeInstanceSpecBootDiskKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeInstanceSpecBootDiskKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecBootDiskKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecBootDiskKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskKmsKeyRef(obj: ComputeInstanceSpecBootDiskKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The source disk used to create this disk.
 *
 * @schema ComputeInstanceSpecBootDiskSourceDiskRef
 */
export interface ComputeInstanceSpecBootDiskSourceDiskRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeDisk` resource.
   *
   * @schema ComputeInstanceSpecBootDiskSourceDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecBootDiskSourceDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecBootDiskSourceDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskSourceDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskSourceDiskRef(obj: ComputeInstanceSpecBootDiskSourceDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceAccessConfig
 */
export interface ComputeInstanceSpecNetworkInterfaceAccessConfig {
  /**
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfig#natIpRef
   */
  readonly natIpRef?: ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef;

  /**
   * The networking tier used for configuring this instance. One of PREMIUM or STANDARD.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfig#networkTier
   */
  readonly networkTier?: string;

  /**
   * The DNS domain name for the public PTR record.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfig#publicPtrDomainName
   */
  readonly publicPtrDomainName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceAccessConfig(obj: ComputeInstanceSpecNetworkInterfaceAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'natIpRef': toJson_ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef(obj.natIpRef),
    'networkTier': obj.networkTier,
    'publicPtrDomainName': obj.publicPtrDomainName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceAliasIpRange
 */
export interface ComputeInstanceSpecNetworkInterfaceAliasIpRange {
  /**
   * The IP CIDR range represented by this alias IP range.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAliasIpRange#ipCidrRange
   */
  readonly ipCidrRange: string;

  /**
   * The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAliasIpRange#subnetworkRangeName
   */
  readonly subnetworkRangeName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceAliasIpRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceAliasIpRange(obj: ComputeInstanceSpecNetworkInterfaceAliasIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'subnetworkRangeName': obj.subnetworkRangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig
 */
export interface ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig {
  /**
   * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig#externalIpv6
   */
  readonly externalIpv6?: string;

  /**
   * The prefix length of the external IPv6 range.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig#externalIpv6PrefixLength
   */
  readonly externalIpv6PrefixLength?: string;

  /**
   * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig#networkTier
   */
  readonly networkTier: string;

  /**
   * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig#publicPtrDomainName
   */
  readonly publicPtrDomainName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig(obj: ComputeInstanceSpecNetworkInterfaceIpv6AccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalIpv6': obj.externalIpv6,
    'externalIpv6PrefixLength': obj.externalIpv6PrefixLength,
    'networkTier': obj.networkTier,
    'publicPtrDomainName': obj.publicPtrDomainName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceNetworkIpRef
 */
export interface ComputeInstanceSpecNetworkInterfaceNetworkIpRef {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkIpRef#external
   */
  readonly external?: string;

  /**
   * Kind of the referent. Allowed values: ComputeAddress
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkIpRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkIpRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkIpRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceNetworkIpRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceNetworkIpRef(obj: ComputeInstanceSpecNetworkInterfaceNetworkIpRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceNetworkRef
 */
export interface ComputeInstanceSpecNetworkInterfaceNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecNetworkInterfaceNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceNetworkRef(obj: ComputeInstanceSpecNetworkInterfaceNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceSubnetworkRef
 */
export interface ComputeInstanceSpecNetworkInterfaceSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecNetworkInterfaceSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecNetworkInterfaceSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceSubnetworkRef(obj: ComputeInstanceSpecNetworkInterfaceSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the label selector for the reservation to use.
 *
 * @schema ComputeInstanceSpecReservationAffinitySpecificReservation
 */
export interface ComputeInstanceSpecReservationAffinitySpecificReservation {
  /**
   * Immutable. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
   *
   * @schema ComputeInstanceSpecReservationAffinitySpecificReservation#key
   */
  readonly key: string;

  /**
   * Immutable. Corresponds to the label values of a reservation resource.
   *
   * @schema ComputeInstanceSpecReservationAffinitySpecificReservation#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'ComputeInstanceSpecReservationAffinitySpecificReservation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecReservationAffinitySpecificReservation(obj: ComputeInstanceSpecReservationAffinitySpecificReservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The timeout for new network connections to hosts.
 *
 * @schema ComputeInstanceSpecSchedulingMaxRunDuration
 */
export interface ComputeInstanceSpecSchedulingMaxRunDuration {
  /**
   * Immutable. Span of time that's a fraction of a second at nanosecond
   * resolution. Durations less than one second are represented
   * with a 0 seconds field and a positive nanos field. Must
   * be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeInstanceSpecSchedulingMaxRunDuration#nanos
   */
  readonly nanos?: number;

  /**
   * Immutable. Span of time at a resolution of a second.
   * Must be from 0 to 315,576,000,000 inclusive.
   *
   * @schema ComputeInstanceSpecSchedulingMaxRunDuration#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeInstanceSpecSchedulingMaxRunDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecSchedulingMaxRunDuration(obj: ComputeInstanceSpecSchedulingMaxRunDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecSchedulingNodeAffinities
 */
export interface ComputeInstanceSpecSchedulingNodeAffinities {
  /**
   * @schema ComputeInstanceSpecSchedulingNodeAffinities#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ComputeInstanceSpecSchedulingNodeAffinities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecSchedulingNodeAffinities(obj: ComputeInstanceSpecSchedulingNodeAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecServiceAccountServiceAccountRef
 */
export interface ComputeInstanceSpecServiceAccountServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeInstanceSpecServiceAccountServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecServiceAccountServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecServiceAccountServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecServiceAccountServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecServiceAccountServiceAccountRef(obj: ComputeInstanceSpecServiceAccountServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom
 */
export interface ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom(obj: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom
 */
export interface ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom(obj: ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The image from which to initialize this disk.
 *
 * @schema ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef
 */
export interface ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeImage` resource.
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef(obj: ComputeInstanceSpecBootDiskInitializeParamsSourceImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef
 */
export interface ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef(obj: ComputeInstanceSpecNetworkInterfaceAccessConfigNatIpRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef
 */
export interface ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef(obj: ComputeInstanceSpecAttachedDiskDiskEncryptionKeyRawValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef
 */
export interface ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef(obj: ComputeInstanceSpecBootDiskDiskEncryptionKeyRawValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeInstanceGroup
 */
export class ComputeInstanceGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeInstanceGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeInstanceGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeInstanceGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeInstanceGroupProps): any {
    return {
      ...ComputeInstanceGroup.GVK,
      ...toJson_ComputeInstanceGroupProps(props),
    };
  }

  /**
   * Defines a "ComputeInstanceGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeInstanceGroupProps) {
    super(scope, id, {
      ...ComputeInstanceGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeInstanceGroup.GVK,
      ...toJson_ComputeInstanceGroupProps(resolved),
    };
  }
}

/**
 * @schema ComputeInstanceGroup
 */
export interface ComputeInstanceGroupProps {
  /**
   * @schema ComputeInstanceGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeInstanceGroup#spec
   */
  readonly spec: ComputeInstanceGroupSpec;

}

/**
 * Converts an object of type 'ComputeInstanceGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupProps(obj: ComputeInstanceGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeInstanceGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupSpec
 */
export interface ComputeInstanceGroupSpec {
  /**
   * Immutable. An optional textual description of the instance group.
   *
   * @schema ComputeInstanceGroupSpec#description
   */
  readonly description?: string;

  /**
   * @schema ComputeInstanceGroupSpec#instances
   */
  readonly instances?: ComputeInstanceGroupSpecInstances[];

  /**
   * The named port configuration.
   *
   * @schema ComputeInstanceGroupSpec#namedPort
   */
  readonly namedPort?: ComputeInstanceGroupSpecNamedPort[];

  /**
   * @schema ComputeInstanceGroupSpec#networkRef
   */
  readonly networkRef?: ComputeInstanceGroupSpecNetworkRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeInstanceGroupSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. The zone that this instance group should be created in.
   *
   * @schema ComputeInstanceGroupSpec#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupSpec(obj: ComputeInstanceGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instances': obj.instances?.map(y => toJson_ComputeInstanceGroupSpecInstances(y)),
    'namedPort': obj.namedPort?.map(y => toJson_ComputeInstanceGroupSpecNamedPort(y)),
    'networkRef': toJson_ComputeInstanceGroupSpecNetworkRef(obj.networkRef),
    'resourceID': obj.resourceId,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupSpecInstances
 */
export interface ComputeInstanceGroupSpecInstances {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputeInstanceGroupSpecInstances#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupSpecInstances#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupSpecInstances#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupSpecInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupSpecInstances(obj: ComputeInstanceGroupSpecInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupSpecNamedPort
 */
export interface ComputeInstanceGroupSpecNamedPort {
  /**
   * The name which the port will be mapped to.
   *
   * @schema ComputeInstanceGroupSpecNamedPort#name
   */
  readonly name: string;

  /**
   * The port number to map the name to.
   *
   * @schema ComputeInstanceGroupSpecNamedPort#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupSpecNamedPort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupSpecNamedPort(obj: ComputeInstanceGroupSpecNamedPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupSpecNetworkRef
 */
export interface ComputeInstanceGroupSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeInstanceGroupSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupSpecNetworkRef(obj: ComputeInstanceGroupSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeInstanceGroupManager
 */
export class ComputeInstanceGroupManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeInstanceGroupManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeInstanceGroupManager',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeInstanceGroupManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeInstanceGroupManagerProps): any {
    return {
      ...ComputeInstanceGroupManager.GVK,
      ...toJson_ComputeInstanceGroupManagerProps(props),
    };
  }

  /**
   * Defines a "ComputeInstanceGroupManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeInstanceGroupManagerProps) {
    super(scope, id, {
      ...ComputeInstanceGroupManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeInstanceGroupManager.GVK,
      ...toJson_ComputeInstanceGroupManagerProps(resolved),
    };
  }
}

/**
 * @schema ComputeInstanceGroupManager
 */
export interface ComputeInstanceGroupManagerProps {
  /**
   * @schema ComputeInstanceGroupManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeInstanceGroupManager#spec
   */
  readonly spec: ComputeInstanceGroupManagerSpec;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerProps(obj: ComputeInstanceGroupManagerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeInstanceGroupManagerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpec
 */
export interface ComputeInstanceGroupManagerSpec {
  /**
   * The autohealing policy for this managed instance group. You can specify only one value.
   *
   * @schema ComputeInstanceGroupManagerSpec#autoHealingPolicies
   */
  readonly autoHealingPolicies?: ComputeInstanceGroupManagerSpecAutoHealingPolicies[];

  /**
   * The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
   *
   * @schema ComputeInstanceGroupManagerSpec#baseInstanceName
   */
  readonly baseInstanceName?: string;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeInstanceGroupManagerSpec#description
   */
  readonly description?: string;

  /**
   * Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.
   *
   * @schema ComputeInstanceGroupManagerSpec#distributionPolicy
   */
  readonly distributionPolicy?: ComputeInstanceGroupManagerSpecDistributionPolicy;

  /**
   * The action to perform in case of zone failure. Only one value is supported, `NO_FAILOVER`. The default is `NO_FAILOVER`. Possible values: UNKNOWN, NO_FAILOVER
   *
   * @schema ComputeInstanceGroupManagerSpec#failoverAction
   */
  readonly failoverAction?: string;

  /**
   * @schema ComputeInstanceGroupManagerSpec#instanceTemplateRef
   */
  readonly instanceTemplateRef?: ComputeInstanceGroupManagerSpecInstanceTemplateRef;

  /**
   * Immutable. The location of this resource.
   *
   * @schema ComputeInstanceGroupManagerSpec#location
   */
  readonly location?: string;

  /**
   * Immutable. Named ports configured for the Instance Groups complementary to this Instance Group Manager.
   *
   * @schema ComputeInstanceGroupManagerSpec#namedPorts
   */
  readonly namedPorts?: ComputeInstanceGroupManagerSpecNamedPorts[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema ComputeInstanceGroupManagerSpec#projectRef
   */
  readonly projectRef: ComputeInstanceGroupManagerSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeInstanceGroupManagerSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeInstanceGroupManagerSpec#serviceAccountRef
   */
  readonly serviceAccountRef?: ComputeInstanceGroupManagerSpecServiceAccountRef;

  /**
   * Stateful configuration for this Instanced Group Manager
   *
   * @schema ComputeInstanceGroupManagerSpec#statefulPolicy
   */
  readonly statefulPolicy?: ComputeInstanceGroupManagerSpecStatefulPolicy;

  /**
   * @schema ComputeInstanceGroupManagerSpec#targetPools
   */
  readonly targetPools?: ComputeInstanceGroupManagerSpecTargetPools[];

  /**
   * The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.
   *
   * @schema ComputeInstanceGroupManagerSpec#targetSize
   */
  readonly targetSize: number;

  /**
   * The update policy for this managed instance group.
   *
   * @schema ComputeInstanceGroupManagerSpec#updatePolicy
   */
  readonly updatePolicy?: ComputeInstanceGroupManagerSpecUpdatePolicy;

  /**
   * Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an `instanceTemplate` and a `name`. Every version can appear at most once per instance group. This field overrides the top-level `instanceTemplate` field. Read more about the [relationships between these fields](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#relationship_between_versions_and_instancetemplate_properties_for_a_managed_instance_group). Exactly one `version` must leave the `targetSize` field unset. That version will be applied to all remaining instances. For more information, read about [canary updates](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update).
   *
   * @schema ComputeInstanceGroupManagerSpec#versions
   */
  readonly versions?: ComputeInstanceGroupManagerSpecVersions[];

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpec(obj: ComputeInstanceGroupManagerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoHealingPolicies': obj.autoHealingPolicies?.map(y => toJson_ComputeInstanceGroupManagerSpecAutoHealingPolicies(y)),
    'baseInstanceName': obj.baseInstanceName,
    'description': obj.description,
    'distributionPolicy': toJson_ComputeInstanceGroupManagerSpecDistributionPolicy(obj.distributionPolicy),
    'failoverAction': obj.failoverAction,
    'instanceTemplateRef': toJson_ComputeInstanceGroupManagerSpecInstanceTemplateRef(obj.instanceTemplateRef),
    'location': obj.location,
    'namedPorts': obj.namedPorts?.map(y => toJson_ComputeInstanceGroupManagerSpecNamedPorts(y)),
    'projectRef': toJson_ComputeInstanceGroupManagerSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'serviceAccountRef': toJson_ComputeInstanceGroupManagerSpecServiceAccountRef(obj.serviceAccountRef),
    'statefulPolicy': toJson_ComputeInstanceGroupManagerSpecStatefulPolicy(obj.statefulPolicy),
    'targetPools': obj.targetPools?.map(y => toJson_ComputeInstanceGroupManagerSpecTargetPools(y)),
    'targetSize': obj.targetSize,
    'updatePolicy': toJson_ComputeInstanceGroupManagerSpecUpdatePolicy(obj.updatePolicy),
    'versions': obj.versions?.map(y => toJson_ComputeInstanceGroupManagerSpecVersions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecAutoHealingPolicies
 */
export interface ComputeInstanceGroupManagerSpecAutoHealingPolicies {
  /**
   * @schema ComputeInstanceGroupManagerSpecAutoHealingPolicies#healthCheckRef
   */
  readonly healthCheckRef?: ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef;

  /**
   * The number of seconds that the managed instance group waits before it applies autohealing policies to new instances or recently recreated instances. This initial delay allows instances to initialize and run their startup scripts before the instance group determines that they are UNHEALTHY. This prevents the managed instance group from recreating its instances prematurely. This value must be from range [0, 3600].
   *
   * @schema ComputeInstanceGroupManagerSpecAutoHealingPolicies#initialDelaySec
   */
  readonly initialDelaySec?: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecAutoHealingPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecAutoHealingPolicies(obj: ComputeInstanceGroupManagerSpecAutoHealingPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckRef': toJson_ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef(obj.healthCheckRef),
    'initialDelaySec': obj.initialDelaySec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.
 *
 * @schema ComputeInstanceGroupManagerSpecDistributionPolicy
 */
export interface ComputeInstanceGroupManagerSpecDistributionPolicy {
  /**
   * The distribution shape to which the group converges either proactively or on resize events (depending on the value set in `updatePolicy.instanceRedistributionType`). Possible values: TARGET_SHAPE_UNSPECIFIED, ANY, BALANCED, ANY_SINGLE_ZONE
   *
   * @schema ComputeInstanceGroupManagerSpecDistributionPolicy#targetShape
   */
  readonly targetShape?: string;

  /**
   * Immutable. Zones where the regional managed instance group will create and manage its instances.
   *
   * @schema ComputeInstanceGroupManagerSpecDistributionPolicy#zones
   */
  readonly zones?: ComputeInstanceGroupManagerSpecDistributionPolicyZones[];

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecDistributionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecDistributionPolicy(obj: ComputeInstanceGroupManagerSpecDistributionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetShape': obj.targetShape,
    'zones': obj.zones?.map(y => toJson_ComputeInstanceGroupManagerSpecDistributionPolicyZones(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecInstanceTemplateRef
 */
export interface ComputeInstanceGroupManagerSpecInstanceTemplateRef {
  /**
   * The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run `recreateInstances`, run `applyUpdatesToInstances`, or set the group's `updatePolicy.type` to `PROACTIVE`.
   *
   * Allowed value: The `selfLink` field of a `ComputeInstanceTemplate` resource.
   *
   * @schema ComputeInstanceGroupManagerSpecInstanceTemplateRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecInstanceTemplateRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecInstanceTemplateRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecInstanceTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecInstanceTemplateRef(obj: ComputeInstanceGroupManagerSpecInstanceTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecNamedPorts
 */
export interface ComputeInstanceGroupManagerSpecNamedPorts {
  /**
   * Immutable. The name for this named port. The name must be 1-63 characters long, and comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
   *
   * @schema ComputeInstanceGroupManagerSpecNamedPorts#name
   */
  readonly name?: string;

  /**
   * Immutable. The port number, which can be a value between 1 and 65535.
   *
   * @schema ComputeInstanceGroupManagerSpecNamedPorts#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecNamedPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecNamedPorts(obj: ComputeInstanceGroupManagerSpecNamedPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema ComputeInstanceGroupManagerSpecProjectRef
 */
export interface ComputeInstanceGroupManagerSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema ComputeInstanceGroupManagerSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecProjectRef(obj: ComputeInstanceGroupManagerSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecServiceAccountRef
 */
export interface ComputeInstanceGroupManagerSpecServiceAccountRef {
  /**
   * The service account to be used as credentials for all operations performed by the managed instance group on instances. The service accounts needs all permissions required to create and delete instances. By default, the service account: {projectNumber}@cloudservices.gserviceaccount.com is used.
   *
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeInstanceGroupManagerSpecServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecServiceAccountRef(obj: ComputeInstanceGroupManagerSpecServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Stateful configuration for this Instanced Group Manager
 *
 * @schema ComputeInstanceGroupManagerSpecStatefulPolicy
 */
export interface ComputeInstanceGroupManagerSpecStatefulPolicy {
  /**
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicy#preservedState
   */
  readonly preservedState?: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecStatefulPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecStatefulPolicy(obj: ComputeInstanceGroupManagerSpecStatefulPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preservedState': toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState(obj.preservedState),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecTargetPools
 */
export interface ComputeInstanceGroupManagerSpecTargetPools {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetPool` resource.
   *
   * @schema ComputeInstanceGroupManagerSpecTargetPools#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecTargetPools#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecTargetPools#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecTargetPools' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecTargetPools(obj: ComputeInstanceGroupManagerSpecTargetPools | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The update policy for this managed instance group.
 *
 * @schema ComputeInstanceGroupManagerSpecUpdatePolicy
 */
export interface ComputeInstanceGroupManagerSpecUpdatePolicy {
  /**
   * The [instance redistribution policy](/compute/docs/instance-groups/regional-migs#proactive_instance_redistribution) for regional managed instance groups. Valid values are: - `PROACTIVE` (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - `NONE`: For non-autoscaled groups, proactive redistribution is disabled.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#instanceRedistributionType
   */
  readonly instanceRedistributionType?: string;

  /**
   * The maximum number of instances that can be created above the specified `targetSize` during the update process. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for `maxSurge` is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either `maxSurge` or `maxUnavailable` must be greater than 0. Learn more about [`maxSurge`](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#max_surge).
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#maxSurge
   */
  readonly maxSurge?: ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge;

  /**
   * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied: - The instance's [status](/compute/docs/instances/checking-instance-status) is `RUNNING`. - If there is a [health check](/compute/docs/instance-groups/autohealing-instances-in-migs) on the instance group, the instance's health check status must be `HEALTHY` at least once. If there is no health check on the group, then the instance only needs to have a status of `RUNNING` to be considered available. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for `maxUnavailable` is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either `maxSurge` or `maxUnavailable` must be greater than 0. Learn more about [`maxUnavailable`](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#max_unavailable).
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#maxUnavailable
   */
  readonly maxUnavailable?: ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable;

  /**
   * Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#minReadySec
   */
  readonly minReadySec?: number;

  /**
   * Minimal action to be taken on an instance. You can specify either `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `RESTART`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#minimalAction
   */
  readonly minimalAction?: string;

  /**
   * Most disruptive action that is allowed to be taken on an instance. You can specify either `NONE` to forbid any actions, `REFRESH` to allow actions that do not need instance restart, `RESTART` to allow actions that can be applied without instance replacing or `REPLACE` to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#mostDisruptiveAllowedAction
   */
  readonly mostDisruptiveAllowedAction?: string;

  /**
   * What action should be used to replace instances. See minimal_action.REPLACE Possible values: SUBSTITUTE, RECREATE
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#replacementMethod
   */
  readonly replacementMethod?: string;

  /**
   * The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or `recreateInstances` calls).
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecUpdatePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecUpdatePolicy(obj: ComputeInstanceGroupManagerSpecUpdatePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceRedistributionType': obj.instanceRedistributionType,
    'maxSurge': toJson_ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge(obj.maxSurge),
    'maxUnavailable': toJson_ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable(obj.maxUnavailable),
    'minReadySec': obj.minReadySec,
    'minimalAction': obj.minimalAction,
    'mostDisruptiveAllowedAction': obj.mostDisruptiveAllowedAction,
    'replacementMethod': obj.replacementMethod,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecVersions
 */
export interface ComputeInstanceGroupManagerSpecVersions {
  /**
   * @schema ComputeInstanceGroupManagerSpecVersions#instanceTemplateRef
   */
  readonly instanceTemplateRef?: ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef;

  /**
   * Name of the version. Unique among all versions in the scope of this managed instance group.
   *
   * @schema ComputeInstanceGroupManagerSpecVersions#name
   */
  readonly name?: string;

  /**
   * Specifies the intended number of instances to be created from the `instanceTemplate`. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either `targetSize.fixed` or `instanceGroupManager.targetSize` is used. - if expressed as a `percent`, the `targetSize` would be `(targetSize.percent/100 * InstanceGroupManager.targetSize)` If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another `version`. Read [Starting a canary update](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update) for more information.
   *
   * @schema ComputeInstanceGroupManagerSpecVersions#targetSize
   */
  readonly targetSize?: ComputeInstanceGroupManagerSpecVersionsTargetSize;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecVersions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecVersions(obj: ComputeInstanceGroupManagerSpecVersions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceTemplateRef': toJson_ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef(obj.instanceTemplateRef),
    'name': obj.name,
    'targetSize': toJson_ComputeInstanceGroupManagerSpecVersionsTargetSize(obj.targetSize),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef
 */
export interface ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef {
  /**
   * The URL for the health check that signals autohealing.
   *
   * Allowed value: The `selfLink` field of a `ComputeHealthCheck` resource.
   *
   * @schema ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef(obj: ComputeInstanceGroupManagerSpecAutoHealingPoliciesHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecDistributionPolicyZones
 */
export interface ComputeInstanceGroupManagerSpecDistributionPolicyZones {
  /**
   * Immutable. The URL of the [zone](/compute/docs/regions-zones/#available). The zone must exist in the region where the managed instance group is located.
   *
   * @schema ComputeInstanceGroupManagerSpecDistributionPolicyZones#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecDistributionPolicyZones' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecDistributionPolicyZones(obj: ComputeInstanceGroupManagerSpecDistributionPolicyZones | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState
 */
export interface ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState {
  /**
   * Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState#disks
   */
  readonly disks?: { [key: string]: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks };

  /**
   * External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState#externalIps
   */
  readonly externalIps?: { [key: string]: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps };

  /**
   * Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState#internalIps
   */
  readonly internalIps?: { [key: string]: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps };

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState(obj: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedState | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disks': ((obj.disks) === undefined) ? undefined : (Object.entries(obj.disks).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks(i[1]) }), {})),
    'externalIps': ((obj.externalIps) === undefined) ? undefined : (Object.entries(obj.externalIps).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps(i[1]) }), {})),
    'internalIps': ((obj.internalIps) === undefined) ? undefined : (Object.entries(obj.internalIps).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum number of instances that can be created above the specified `targetSize` during the update process. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for `maxSurge` is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either `maxSurge` or `maxUnavailable` must be greater than 0. Learn more about [`maxSurge`](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#max_surge).
 *
 * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge
 */
export interface ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge {
  /**
   * Specifies a fixed number of VM instances. This must be a positive integer.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge(obj: ComputeInstanceGroupManagerSpecUpdatePolicyMaxSurge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied: - The instance's [status](/compute/docs/instances/checking-instance-status) is `RUNNING`. - If there is a [health check](/compute/docs/instance-groups/autohealing-instances-in-migs) on the instance group, the instance's health check status must be `HEALTHY` at least once. If there is no health check on the group, then the instance only needs to have a status of `RUNNING` to be considered available. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for `maxUnavailable` is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either `maxSurge` or `maxUnavailable` must be greater than 0. Learn more about [`maxUnavailable`](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#max_unavailable).
 *
 * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable
 */
export interface ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable {
  /**
   * Specifies a fixed number of VM instances. This must be a positive integer.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.
   *
   * @schema ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable(obj: ComputeInstanceGroupManagerSpecUpdatePolicyMaxUnavailable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef
 */
export interface ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef {
  /**
   * The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run `recreateInstances`, run `applyUpdatesToInstances`, or set the group's `updatePolicy.type` to `PROACTIVE`; in those cases, existing instances are updated until the `targetSize` for this version is reached.
   *
   * Allowed value: The `selfLink` field of a `ComputeInstanceTemplate` resource.
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef(obj: ComputeInstanceGroupManagerSpecVersionsInstanceTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the intended number of instances to be created from the `instanceTemplate`. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either `targetSize.fixed` or `instanceGroupManager.targetSize` is used. - if expressed as a `percent`, the `targetSize` would be `(targetSize.percent/100 * InstanceGroupManager.targetSize)` If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another `version`. Read [Starting a canary update](/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#starting_a_canary_update) for more information.
 *
 * @schema ComputeInstanceGroupManagerSpecVersionsTargetSize
 */
export interface ComputeInstanceGroupManagerSpecVersionsTargetSize {
  /**
   * [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is `fixed`, then the `calculated` value is equal to the `fixed` value. - If the value is a `percent`, then the `calculated` value is `percent`/100 * `targetSize`. For example, the `calculated` value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsTargetSize#calculated
   */
  readonly calculated?: number;

  /**
   * Specifies a fixed number of VM instances. This must be a positive integer.
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsTargetSize#fixed
   */
  readonly fixed?: number;

  /**
   * Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify `80` for 80%.
   *
   * @schema ComputeInstanceGroupManagerSpecVersionsTargetSize#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecVersionsTargetSize' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecVersionsTargetSize(obj: ComputeInstanceGroupManagerSpecVersionsTargetSize | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'calculated': obj.calculated,
    'fixed': obj.fixed,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks
 */
export interface ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks {
  /**
   * These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted. Possible values: NEVER, ON_PERMANENT_INSTANCE_DELETION
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks#autoDelete
   */
  readonly autoDelete?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks(obj: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateDisks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDelete': obj.autoDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps
 */
export interface ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps {
  /**
   * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Possible values: NEVER, ON_PERMANENT_INSTANCE_DELETION
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps#autoDelete
   */
  readonly autoDelete?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps(obj: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateExternalIps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDelete': obj.autoDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps
 */
export interface ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps {
  /**
   * These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Possible values: NEVER, ON_PERMANENT_INSTANCE_DELETION
   *
   * @schema ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps#autoDelete
   */
  readonly autoDelete?: string;

}

/**
 * Converts an object of type 'ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps(obj: ComputeInstanceGroupManagerSpecStatefulPolicyPreservedStateInternalIps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDelete': obj.autoDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeInstanceTemplate
 */
export class ComputeInstanceTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeInstanceTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeInstanceTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeInstanceTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeInstanceTemplateProps): any {
    return {
      ...ComputeInstanceTemplate.GVK,
      ...toJson_ComputeInstanceTemplateProps(props),
    };
  }

  /**
   * Defines a "ComputeInstanceTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeInstanceTemplateProps) {
    super(scope, id, {
      ...ComputeInstanceTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeInstanceTemplate.GVK,
      ...toJson_ComputeInstanceTemplateProps(resolved),
    };
  }
}

/**
 * @schema ComputeInstanceTemplate
 */
export interface ComputeInstanceTemplateProps {
  /**
   * @schema ComputeInstanceTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeInstanceTemplate#spec
   */
  readonly spec: ComputeInstanceTemplateSpec;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateProps(obj: ComputeInstanceTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeInstanceTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpec
 */
export interface ComputeInstanceTemplateSpec {
  /**
   * Immutable. Controls for advanced machine-related behavior features.
   *
   * @schema ComputeInstanceTemplateSpec#advancedMachineFeatures
   */
  readonly advancedMachineFeatures?: ComputeInstanceTemplateSpecAdvancedMachineFeatures;

  /**
   * Immutable. Whether to allow sending and receiving of packets with non-matching source or destination IPs. This defaults to false.
   *
   * @schema ComputeInstanceTemplateSpec#canIpForward
   */
  readonly canIpForward?: boolean;

  /**
   * Immutable. The Confidential VM config being used by the instance. on_host_maintenance has to be set to TERMINATE or this will fail to create.
   *
   * @schema ComputeInstanceTemplateSpec#confidentialInstanceConfig
   */
  readonly confidentialInstanceConfig?: ComputeInstanceTemplateSpecConfidentialInstanceConfig;

  /**
   * Immutable. A brief description of this resource.
   *
   * @schema ComputeInstanceTemplateSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Disks to attach to instances created from this template. This can be specified multiple times for multiple disks.
   *
   * @schema ComputeInstanceTemplateSpec#disk
   */
  readonly disk: ComputeInstanceTemplateSpecDisk[];

  /**
   * Immutable. Enable Virtual Displays on this instance. Note: allow_stopping_for_update must be set to true in order to update this field.
   *
   * @schema ComputeInstanceTemplateSpec#enableDisplay
   */
  readonly enableDisplay?: boolean;

  /**
   * Immutable. List of the type and count of accelerator cards attached to the instance.
   *
   * @schema ComputeInstanceTemplateSpec#guestAccelerator
   */
  readonly guestAccelerator?: ComputeInstanceTemplateSpecGuestAccelerator[];

  /**
   * Immutable. A description of the instance.
   *
   * @schema ComputeInstanceTemplateSpec#instanceDescription
   */
  readonly instanceDescription?: string;

  /**
   * Immutable. The machine type to create. To create a machine with a custom type (such as extended memory), format the value like custom-VCPUS-MEM_IN_MB like custom-6-20480 for 6 vCPU and 20GB of RAM.
   *
   * @schema ComputeInstanceTemplateSpec#machineType
   */
  readonly machineType: string;

  /**
   * @schema ComputeInstanceTemplateSpec#metadata
   */
  readonly metadata?: ComputeInstanceTemplateSpecMetadata[];

  /**
   * Immutable. An alternative to using the startup-script metadata key, mostly to match the compute_instance resource. This replaces the startup-script metadata key on the created instance and thus the two mechanisms are not allowed to be used simultaneously.
   *
   * @schema ComputeInstanceTemplateSpec#metadataStartupScript
   */
  readonly metadataStartupScript?: string;

  /**
   * Immutable. Specifies a minimum CPU platform. Applicable values are the friendly names of CPU platforms, such as Intel Haswell or Intel Skylake.
   *
   * @schema ComputeInstanceTemplateSpec#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

  /**
   * Immutable. Creates a unique name beginning with the specified prefix. Conflicts with name.
   *
   * @schema ComputeInstanceTemplateSpec#namePrefix
   */
  readonly namePrefix?: string;

  /**
   * Immutable. Networks to attach to instances created from this template. This can be specified multiple times for multiple networks.
   *
   * @schema ComputeInstanceTemplateSpec#networkInterface
   */
  readonly networkInterface?: ComputeInstanceTemplateSpecNetworkInterface[];

  /**
   * Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.
   *
   * @schema ComputeInstanceTemplateSpec#networkPerformanceConfig
   */
  readonly networkPerformanceConfig?: ComputeInstanceTemplateSpecNetworkPerformanceConfig;

  /**
   * Immutable. An instance template is a global resource that is not bound to a zone or a region. However, you can still specify some regional resources in an instance template, which restricts the template to the region where that resource resides. For example, a custom subnetwork resource is tied to a specific region. Defaults to the region of the Provider if no value is given.
   *
   * @default the region of the Provider if no value is given.
   * @schema ComputeInstanceTemplateSpec#region
   */
  readonly region?: string;

  /**
   * Immutable. Specifies the reservations that this instance can consume from.
   *
   * @schema ComputeInstanceTemplateSpec#reservationAffinity
   */
  readonly reservationAffinity?: ComputeInstanceTemplateSpecReservationAffinity;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeInstanceTemplateSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeInstanceTemplateSpec#resourcePolicies
   */
  readonly resourcePolicies?: ComputeInstanceTemplateSpecResourcePolicies[];

  /**
   * Immutable. The scheduling strategy to use.
   *
   * @schema ComputeInstanceTemplateSpec#scheduling
   */
  readonly scheduling?: ComputeInstanceTemplateSpecScheduling;

  /**
   * Immutable. Service account to attach to the instance.
   *
   * @schema ComputeInstanceTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: ComputeInstanceTemplateSpecServiceAccount;

  /**
   * Immutable. Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Note: shielded_instance_config can only be used with boot images with shielded vm support.
   *
   * @default disabled. Note: shielded_instance_config can only be used with boot images with shielded vm support.
   * @schema ComputeInstanceTemplateSpec#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: ComputeInstanceTemplateSpecShieldedInstanceConfig;

  /**
   * Immutable. Tags to attach to the instance.
   *
   * @schema ComputeInstanceTemplateSpec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpec(obj: ComputeInstanceTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedMachineFeatures': toJson_ComputeInstanceTemplateSpecAdvancedMachineFeatures(obj.advancedMachineFeatures),
    'canIpForward': obj.canIpForward,
    'confidentialInstanceConfig': toJson_ComputeInstanceTemplateSpecConfidentialInstanceConfig(obj.confidentialInstanceConfig),
    'description': obj.description,
    'disk': obj.disk?.map(y => toJson_ComputeInstanceTemplateSpecDisk(y)),
    'enableDisplay': obj.enableDisplay,
    'guestAccelerator': obj.guestAccelerator?.map(y => toJson_ComputeInstanceTemplateSpecGuestAccelerator(y)),
    'instanceDescription': obj.instanceDescription,
    'machineType': obj.machineType,
    'metadata': obj.metadata?.map(y => toJson_ComputeInstanceTemplateSpecMetadata(y)),
    'metadataStartupScript': obj.metadataStartupScript,
    'minCpuPlatform': obj.minCpuPlatform,
    'namePrefix': obj.namePrefix,
    'networkInterface': obj.networkInterface?.map(y => toJson_ComputeInstanceTemplateSpecNetworkInterface(y)),
    'networkPerformanceConfig': toJson_ComputeInstanceTemplateSpecNetworkPerformanceConfig(obj.networkPerformanceConfig),
    'region': obj.region,
    'reservationAffinity': toJson_ComputeInstanceTemplateSpecReservationAffinity(obj.reservationAffinity),
    'resourceID': obj.resourceId,
    'resourcePolicies': obj.resourcePolicies?.map(y => toJson_ComputeInstanceTemplateSpecResourcePolicies(y)),
    'scheduling': toJson_ComputeInstanceTemplateSpecScheduling(obj.scheduling),
    'serviceAccount': toJson_ComputeInstanceTemplateSpecServiceAccount(obj.serviceAccount),
    'shieldedInstanceConfig': toJson_ComputeInstanceTemplateSpecShieldedInstanceConfig(obj.shieldedInstanceConfig),
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Controls for advanced machine-related behavior features.
 *
 * @schema ComputeInstanceTemplateSpecAdvancedMachineFeatures
 */
export interface ComputeInstanceTemplateSpecAdvancedMachineFeatures {
  /**
   * Immutable. Whether to enable nested virtualization or not.
   *
   * @schema ComputeInstanceTemplateSpecAdvancedMachineFeatures#enableNestedVirtualization
   */
  readonly enableNestedVirtualization?: boolean;

  /**
   * Immutable. The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
   *
   * @schema ComputeInstanceTemplateSpecAdvancedMachineFeatures#threadsPerCore
   */
  readonly threadsPerCore?: number;

  /**
   * Immutable. The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance\'s nominal CPU count and the underlying platform\'s SMT width.
   *
   * @schema ComputeInstanceTemplateSpecAdvancedMachineFeatures#visibleCoreCount
   */
  readonly visibleCoreCount?: number;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecAdvancedMachineFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecAdvancedMachineFeatures(obj: ComputeInstanceTemplateSpecAdvancedMachineFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableNestedVirtualization': obj.enableNestedVirtualization,
    'threadsPerCore': obj.threadsPerCore,
    'visibleCoreCount': obj.visibleCoreCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Confidential VM config being used by the instance. on_host_maintenance has to be set to TERMINATE or this will fail to create.
 *
 * @schema ComputeInstanceTemplateSpecConfidentialInstanceConfig
 */
export interface ComputeInstanceTemplateSpecConfidentialInstanceConfig {
  /**
   * Immutable. Defines whether the instance should have confidential compute enabled.
   *
   * @schema ComputeInstanceTemplateSpecConfidentialInstanceConfig#enableConfidentialCompute
   */
  readonly enableConfidentialCompute: boolean;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecConfidentialInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecConfidentialInstanceConfig(obj: ComputeInstanceTemplateSpecConfidentialInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableConfidentialCompute': obj.enableConfidentialCompute,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecDisk
 */
export interface ComputeInstanceTemplateSpecDisk {
  /**
   * Immutable. Whether or not the disk should be auto-deleted. This defaults to true.
   *
   * @schema ComputeInstanceTemplateSpecDisk#autoDelete
   */
  readonly autoDelete?: boolean;

  /**
   * Immutable. Indicates that this is a boot disk.
   *
   * @schema ComputeInstanceTemplateSpecDisk#boot
   */
  readonly boot?: boolean;

  /**
   * Immutable. A unique device name that is reflected into the /dev/ tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk.
   *
   * @schema ComputeInstanceTemplateSpecDisk#deviceName
   */
  readonly deviceName?: string;

  /**
   * Immutable. Encrypts or decrypts a disk using a customer-supplied encryption key.
   *
   * @schema ComputeInstanceTemplateSpecDisk#diskEncryptionKey
   */
  readonly diskEncryptionKey?: ComputeInstanceTemplateSpecDiskDiskEncryptionKey;

  /**
   * Immutable. Name of the disk. When not provided, this defaults to the name of the instance.
   *
   * @schema ComputeInstanceTemplateSpecDisk#diskName
   */
  readonly diskName?: string;

  /**
   * Immutable. The size of the image in gigabytes. If not specified, it will inherit the size of its base image. For SCRATCH disks, the size must be one of 375 or 3000 GB, with a default of 375 GB.
   *
   * @schema ComputeInstanceTemplateSpecDisk#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * Immutable. The Google Compute Engine disk type. Such as "pd-ssd", "local-ssd", "pd-balanced" or "pd-standard".
   *
   * @schema ComputeInstanceTemplateSpecDisk#diskType
   */
  readonly diskType?: string;

  /**
   * Immutable. Specifies the disk interface to use for attaching this disk.
   *
   * @schema ComputeInstanceTemplateSpecDisk#interface
   */
  readonly interface?: string;

  /**
   * Immutable. A set of key/value label pairs to assign to disks,.
   *
   * @schema ComputeInstanceTemplateSpecDisk#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Immutable. The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If you are attaching or creating a boot disk, this must read-write mode.
   *
   * @schema ComputeInstanceTemplateSpecDisk#mode
   */
  readonly mode?: string;

  /**
   * @schema ComputeInstanceTemplateSpecDisk#resourcePolicies
   */
  readonly resourcePolicies?: ComputeInstanceTemplateSpecDiskResourcePolicies[];

  /**
   * @schema ComputeInstanceTemplateSpecDisk#sourceDiskRef
   */
  readonly sourceDiskRef?: ComputeInstanceTemplateSpecDiskSourceDiskRef;

  /**
   * Immutable. The customer-supplied encryption key of the source
   * image. Required if the source image is protected by a
   * customer-supplied encryption key.
   *
   * Instance templates do not store customer-supplied
   * encryption keys, so you cannot create disks for
   * instances in a managed instance group if the source
   * images are encrypted with your own keys.
   *
   * @schema ComputeInstanceTemplateSpecDisk#sourceImageEncryptionKey
   */
  readonly sourceImageEncryptionKey?: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey;

  /**
   * @schema ComputeInstanceTemplateSpecDisk#sourceImageRef
   */
  readonly sourceImageRef?: ComputeInstanceTemplateSpecDiskSourceImageRef;

  /**
   * Immutable. The customer-supplied encryption key of the source snapshot.
   *
   * @schema ComputeInstanceTemplateSpecDisk#sourceSnapshotEncryptionKey
   */
  readonly sourceSnapshotEncryptionKey?: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey;

  /**
   * The source snapshot to create this disk. When creating a new
   * instance, one of initializeParams.sourceSnapshot,
   * initializeParams.sourceImage, or disks.source is required except for
   * local SSD.
   *
   * @schema ComputeInstanceTemplateSpecDisk#sourceSnapshotRef
   */
  readonly sourceSnapshotRef?: ComputeInstanceTemplateSpecDiskSourceSnapshotRef;

  /**
   * Immutable. The type of Google Compute Engine disk, can be either "SCRATCH" or "PERSISTENT".
   *
   * @schema ComputeInstanceTemplateSpecDisk#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDisk(obj: ComputeInstanceTemplateSpecDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDelete': obj.autoDelete,
    'boot': obj.boot,
    'deviceName': obj.deviceName,
    'diskEncryptionKey': toJson_ComputeInstanceTemplateSpecDiskDiskEncryptionKey(obj.diskEncryptionKey),
    'diskName': obj.diskName,
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'interface': obj.interface,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mode': obj.mode,
    'resourcePolicies': obj.resourcePolicies?.map(y => toJson_ComputeInstanceTemplateSpecDiskResourcePolicies(y)),
    'sourceDiskRef': toJson_ComputeInstanceTemplateSpecDiskSourceDiskRef(obj.sourceDiskRef),
    'sourceImageEncryptionKey': toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey(obj.sourceImageEncryptionKey),
    'sourceImageRef': toJson_ComputeInstanceTemplateSpecDiskSourceImageRef(obj.sourceImageRef),
    'sourceSnapshotEncryptionKey': toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey(obj.sourceSnapshotEncryptionKey),
    'sourceSnapshotRef': toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotRef(obj.sourceSnapshotRef),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecGuestAccelerator
 */
export interface ComputeInstanceTemplateSpecGuestAccelerator {
  /**
   * Immutable. The number of the guest accelerator cards exposed to this instance.
   *
   * @schema ComputeInstanceTemplateSpecGuestAccelerator#count
   */
  readonly count: number;

  /**
   * Immutable. The accelerator type resource to expose to this instance. E.g. nvidia-tesla-k80.
   *
   * @schema ComputeInstanceTemplateSpecGuestAccelerator#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecGuestAccelerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecGuestAccelerator(obj: ComputeInstanceTemplateSpecGuestAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecMetadata
 */
export interface ComputeInstanceTemplateSpecMetadata {
  /**
   * @schema ComputeInstanceTemplateSpecMetadata#key
   */
  readonly key: string;

  /**
   * @schema ComputeInstanceTemplateSpecMetadata#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecMetadata(obj: ComputeInstanceTemplateSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterface
 */
export interface ComputeInstanceTemplateSpecNetworkInterface {
  /**
   * @schema ComputeInstanceTemplateSpecNetworkInterface#accessConfig
   */
  readonly accessConfig?: ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig[];

  /**
   * Immutable. An array of alias IP ranges for this network interface. Can only be specified for network interfaces on subnet-mode networks.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#aliasIpRange
   */
  readonly aliasIpRange?: ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange[];

  /**
   * An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#ipv6AccessConfig
   */
  readonly ipv6AccessConfig?: ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig[];

  /**
   * One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * The name of the network_interface.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#name
   */
  readonly name?: string;

  /**
   * Immutable. The URL of the network attachment that this interface should connect to in the following format: projects/{projectNumber}/regions/{region_name}/networkAttachments/{network_attachment_name}.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#networkAttachment
   */
  readonly networkAttachment?: string;

  /**
   * Immutable. The private IP address to assign to the instance. If empty, the address will be automatically assigned.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#networkIp
   */
  readonly networkIp?: string;

  /**
   * @schema ComputeInstanceTemplateSpecNetworkInterface#networkRef
   */
  readonly networkRef?: ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef;

  /**
   * Immutable. The type of vNIC to be used on this interface. Possible values:GVNIC, VIRTIO_NET.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#nicType
   */
  readonly nicType?: string;

  /**
   * Immutable. The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#queueCount
   */
  readonly queueCount?: number;

  /**
   * The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#stackType
   */
  readonly stackType?: string;

  /**
   * Immutable. The ID of the project in which the subnetwork belongs. If it is not provided, the provider project is used.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterface#subnetworkProject
   */
  readonly subnetworkProject?: string;

  /**
   * @schema ComputeInstanceTemplateSpecNetworkInterface#subnetworkRef
   */
  readonly subnetworkRef?: ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterface' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterface(obj: ComputeInstanceTemplateSpecNetworkInterface | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessConfig': obj.accessConfig?.map(y => toJson_ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig(y)),
    'aliasIpRange': obj.aliasIpRange?.map(y => toJson_ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange(y)),
    'ipv6AccessConfig': obj.ipv6AccessConfig?.map(y => toJson_ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig(y)),
    'ipv6AccessType': obj.ipv6AccessType,
    'name': obj.name,
    'networkAttachment': obj.networkAttachment,
    'networkIp': obj.networkIp,
    'networkRef': toJson_ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef(obj.networkRef),
    'nicType': obj.nicType,
    'queueCount': obj.queueCount,
    'stackType': obj.stackType,
    'subnetworkProject': obj.subnetworkProject,
    'subnetworkRef': toJson_ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Configures network performance settings for the instance. If not specified, the instance will be created with its default network performance configuration.
 *
 * @schema ComputeInstanceTemplateSpecNetworkPerformanceConfig
 */
export interface ComputeInstanceTemplateSpecNetworkPerformanceConfig {
  /**
   * Immutable. The egress bandwidth tier to enable. Possible values:TIER_1, DEFAULT.
   *
   * @schema ComputeInstanceTemplateSpecNetworkPerformanceConfig#totalEgressBandwidthTier
   */
  readonly totalEgressBandwidthTier: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkPerformanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkPerformanceConfig(obj: ComputeInstanceTemplateSpecNetworkPerformanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'totalEgressBandwidthTier': obj.totalEgressBandwidthTier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the reservations that this instance can consume from.
 *
 * @schema ComputeInstanceTemplateSpecReservationAffinity
 */
export interface ComputeInstanceTemplateSpecReservationAffinity {
  /**
   * Immutable. Specifies the label selector for the reservation to use.
   *
   * @schema ComputeInstanceTemplateSpecReservationAffinity#specificReservation
   */
  readonly specificReservation?: ComputeInstanceTemplateSpecReservationAffinitySpecificReservation;

  /**
   * Immutable. The type of reservation from which this instance can consume resources.
   *
   * @schema ComputeInstanceTemplateSpecReservationAffinity#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecReservationAffinity(obj: ComputeInstanceTemplateSpecReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'specificReservation': toJson_ComputeInstanceTemplateSpecReservationAffinitySpecificReservation(obj.specificReservation),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecResourcePolicies
 */
export interface ComputeInstanceTemplateSpecResourcePolicies {
  /**
   * Allowed value: The `selfLink` field of a `ComputeResourcePolicy` resource.
   *
   * @schema ComputeInstanceTemplateSpecResourcePolicies#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecResourcePolicies#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecResourcePolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecResourcePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecResourcePolicies(obj: ComputeInstanceTemplateSpecResourcePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The scheduling strategy to use.
 *
 * @schema ComputeInstanceTemplateSpecScheduling
 */
export interface ComputeInstanceTemplateSpecScheduling {
  /**
   * Immutable. Specifies whether the instance should be automatically restarted if it is terminated by Compute Engine (not terminated by a user). This defaults to true.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#automaticRestart
   */
  readonly automaticRestart?: boolean;

  /**
   * Immutable. Specifies the action GCE should take when SPOT VM is preempted.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#instanceTerminationAction
   */
  readonly instanceTerminationAction?: string;

  /**
   * Specifies the frequency of planned maintenance events. The accepted values are: PERIODIC.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#maintenanceInterval
   */
  readonly maintenanceInterval?: string;

  /**
   * Immutable. The timeout for new network connections to hosts.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#maxRunDuration
   */
  readonly maxRunDuration?: ComputeInstanceTemplateSpecSchedulingMaxRunDuration;

  /**
   * Minimum number of cpus for the instance.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#minNodeCpus
   */
  readonly minNodeCpus?: number;

  /**
   * @schema ComputeInstanceTemplateSpecScheduling#nodeAffinities
   */
  readonly nodeAffinities?: ComputeInstanceTemplateSpecSchedulingNodeAffinities[];

  /**
   * Immutable. Defines the maintenance behavior for this instance.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#onHostMaintenance
   */
  readonly onHostMaintenance?: string;

  /**
   * Immutable. Allows instance to be preempted. This defaults to false.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#preemptible
   */
  readonly preemptible?: boolean;

  /**
   * Immutable. Whether the instance is spot. If this is set as SPOT.
   *
   * @schema ComputeInstanceTemplateSpecScheduling#provisioningModel
   */
  readonly provisioningModel?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecScheduling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecScheduling(obj: ComputeInstanceTemplateSpecScheduling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automaticRestart': obj.automaticRestart,
    'instanceTerminationAction': obj.instanceTerminationAction,
    'maintenanceInterval': obj.maintenanceInterval,
    'maxRunDuration': toJson_ComputeInstanceTemplateSpecSchedulingMaxRunDuration(obj.maxRunDuration),
    'minNodeCpus': obj.minNodeCpus,
    'nodeAffinities': obj.nodeAffinities?.map(y => toJson_ComputeInstanceTemplateSpecSchedulingNodeAffinities(y)),
    'onHostMaintenance': obj.onHostMaintenance,
    'preemptible': obj.preemptible,
    'provisioningModel': obj.provisioningModel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Service account to attach to the instance.
 *
 * @schema ComputeInstanceTemplateSpecServiceAccount
 */
export interface ComputeInstanceTemplateSpecServiceAccount {
  /**
   * Immutable. A list of service scopes. Both OAuth2 URLs and gcloud short names are supported. To allow full access to all Cloud APIs, use the cloud-platform scope.
   *
   * @schema ComputeInstanceTemplateSpecServiceAccount#scopes
   */
  readonly scopes: string[];

  /**
   * @schema ComputeInstanceTemplateSpecServiceAccount#serviceAccountRef
   */
  readonly serviceAccountRef?: ComputeInstanceTemplateSpecServiceAccountServiceAccountRef;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecServiceAccount(obj: ComputeInstanceTemplateSpecServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scopes': obj.scopes?.map(y => y),
    'serviceAccountRef': toJson_ComputeInstanceTemplateSpecServiceAccountServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Enable Shielded VM on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Note: shielded_instance_config can only be used with boot images with shielded vm support.
 *
 * @default disabled. Note: shielded_instance_config can only be used with boot images with shielded vm support.
 * @schema ComputeInstanceTemplateSpecShieldedInstanceConfig
 */
export interface ComputeInstanceTemplateSpecShieldedInstanceConfig {
  /**
   * Immutable. Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.
   *
   * @default true.
   * @schema ComputeInstanceTemplateSpecShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Immutable. Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.
   *
   * @default false.
   * @schema ComputeInstanceTemplateSpecShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;

  /**
   * Immutable. Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.
   *
   * @default true.
   * @schema ComputeInstanceTemplateSpecShieldedInstanceConfig#enableVtpm
   */
  readonly enableVtpm?: boolean;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecShieldedInstanceConfig(obj: ComputeInstanceTemplateSpecShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
    'enableVtpm': obj.enableVtpm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Encrypts or decrypts a disk using a customer-supplied encryption key.
 *
 * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKey
 */
export interface ComputeInstanceTemplateSpecDiskDiskEncryptionKey {
  /**
   * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKey#kmsKeyRef
   */
  readonly kmsKeyRef: ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskDiskEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskDiskEncryptionKey(obj: ComputeInstanceTemplateSpecDiskDiskEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyRef': toJson_ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef(obj.kmsKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecDiskResourcePolicies
 */
export interface ComputeInstanceTemplateSpecDiskResourcePolicies {
  /**
   * Allowed value: The `selfLink` field of a `ComputeResourcePolicy` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskResourcePolicies#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskResourcePolicies#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskResourcePolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskResourcePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskResourcePolicies(obj: ComputeInstanceTemplateSpecDiskResourcePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecDiskSourceDiskRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceDiskRef {
  /**
   * Allowed value: The `name` field of a `ComputeDisk` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceDiskRef(obj: ComputeInstanceTemplateSpecDiskSourceDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The customer-supplied encryption key of the source
 * image. Required if the source image is protected by a
 * customer-supplied encryption key.
 *
 * Instance templates do not store customer-supplied
 * encryption keys, so you cannot create disks for
 * instances in a managed instance group if the source
 * images are encrypted with your own keys.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey
 */
export interface ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey {
  /**
   * The self link of the encryption key that is stored in Google Cloud
   * KMS.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey#kmsKeySelfLinkRef
   */
  readonly kmsKeySelfLinkRef: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef;

  /**
   * The service account being used for the encryption request for the
   * given KMS key. If absent, the Compute Engine default service account
   * is used.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey(obj: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeySelfLinkRef': toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef(obj.kmsKeySelfLinkRef),
    'kmsKeyServiceAccountRef': toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecDiskSourceImageRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceImageRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeImage` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceImageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceImageRef(obj: ComputeInstanceTemplateSpecDiskSourceImageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The customer-supplied encryption key of the source snapshot.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey
 */
export interface ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey {
  /**
   * The self link of the encryption key that is stored in Google Cloud
   * KMS.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey#kmsKeySelfLinkRef
   */
  readonly kmsKeySelfLinkRef: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef;

  /**
   * The service account being used for the encryption request for the
   * given KMS key. If absent, the Compute Engine default service account
   * is used.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey(obj: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeySelfLinkRef': toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef(obj.kmsKeySelfLinkRef),
    'kmsKeyServiceAccountRef': toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source snapshot to create this disk. When creating a new
 * instance, one of initializeParams.sourceSnapshot,
 * initializeParams.sourceImage, or disks.source is required except for
 * local SSD.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceSnapshotRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSnapshot` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceSnapshotRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotRef(obj: ComputeInstanceTemplateSpecDiskSourceSnapshotRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig {
  /**
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig#natIpRef
   */
  readonly natIpRef?: ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef;

  /**
   * Immutable. The networking tier used for configuring this instance template. This field can take the following values: PREMIUM, STANDARD, FIXED_STANDARD. If this field is not specified, it is assumed to be PREMIUM.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig#networkTier
   */
  readonly networkTier?: string;

  /**
   * The DNS domain name for the public PTR record.The DNS domain name for the public PTR record.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig#publicPtrDomainName
   */
  readonly publicPtrDomainName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig(obj: ComputeInstanceTemplateSpecNetworkInterfaceAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'natIpRef': toJson_ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef(obj.natIpRef),
    'networkTier': obj.networkTier,
    'publicPtrDomainName': obj.publicPtrDomainName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange {
  /**
   * Immutable. The IP CIDR range represented by this alias IP range. This IP CIDR range must belong to the specified subnetwork and cannot contain IP addresses reserved by system or used by other network interfaces. At the time of writing only a netmask (e.g. /24) may be supplied, with a CIDR format resulting in an API error.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange#ipCidrRange
   */
  readonly ipCidrRange: string;

  /**
   * Immutable. The subnetwork secondary range name specifying the secondary range from which to allocate the IP CIDR range for this alias IP range. If left unspecified, the primary range of the subnetwork will be used.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange#subnetworkRangeName
   */
  readonly subnetworkRangeName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange(obj: ComputeInstanceTemplateSpecNetworkInterfaceAliasIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'subnetworkRangeName': obj.subnetworkRangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig {
  /**
   * The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. The field is output only, an IPv6 address from a subnetwork associated with the instance will be allocated dynamically.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig#externalIpv6
   */
  readonly externalIpv6?: string;

  /**
   * The prefix length of the external IPv6 range.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig#externalIpv6PrefixLength
   */
  readonly externalIpv6PrefixLength?: string;

  /**
   * The service-level to be provided for IPv6 traffic when the subnet has an external subnet. Only PREMIUM tier is valid for IPv6.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig#networkTier
   */
  readonly networkTier: string;

  /**
   * The domain name to be used when creating DNSv6 records for the external IPv6 ranges.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig#publicPtrDomainName
   */
  readonly publicPtrDomainName?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig(obj: ComputeInstanceTemplateSpecNetworkInterfaceIpv6AccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalIpv6': obj.externalIpv6,
    'externalIpv6PrefixLength': obj.externalIpv6PrefixLength,
    'networkTier': obj.networkTier,
    'publicPtrDomainName': obj.publicPtrDomainName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef(obj: ComputeInstanceTemplateSpecNetworkInterfaceNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef(obj: ComputeInstanceTemplateSpecNetworkInterfaceSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the label selector for the reservation to use.
 *
 * @schema ComputeInstanceTemplateSpecReservationAffinitySpecificReservation
 */
export interface ComputeInstanceTemplateSpecReservationAffinitySpecificReservation {
  /**
   * Immutable. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.
   *
   * @schema ComputeInstanceTemplateSpecReservationAffinitySpecificReservation#key
   */
  readonly key: string;

  /**
   * Immutable. Corresponds to the label values of a reservation resource.
   *
   * @schema ComputeInstanceTemplateSpecReservationAffinitySpecificReservation#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecReservationAffinitySpecificReservation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecReservationAffinitySpecificReservation(obj: ComputeInstanceTemplateSpecReservationAffinitySpecificReservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The timeout for new network connections to hosts.
 *
 * @schema ComputeInstanceTemplateSpecSchedulingMaxRunDuration
 */
export interface ComputeInstanceTemplateSpecSchedulingMaxRunDuration {
  /**
   * Immutable. Span of time that's a fraction of a second at nanosecond
   * resolution. Durations less than one second are represented
   * with a 0 seconds field and a positive nanos field. Must
   * be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeInstanceTemplateSpecSchedulingMaxRunDuration#nanos
   */
  readonly nanos?: number;

  /**
   * Immutable. Span of time at a resolution of a second.
   * Must be from 0 to 315,576,000,000 inclusive.
   *
   * @schema ComputeInstanceTemplateSpecSchedulingMaxRunDuration#seconds
   */
  readonly seconds: number;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecSchedulingMaxRunDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecSchedulingMaxRunDuration(obj: ComputeInstanceTemplateSpecSchedulingMaxRunDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecSchedulingNodeAffinities
 */
export interface ComputeInstanceTemplateSpecSchedulingNodeAffinities {
  /**
   * @schema ComputeInstanceTemplateSpecSchedulingNodeAffinities#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecSchedulingNodeAffinities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecSchedulingNodeAffinities(obj: ComputeInstanceTemplateSpecSchedulingNodeAffinities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecServiceAccountServiceAccountRef
 */
export interface ComputeInstanceTemplateSpecServiceAccountServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeInstanceTemplateSpecServiceAccountServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecServiceAccountServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecServiceAccountServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecServiceAccountServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecServiceAccountServiceAccountRef(obj: ComputeInstanceTemplateSpecServiceAccountServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef
 */
export interface ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef(obj: ComputeInstanceTemplateSpecDiskDiskEncryptionKeyKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The self link of the encryption key that is stored in Google Cloud
 * KMS.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef(obj: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeySelfLinkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account being used for the encryption request for the
 * given KMS key. If absent, the Compute Engine default service account
 * is used.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeInstanceTemplateSpecDiskSourceImageEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The self link of the encryption key that is stored in Google Cloud
 * KMS.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef(obj: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeySelfLinkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account being used for the encryption request for the
 * given KMS key. If absent, the Compute Engine default service account
 * is used.
 *
 * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeInstanceTemplateSpecDiskSourceSnapshotEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef
 */
export interface ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef(obj: ComputeInstanceTemplateSpecNetworkInterfaceAccessConfigNatIpRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeInterconnectAttachment
 */
export class ComputeInterconnectAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeInterconnectAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeInterconnectAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeInterconnectAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeInterconnectAttachmentProps): any {
    return {
      ...ComputeInterconnectAttachment.GVK,
      ...toJson_ComputeInterconnectAttachmentProps(props),
    };
  }

  /**
   * Defines a "ComputeInterconnectAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeInterconnectAttachmentProps) {
    super(scope, id, {
      ...ComputeInterconnectAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeInterconnectAttachment.GVK,
      ...toJson_ComputeInterconnectAttachmentProps(resolved),
    };
  }
}

/**
 * @schema ComputeInterconnectAttachment
 */
export interface ComputeInterconnectAttachmentProps {
  /**
   * @schema ComputeInterconnectAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeInterconnectAttachment#spec
   */
  readonly spec: ComputeInterconnectAttachmentSpec;

}

/**
 * Converts an object of type 'ComputeInterconnectAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInterconnectAttachmentProps(obj: ComputeInterconnectAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeInterconnectAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeInterconnectAttachmentSpec
 */
export interface ComputeInterconnectAttachmentSpec {
  /**
   * Whether the VLAN attachment is enabled or disabled.  When using
   * PARTNER type this will Pre-Activate the interconnect attachment.
   *
   * @schema ComputeInterconnectAttachmentSpec#adminEnabled
   */
  readonly adminEnabled?: boolean;

  /**
   * Provisioned bandwidth capacity for the interconnect attachment.
   * For attachments of type DEDICATED, the user can set the bandwidth.
   * For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth.
   * Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED,
   * Defaults to BPS_10G Possible values: ["BPS_50M", "BPS_100M", "BPS_200M", "BPS_300M", "BPS_400M", "BPS_500M", "BPS_1G", "BPS_2G", "BPS_5G", "BPS_10G", "BPS_20G", "BPS_50G"].
   *
   * @default BPS_10G Possible values: ["BPS_50M", "BPS_100M", "BPS_200M", "BPS_300M", "BPS_400M", "BPS_500M", "BPS_1G", "BPS_2G", "BPS_5G", "BPS_10G", "BPS_20G", "BPS_50G"].
   * @schema ComputeInterconnectAttachmentSpec#bandwidth
   */
  readonly bandwidth?: string;

  /**
   * Immutable. Up to 16 candidate prefixes that can be used to restrict the allocation
   * of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
   * All prefixes must be within link-local address space (169.254.0.0/16)
   * and must be /29 or shorter (/28, /27, etc). Google will attempt to select
   * an unused /29 from the supplied candidate prefix(es). The request will
   * fail if all possible /29s are in use on Google's edge. If not supplied,
   * Google will randomly select an unused /29 from all of link-local space.
   *
   * @schema ComputeInterconnectAttachmentSpec#candidateSubnets
   */
  readonly candidateSubnets?: string[];

  /**
   * An optional description of this resource.
   *
   * @schema ComputeInterconnectAttachmentSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Desired availability domain for the attachment. Only available for type
   * PARTNER, at creation time. For improved reliability, customers should
   * configure a pair of attachments with one per availability domain. The
   * selected availability domain will be provided to the Partner via the
   * pairing key so that the provisioned circuit will lie in the specified
   * domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
   *
   * @schema ComputeInterconnectAttachmentSpec#edgeAvailabilityDomain
   */
  readonly edgeAvailabilityDomain?: string;

  /**
   * Immutable. Indicates the user-supplied encryption option of this interconnect
   * attachment. Can only be specified at attachment creation for PARTNER or
   * DEDICATED attachments.
   *
   * * NONE - This is the default value, which means that the VLAN attachment
   * carries unencrypted traffic. VMs are able to send traffic to, or receive
   * traffic from, such a VLAN attachment.
   *
   * * IPSEC - The VLAN attachment carries only encrypted traffic that is
   * encrypted by an IPsec device, such as an HA VPN gateway or third-party
   * IPsec VPN. VMs cannot directly send traffic to, or receive traffic from,
   * such a VLAN attachment. To use HA VPN over Cloud Interconnect, the VLAN
   * attachment must be created with this option. Default value: "NONE" Possible values: ["NONE", "IPSEC"].
   *
   * @schema ComputeInterconnectAttachmentSpec#encryption
   */
  readonly encryption?: string;

  /**
   * Immutable. URL of the underlying Interconnect object that this attachment's
   * traffic will traverse through. Required if type is DEDICATED, must not
   * be set if type is PARTNER.
   *
   * @schema ComputeInterconnectAttachmentSpec#interconnect
   */
  readonly interconnect?: string;

  /**
   * @schema ComputeInterconnectAttachmentSpec#ipsecInternalAddresses
   */
  readonly ipsecInternalAddresses?: ComputeInterconnectAttachmentSpecIpsecInternalAddresses[];

  /**
   * Maximum Transmission Unit (MTU), in bytes, of packets passing through
   * this interconnect attachment. Currently, only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
   *
   * @schema ComputeInterconnectAttachmentSpec#mtu
   */
  readonly mtu?: string;

  /**
   * Region where the regional interconnect attachment resides.
   *
   * @schema ComputeInterconnectAttachmentSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeInterconnectAttachmentSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The Cloud Router to be used for dynamic routing. This router must
   * be in the same region as this ComputeInterconnectAttachment. The
   * ComputeInterconnectAttachment will automatically connect the
   * interconnect to the network & region within which the Cloud Router
   * is configured.
   *
   * @schema ComputeInterconnectAttachmentSpec#routerRef
   */
  readonly routerRef: ComputeInterconnectAttachmentSpecRouterRef;

  /**
   * Immutable. The type of InterconnectAttachment you wish to create. Defaults to
   * DEDICATED. Possible values: ["DEDICATED", "PARTNER", "PARTNER_PROVIDER"].
   *
   * @default DEDICATED. Possible values: ["DEDICATED", "PARTNER", "PARTNER_PROVIDER"].
   * @schema ComputeInterconnectAttachmentSpec#type
   */
  readonly type?: string;

  /**
   * Immutable. The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When
   * using PARTNER type this will be managed upstream.
   *
   * @schema ComputeInterconnectAttachmentSpec#vlanTag8021q
   */
  readonly vlanTag8021Q?: number;

}

/**
 * Converts an object of type 'ComputeInterconnectAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInterconnectAttachmentSpec(obj: ComputeInterconnectAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminEnabled': obj.adminEnabled,
    'bandwidth': obj.bandwidth,
    'candidateSubnets': obj.candidateSubnets?.map(y => y),
    'description': obj.description,
    'edgeAvailabilityDomain': obj.edgeAvailabilityDomain,
    'encryption': obj.encryption,
    'interconnect': obj.interconnect,
    'ipsecInternalAddresses': obj.ipsecInternalAddresses?.map(y => toJson_ComputeInterconnectAttachmentSpecIpsecInternalAddresses(y)),
    'mtu': obj.mtu,
    'region': obj.region,
    'resourceID': obj.resourceId,
    'routerRef': toJson_ComputeInterconnectAttachmentSpecRouterRef(obj.routerRef),
    'type': obj.type,
    'vlanTag8021q': obj.vlanTag8021Q,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The addresses that have been reserved for the
 * interconnect attachment. Used only for interconnect attachment that
 * has the encryption option as IPSEC.
 *
 * The addresses must be RFC 1918 IP address ranges. When creating HA
 * VPN gateway over the interconnect attachment, if the attachment is
 * configured to use an RFC 1918 IP address, then the VPN gateway's IP
 * address will be allocated from the IP address range specified
 * here.
 *
 * For example, if the HA VPN gateway's interface 0 is paired to this
 * interconnect attachment, then an RFC 1918 IP address for the VPN
 * gateway interface 0 will be allocated from the IP address specified
 * for this interconnect attachment.
 *
 * If this field is not specified for interconnect attachment that has
 * encryption option as IPSEC, later on when creating HA VPN gateway on
 * this interconnect attachment, the HA VPN gateway's IP address will
 * be allocated from regional external IP address pool.
 *
 * @schema ComputeInterconnectAttachmentSpecIpsecInternalAddresses
 */
export interface ComputeInterconnectAttachmentSpecIpsecInternalAddresses {
  /**
   * Allowed value: The `selfLink` field of a `ComputeAddress` resource.
   *
   * @schema ComputeInterconnectAttachmentSpecIpsecInternalAddresses#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInterconnectAttachmentSpecIpsecInternalAddresses#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInterconnectAttachmentSpecIpsecInternalAddresses#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInterconnectAttachmentSpecIpsecInternalAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInterconnectAttachmentSpecIpsecInternalAddresses(obj: ComputeInterconnectAttachmentSpecIpsecInternalAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Cloud Router to be used for dynamic routing. This router must
 * be in the same region as this ComputeInterconnectAttachment. The
 * ComputeInterconnectAttachment will automatically connect the
 * interconnect to the network & region within which the Cloud Router
 * is configured.
 *
 * @schema ComputeInterconnectAttachmentSpecRouterRef
 */
export interface ComputeInterconnectAttachmentSpecRouterRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeRouter` resource.
   *
   * @schema ComputeInterconnectAttachmentSpecRouterRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeInterconnectAttachmentSpecRouterRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeInterconnectAttachmentSpecRouterRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeInterconnectAttachmentSpecRouterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeInterconnectAttachmentSpecRouterRef(obj: ComputeInterconnectAttachmentSpecRouterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeNetwork
 */
export class ComputeNetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeNetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeNetwork',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeNetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeNetworkProps = {}): any {
    return {
      ...ComputeNetwork.GVK,
      ...toJson_ComputeNetworkProps(props),
    };
  }

  /**
   * Defines a "ComputeNetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeNetworkProps = {}) {
    super(scope, id, {
      ...ComputeNetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeNetwork.GVK,
      ...toJson_ComputeNetworkProps(resolved),
    };
  }
}

/**
 * @schema ComputeNetwork
 */
export interface ComputeNetworkProps {
  /**
   * @schema ComputeNetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeNetwork#spec
   */
  readonly spec?: ComputeNetworkSpec;

}

/**
 * Converts an object of type 'ComputeNetworkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkProps(obj: ComputeNetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeNetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNetworkSpec
 */
export interface ComputeNetworkSpec {
  /**
   * Immutable. When set to 'true', the network is created in "auto subnet mode" and
   * it will create a subnet for each region automatically across the
   * '10.128.0.0/9' address range.
   *
   * When set to 'false', the network is created in "custom subnet mode" so
   * the user can explicitly connect subnetwork resources.
   *
   * @schema ComputeNetworkSpec#autoCreateSubnetworks
   */
  readonly autoCreateSubnetworks?: boolean;

  /**
   * If set to 'true', default routes ('0.0.0.0/0') will be deleted
   * immediately after network creation. Defaults to 'false'.
   *
   * @default false'.
   * @schema ComputeNetworkSpec#deleteDefaultRoutesOnCreate
   */
  readonly deleteDefaultRoutesOnCreate?: boolean;

  /**
   * Immutable. An optional description of this resource. The resource must be
   * recreated to modify this field.
   *
   * @schema ComputeNetworkSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Enable ULA internal ipv6 on this network. Enabling this feature will assign
   * a /48 from google defined ULA prefix fd20::/20.
   *
   * @schema ComputeNetworkSpec#enableUlaInternalIpv6
   */
  readonly enableUlaInternalIpv6?: boolean;

  /**
   * Immutable. When enabling ula internal ipv6, caller optionally can specify the /48 range
   * they want from the google defined ULA prefix fd20::/20. The input must be a
   * valid /48 ULA IPv6 address and must be within the fd20::/20. Operation will
   * fail if the speficied /48 is already in used by another resource.
   * If the field is not speficied, then a /48 range will be randomly allocated from fd20::/20 and returned via this field.
   *
   * @schema ComputeNetworkSpec#internalIpv6Range
   */
  readonly internalIpv6Range?: string;

  /**
   * Immutable. Maximum Transmission Unit in bytes. The default value is 1460 bytes.
   * The minimum value for this field is 1300 and the maximum value is 8896 bytes (jumbo frames).
   * Note that packets larger than 1500 bytes (standard Ethernet) can be subject to TCP-MSS clamping or dropped
   * with an ICMP 'Fragmentation-Needed' message if the packets are routed to the Internet or other VPCs
   * with varying MTUs.
   *
   * @schema ComputeNetworkSpec#mtu
   */
  readonly mtu?: number;

  /**
   * Set the order that Firewall Rules and Firewall Policies are evaluated. Default value: "AFTER_CLASSIC_FIREWALL" Possible values: ["BEFORE_CLASSIC_FIREWALL", "AFTER_CLASSIC_FIREWALL"].
   *
   * @schema ComputeNetworkSpec#networkFirewallPolicyEnforcementOrder
   */
  readonly networkFirewallPolicyEnforcementOrder?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeNetworkSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The network-wide routing mode to use. If set to 'REGIONAL', this
   * network's cloud routers will only advertise routes with subnetworks
   * of this network in the same region as the router. If set to 'GLOBAL',
   * this network's cloud routers will advertise routes with all
   * subnetworks of this network, across regions. Possible values: ["REGIONAL", "GLOBAL"].
   *
   * @schema ComputeNetworkSpec#routingMode
   */
  readonly routingMode?: string;

}

/**
 * Converts an object of type 'ComputeNetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkSpec(obj: ComputeNetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoCreateSubnetworks': obj.autoCreateSubnetworks,
    'deleteDefaultRoutesOnCreate': obj.deleteDefaultRoutesOnCreate,
    'description': obj.description,
    'enableUlaInternalIpv6': obj.enableUlaInternalIpv6,
    'internalIpv6Range': obj.internalIpv6Range,
    'mtu': obj.mtu,
    'networkFirewallPolicyEnforcementOrder': obj.networkFirewallPolicyEnforcementOrder,
    'resourceID': obj.resourceId,
    'routingMode': obj.routingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeNetworkEndpointGroup
 */
export class ComputeNetworkEndpointGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeNetworkEndpointGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeNetworkEndpointGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeNetworkEndpointGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeNetworkEndpointGroupProps): any {
    return {
      ...ComputeNetworkEndpointGroup.GVK,
      ...toJson_ComputeNetworkEndpointGroupProps(props),
    };
  }

  /**
   * Defines a "ComputeNetworkEndpointGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeNetworkEndpointGroupProps) {
    super(scope, id, {
      ...ComputeNetworkEndpointGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeNetworkEndpointGroup.GVK,
      ...toJson_ComputeNetworkEndpointGroupProps(resolved),
    };
  }
}

/**
 * @schema ComputeNetworkEndpointGroup
 */
export interface ComputeNetworkEndpointGroupProps {
  /**
   * @schema ComputeNetworkEndpointGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeNetworkEndpointGroup#spec
   */
  readonly spec: ComputeNetworkEndpointGroupSpec;

}

/**
 * Converts an object of type 'ComputeNetworkEndpointGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkEndpointGroupProps(obj: ComputeNetworkEndpointGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeNetworkEndpointGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNetworkEndpointGroupSpec
 */
export interface ComputeNetworkEndpointGroupSpec {
  /**
   * Immutable. The default port used if the port number is not specified in the
   * network endpoint.
   *
   * @schema ComputeNetworkEndpointGroupSpec#defaultPort
   */
  readonly defaultPort?: number;

  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeNetworkEndpointGroupSpec#description
   */
  readonly description?: string;

  /**
   * Location represents the geographical location of the ComputeNetworkEndpointGroup. Specify a zone name. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeNetworkEndpointGroupSpec#location
   */
  readonly location: string;

  /**
   * Immutable. Type of network endpoints in this network endpoint group.
   * NON_GCP_PRIVATE_IP_PORT is used for hybrid connectivity network
   * endpoint groups (see https://cloud.google.com/load-balancing/docs/hybrid).
   * Note that NON_GCP_PRIVATE_IP_PORT can only be used with Backend Services
   * that 1) have the following load balancing schemes: EXTERNAL, EXTERNAL_MANAGED,
   * INTERNAL_MANAGED, and INTERNAL_SELF_MANAGED and 2) support the RATE or
   * CONNECTION balancing modes.
   *
   * Possible values include: GCE_VM_IP, GCE_VM_IP_PORT, and NON_GCP_PRIVATE_IP_PORT. Default value: "GCE_VM_IP_PORT" Possible values: ["GCE_VM_IP", "GCE_VM_IP_PORT", "NON_GCP_PRIVATE_IP_PORT"].
   *
   * @schema ComputeNetworkEndpointGroupSpec#networkEndpointType
   */
  readonly networkEndpointType?: string;

  /**
   * The network to which all network endpoints in the NEG belong. Uses
   * "default" project network if unspecified.
   *
   * @schema ComputeNetworkEndpointGroupSpec#networkRef
   */
  readonly networkRef: ComputeNetworkEndpointGroupSpecNetworkRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeNetworkEndpointGroupSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Optional subnetwork to which all network endpoints in the NEG belong.
   *
   * @schema ComputeNetworkEndpointGroupSpec#subnetworkRef
   */
  readonly subnetworkRef?: ComputeNetworkEndpointGroupSpecSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeNetworkEndpointGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkEndpointGroupSpec(obj: ComputeNetworkEndpointGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultPort': obj.defaultPort,
    'description': obj.description,
    'location': obj.location,
    'networkEndpointType': obj.networkEndpointType,
    'networkRef': toJson_ComputeNetworkEndpointGroupSpecNetworkRef(obj.networkRef),
    'resourceID': obj.resourceId,
    'subnetworkRef': toJson_ComputeNetworkEndpointGroupSpecSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network to which all network endpoints in the NEG belong. Uses
 * "default" project network if unspecified.
 *
 * @schema ComputeNetworkEndpointGroupSpecNetworkRef
 */
export interface ComputeNetworkEndpointGroupSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeNetworkEndpointGroupSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNetworkEndpointGroupSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNetworkEndpointGroupSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNetworkEndpointGroupSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkEndpointGroupSpecNetworkRef(obj: ComputeNetworkEndpointGroupSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional subnetwork to which all network endpoints in the NEG belong.
 *
 * @schema ComputeNetworkEndpointGroupSpecSubnetworkRef
 */
export interface ComputeNetworkEndpointGroupSpecSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeNetworkEndpointGroupSpecSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNetworkEndpointGroupSpecSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNetworkEndpointGroupSpecSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNetworkEndpointGroupSpecSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkEndpointGroupSpecSubnetworkRef(obj: ComputeNetworkEndpointGroupSpecSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeNetworkPeering
 */
export class ComputeNetworkPeering extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeNetworkPeering"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeNetworkPeering',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeNetworkPeering".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeNetworkPeeringProps): any {
    return {
      ...ComputeNetworkPeering.GVK,
      ...toJson_ComputeNetworkPeeringProps(props),
    };
  }

  /**
   * Defines a "ComputeNetworkPeering" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeNetworkPeeringProps) {
    super(scope, id, {
      ...ComputeNetworkPeering.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeNetworkPeering.GVK,
      ...toJson_ComputeNetworkPeeringProps(resolved),
    };
  }
}

/**
 * @schema ComputeNetworkPeering
 */
export interface ComputeNetworkPeeringProps {
  /**
   * @schema ComputeNetworkPeering#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeNetworkPeering#spec
   */
  readonly spec: ComputeNetworkPeeringSpec;

}

/**
 * Converts an object of type 'ComputeNetworkPeeringProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkPeeringProps(obj: ComputeNetworkPeeringProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeNetworkPeeringSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNetworkPeeringSpec
 */
export interface ComputeNetworkPeeringSpec {
  /**
   * Whether to export the custom routes to the peer network. Defaults to false.
   *
   * @default false.
   * @schema ComputeNetworkPeeringSpec#exportCustomRoutes
   */
  readonly exportCustomRoutes?: boolean;

  /**
   * Immutable.
   *
   * @schema ComputeNetworkPeeringSpec#exportSubnetRoutesWithPublicIp
   */
  readonly exportSubnetRoutesWithPublicIp?: boolean;

  /**
   * Whether to export the custom routes from the peer network. Defaults to false.
   *
   * @default false.
   * @schema ComputeNetworkPeeringSpec#importCustomRoutes
   */
  readonly importCustomRoutes?: boolean;

  /**
   * Immutable.
   *
   * @schema ComputeNetworkPeeringSpec#importSubnetRoutesWithPublicIp
   */
  readonly importSubnetRoutesWithPublicIp?: boolean;

  /**
   * @schema ComputeNetworkPeeringSpec#networkRef
   */
  readonly networkRef: ComputeNetworkPeeringSpecNetworkRef;

  /**
   * @schema ComputeNetworkPeeringSpec#peerNetworkRef
   */
  readonly peerNetworkRef: ComputeNetworkPeeringSpecPeerNetworkRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeNetworkPeeringSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
   *
   * @schema ComputeNetworkPeeringSpec#stackType
   */
  readonly stackType?: string;

}

/**
 * Converts an object of type 'ComputeNetworkPeeringSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkPeeringSpec(obj: ComputeNetworkPeeringSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportCustomRoutes': obj.exportCustomRoutes,
    'exportSubnetRoutesWithPublicIp': obj.exportSubnetRoutesWithPublicIp,
    'importCustomRoutes': obj.importCustomRoutes,
    'importSubnetRoutesWithPublicIp': obj.importSubnetRoutesWithPublicIp,
    'networkRef': toJson_ComputeNetworkPeeringSpecNetworkRef(obj.networkRef),
    'peerNetworkRef': toJson_ComputeNetworkPeeringSpecPeerNetworkRef(obj.peerNetworkRef),
    'resourceID': obj.resourceId,
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNetworkPeeringSpecNetworkRef
 */
export interface ComputeNetworkPeeringSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeNetworkPeeringSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNetworkPeeringSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNetworkPeeringSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNetworkPeeringSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkPeeringSpecNetworkRef(obj: ComputeNetworkPeeringSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNetworkPeeringSpecPeerNetworkRef
 */
export interface ComputeNetworkPeeringSpecPeerNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeNetworkPeeringSpecPeerNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNetworkPeeringSpecPeerNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNetworkPeeringSpecPeerNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNetworkPeeringSpecPeerNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNetworkPeeringSpecPeerNetworkRef(obj: ComputeNetworkPeeringSpecPeerNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeNodeGroup
 */
export class ComputeNodeGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeNodeGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeNodeGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeNodeGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeNodeGroupProps): any {
    return {
      ...ComputeNodeGroup.GVK,
      ...toJson_ComputeNodeGroupProps(props),
    };
  }

  /**
   * Defines a "ComputeNodeGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeNodeGroupProps) {
    super(scope, id, {
      ...ComputeNodeGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeNodeGroup.GVK,
      ...toJson_ComputeNodeGroupProps(resolved),
    };
  }
}

/**
 * @schema ComputeNodeGroup
 */
export interface ComputeNodeGroupProps {
  /**
   * @schema ComputeNodeGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeNodeGroup#spec
   */
  readonly spec: ComputeNodeGroupSpec;

}

/**
 * Converts an object of type 'ComputeNodeGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupProps(obj: ComputeNodeGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeNodeGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNodeGroupSpec
 */
export interface ComputeNodeGroupSpec {
  /**
   * Immutable. If you use sole-tenant nodes for your workloads, you can use the node
   * group autoscaler to automatically manage the sizes of your node groups.
   *
   * @schema ComputeNodeGroupSpec#autoscalingPolicy
   */
  readonly autoscalingPolicy?: ComputeNodeGroupSpecAutoscalingPolicy;

  /**
   * Immutable. An optional textual description of the resource.
   *
   * @schema ComputeNodeGroupSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The initial number of nodes in the node group. One of 'initial_size' or 'size' must be specified.
   *
   * @schema ComputeNodeGroupSpec#initialSize
   */
  readonly initialSize?: number;

  /**
   * Immutable. Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT.
   *
   * @schema ComputeNodeGroupSpec#maintenancePolicy
   */
  readonly maintenancePolicy?: string;

  /**
   * Immutable. contains properties for the timeframe of maintenance.
   *
   * @schema ComputeNodeGroupSpec#maintenanceWindow
   */
  readonly maintenanceWindow?: ComputeNodeGroupSpecMaintenanceWindow;

  /**
   * The node template to which this node group belongs.
   *
   * @schema ComputeNodeGroupSpec#nodeTemplateRef
   */
  readonly nodeTemplateRef: ComputeNodeGroupSpecNodeTemplateRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeNodeGroupSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Share settings for the node group.
   *
   * @schema ComputeNodeGroupSpec#shareSettings
   */
  readonly shareSettings?: ComputeNodeGroupSpecShareSettings;

  /**
   * Immutable. The total number of nodes in the node group. One of 'initial_size' or 'size' must be specified.
   *
   * @schema ComputeNodeGroupSpec#size
   */
  readonly size?: number;

  /**
   * Immutable. Zone where this node group is located.
   *
   * @schema ComputeNodeGroupSpec#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpec(obj: ComputeNodeGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingPolicy': toJson_ComputeNodeGroupSpecAutoscalingPolicy(obj.autoscalingPolicy),
    'description': obj.description,
    'initialSize': obj.initialSize,
    'maintenancePolicy': obj.maintenancePolicy,
    'maintenanceWindow': toJson_ComputeNodeGroupSpecMaintenanceWindow(obj.maintenanceWindow),
    'nodeTemplateRef': toJson_ComputeNodeGroupSpecNodeTemplateRef(obj.nodeTemplateRef),
    'resourceID': obj.resourceId,
    'shareSettings': toJson_ComputeNodeGroupSpecShareSettings(obj.shareSettings),
    'size': obj.size,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. If you use sole-tenant nodes for your workloads, you can use the node
 * group autoscaler to automatically manage the sizes of your node groups.
 *
 * @schema ComputeNodeGroupSpecAutoscalingPolicy
 */
export interface ComputeNodeGroupSpecAutoscalingPolicy {
  /**
   * Immutable. Maximum size of the node group. Set to a value less than or equal
   * to 100 and greater than or equal to min-nodes.
   *
   * @schema ComputeNodeGroupSpecAutoscalingPolicy#maxNodes
   */
  readonly maxNodes?: number;

  /**
   * Immutable. Minimum size of the node group. Must be less
   * than or equal to max-nodes. The default value is 0.
   *
   * @schema ComputeNodeGroupSpecAutoscalingPolicy#minNodes
   */
  readonly minNodes?: number;

  /**
   * Immutable. The autoscaling mode. Set to one of the following:
   * - OFF: Disables the autoscaler.
   * - ON: Enables scaling in and scaling out.
   * - ONLY_SCALE_OUT: Enables only scaling out.
   * You must use this mode if your node groups are configured to
   * restart their hosted VMs on minimal servers. Possible values: ["OFF", "ON", "ONLY_SCALE_OUT"].
   *
   * @schema ComputeNodeGroupSpecAutoscalingPolicy#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecAutoscalingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecAutoscalingPolicy(obj: ComputeNodeGroupSpecAutoscalingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodes': obj.maxNodes,
    'minNodes': obj.minNodes,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. contains properties for the timeframe of maintenance.
 *
 * @schema ComputeNodeGroupSpecMaintenanceWindow
 */
export interface ComputeNodeGroupSpecMaintenanceWindow {
  /**
   * Immutable. instances.start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
   *
   * @schema ComputeNodeGroupSpecMaintenanceWindow#startTime
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecMaintenanceWindow(obj: ComputeNodeGroupSpecMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The node template to which this node group belongs.
 *
 * @schema ComputeNodeGroupSpecNodeTemplateRef
 */
export interface ComputeNodeGroupSpecNodeTemplateRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNodeTemplate` resource.
   *
   * @schema ComputeNodeGroupSpecNodeTemplateRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNodeGroupSpecNodeTemplateRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNodeGroupSpecNodeTemplateRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecNodeTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecNodeTemplateRef(obj: ComputeNodeGroupSpecNodeTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Share settings for the node group.
 *
 * @schema ComputeNodeGroupSpecShareSettings
 */
export interface ComputeNodeGroupSpecShareSettings {
  /**
   * Immutable. A map of project id and project config. This is only valid when shareType's value is SPECIFIC_PROJECTS.
   *
   * @schema ComputeNodeGroupSpecShareSettings#projectMap
   */
  readonly projectMap?: ComputeNodeGroupSpecShareSettingsProjectMap[];

  /**
   * Immutable. Node group sharing type. Possible values: ["ORGANIZATION", "SPECIFIC_PROJECTS", "LOCAL"].
   *
   * @schema ComputeNodeGroupSpecShareSettings#shareType
   */
  readonly shareType: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecShareSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecShareSettings(obj: ComputeNodeGroupSpecShareSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'projectMap': obj.projectMap?.map(y => toJson_ComputeNodeGroupSpecShareSettingsProjectMap(y)),
    'shareType': obj.shareType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNodeGroupSpecShareSettingsProjectMap
 */
export interface ComputeNodeGroupSpecShareSettingsProjectMap {
  /**
   * The key of this project config in the parent map.
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMap#idRef
   */
  readonly idRef: ComputeNodeGroupSpecShareSettingsProjectMapIdRef;

  /**
   * The project id/number should be the same as the key of this project
   * config in the project map.
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMap#projectIdRef
   */
  readonly projectIdRef: ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecShareSettingsProjectMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecShareSettingsProjectMap(obj: ComputeNodeGroupSpecShareSettingsProjectMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idRef': toJson_ComputeNodeGroupSpecShareSettingsProjectMapIdRef(obj.idRef),
    'projectIdRef': toJson_ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef(obj.projectIdRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key of this project config in the parent map.
 *
 * @schema ComputeNodeGroupSpecShareSettingsProjectMapIdRef
 */
export interface ComputeNodeGroupSpecShareSettingsProjectMapIdRef {
  /**
   * Allowed value: The `name` field of a `Project` resource.
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapIdRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapIdRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapIdRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecShareSettingsProjectMapIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecShareSettingsProjectMapIdRef(obj: ComputeNodeGroupSpecShareSettingsProjectMapIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The project id/number should be the same as the key of this project
 * config in the project map.
 *
 * @schema ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef
 */
export interface ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef {
  /**
   * Allowed value: The `name` field of a `Project` resource.
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef(obj: ComputeNodeGroupSpecShareSettingsProjectMapProjectIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeNodeTemplate
 */
export class ComputeNodeTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeNodeTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeNodeTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeNodeTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeNodeTemplateProps): any {
    return {
      ...ComputeNodeTemplate.GVK,
      ...toJson_ComputeNodeTemplateProps(props),
    };
  }

  /**
   * Defines a "ComputeNodeTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeNodeTemplateProps) {
    super(scope, id, {
      ...ComputeNodeTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeNodeTemplate.GVK,
      ...toJson_ComputeNodeTemplateProps(resolved),
    };
  }
}

/**
 * @schema ComputeNodeTemplate
 */
export interface ComputeNodeTemplateProps {
  /**
   * @schema ComputeNodeTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeNodeTemplate#spec
   */
  readonly spec: ComputeNodeTemplateSpec;

}

/**
 * Converts an object of type 'ComputeNodeTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeTemplateProps(obj: ComputeNodeTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeNodeTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeNodeTemplateSpec
 */
export interface ComputeNodeTemplateSpec {
  /**
   * Immutable. CPU overcommit. Default value: "NONE" Possible values: ["ENABLED", "NONE"].
   *
   * @schema ComputeNodeTemplateSpec#cpuOvercommitType
   */
  readonly cpuOvercommitType?: string;

  /**
   * Immutable. An optional textual description of the resource.
   *
   * @schema ComputeNodeTemplateSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Node type to use for nodes group that are created from this template.
   * Only one of nodeTypeFlexibility and nodeType can be specified.
   *
   * @schema ComputeNodeTemplateSpec#nodeType
   */
  readonly nodeType?: string;

  /**
   * Immutable. Flexible properties for the desired node type. Node groups that
   * use this node template will create nodes of a type that matches
   * these properties. Only one of nodeTypeFlexibility and nodeType can
   * be specified.
   *
   * @schema ComputeNodeTemplateSpec#nodeTypeFlexibility
   */
  readonly nodeTypeFlexibility?: ComputeNodeTemplateSpecNodeTypeFlexibility;

  /**
   * Immutable. Region where nodes using the node template will be created.
   * If it is not provided, the provider region is used.
   *
   * @schema ComputeNodeTemplateSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeNodeTemplateSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. The server binding policy for nodes using this template. Determines
   * where the nodes should restart following a maintenance event.
   *
   * @schema ComputeNodeTemplateSpec#serverBinding
   */
  readonly serverBinding?: ComputeNodeTemplateSpecServerBinding;

}

/**
 * Converts an object of type 'ComputeNodeTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeTemplateSpec(obj: ComputeNodeTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuOvercommitType': obj.cpuOvercommitType,
    'description': obj.description,
    'nodeType': obj.nodeType,
    'nodeTypeFlexibility': toJson_ComputeNodeTemplateSpecNodeTypeFlexibility(obj.nodeTypeFlexibility),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'serverBinding': toJson_ComputeNodeTemplateSpecServerBinding(obj.serverBinding),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Flexible properties for the desired node type. Node groups that
 * use this node template will create nodes of a type that matches
 * these properties. Only one of nodeTypeFlexibility and nodeType can
 * be specified.
 *
 * @schema ComputeNodeTemplateSpecNodeTypeFlexibility
 */
export interface ComputeNodeTemplateSpecNodeTypeFlexibility {
  /**
   * Immutable. Number of virtual CPUs to use.
   *
   * @schema ComputeNodeTemplateSpecNodeTypeFlexibility#cpus
   */
  readonly cpus?: string;

  /**
   * Use local SSD.
   *
   * @schema ComputeNodeTemplateSpecNodeTypeFlexibility#localSsd
   */
  readonly localSsd?: string;

  /**
   * Immutable. Physical memory available to the node, defined in MB.
   *
   * @schema ComputeNodeTemplateSpecNodeTypeFlexibility#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ComputeNodeTemplateSpecNodeTypeFlexibility' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeTemplateSpecNodeTypeFlexibility(obj: ComputeNodeTemplateSpecNodeTypeFlexibility | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpus': obj.cpus,
    'localSsd': obj.localSsd,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The server binding policy for nodes using this template. Determines
 * where the nodes should restart following a maintenance event.
 *
 * @schema ComputeNodeTemplateSpecServerBinding
 */
export interface ComputeNodeTemplateSpecServerBinding {
  /**
   * Immutable. Type of server binding policy. If 'RESTART_NODE_ON_ANY_SERVER',
   * nodes using this template will restart on any physical server
   * following a maintenance event.
   *
   * If 'RESTART_NODE_ON_MINIMAL_SERVER', nodes using this template
   * will restart on the same physical server following a maintenance
   * event, instead of being live migrated to or restarted on a new
   * physical server. This option may be useful if you are using
   * software licenses tied to the underlying server characteristics
   * such as physical sockets or cores, to avoid the need for
   * additional licenses when maintenance occurs. However, VMs on such
   * nodes will experience outages while maintenance is applied. Possible values: ["RESTART_NODE_ON_ANY_SERVER", "RESTART_NODE_ON_MINIMAL_SERVERS"].
   *
   * @schema ComputeNodeTemplateSpecServerBinding#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeNodeTemplateSpecServerBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeNodeTemplateSpecServerBinding(obj: ComputeNodeTemplateSpecServerBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputePacketMirroring
 */
export class ComputePacketMirroring extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputePacketMirroring"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputePacketMirroring',
  }

  /**
   * Renders a Kubernetes manifest for "ComputePacketMirroring".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputePacketMirroringProps): any {
    return {
      ...ComputePacketMirroring.GVK,
      ...toJson_ComputePacketMirroringProps(props),
    };
  }

  /**
   * Defines a "ComputePacketMirroring" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputePacketMirroringProps) {
    super(scope, id, {
      ...ComputePacketMirroring.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputePacketMirroring.GVK,
      ...toJson_ComputePacketMirroringProps(resolved),
    };
  }
}

/**
 * @schema ComputePacketMirroring
 */
export interface ComputePacketMirroringProps {
  /**
   * @schema ComputePacketMirroring#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputePacketMirroring#spec
   */
  readonly spec: ComputePacketMirroringSpec;

}

/**
 * Converts an object of type 'ComputePacketMirroringProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringProps(obj: ComputePacketMirroringProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputePacketMirroringSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputePacketMirroringSpec
 */
export interface ComputePacketMirroringSpec {
  /**
   * The Forwarding Rule resource of type `loadBalancingScheme=INTERNAL` that will be used as collector for mirrored traffic. The specified forwarding rule must have `isMirroringCollector` set to true.
   *
   * @schema ComputePacketMirroringSpec#collectorIlb
   */
  readonly collectorIlb: ComputePacketMirroringSpecCollectorIlb;

  /**
   * An optional description of this resource. Provide this property when you create the resource.
   *
   * @schema ComputePacketMirroringSpec#description
   */
  readonly description?: string;

  /**
   * Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network. The default is TRUE.
   *
   * @schema ComputePacketMirroringSpec#enable
   */
  readonly enable?: string;

  /**
   * Filter for mirrored traffic. If unspecified, all traffic is mirrored.
   *
   * @schema ComputePacketMirroringSpec#filter
   */
  readonly filter?: ComputePacketMirroringSpecFilter;

  /**
   * Immutable. The location for the resource
   *
   * @schema ComputePacketMirroringSpec#location
   */
  readonly location: string;

  /**
   * PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a set of mirrored VM instances, subnetworks and/or tags for which traffic from/to all VM instances will be mirrored.
   *
   * @schema ComputePacketMirroringSpec#mirroredResources
   */
  readonly mirroredResources: ComputePacketMirroringSpecMirroredResources;

  /**
   * Immutable. Specifies the mirrored VPC network. Only packets in this network will be mirrored. All mirrored VMs should have a NIC in the given network. All mirrored subnetworks should belong to the given network.
   *
   * @schema ComputePacketMirroringSpec#network
   */
  readonly network: ComputePacketMirroringSpecNetwork;

  /**
   * The priority of applying this configuration. Priority is used to break ties in cases where there is more than one matching rule. In the case of two rules that apply for a given Instance, the one with the lowest-numbered priority value wins. Default value is 1000. Valid range is 0 through 65535.
   *
   * @schema ComputePacketMirroringSpec#priority
   */
  readonly priority?: number;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema ComputePacketMirroringSpec#projectRef
   */
  readonly projectRef: ComputePacketMirroringSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputePacketMirroringSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpec(obj: ComputePacketMirroringSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectorIlb': toJson_ComputePacketMirroringSpecCollectorIlb(obj.collectorIlb),
    'description': obj.description,
    'enable': obj.enable,
    'filter': toJson_ComputePacketMirroringSpecFilter(obj.filter),
    'location': obj.location,
    'mirroredResources': toJson_ComputePacketMirroringSpecMirroredResources(obj.mirroredResources),
    'network': toJson_ComputePacketMirroringSpecNetwork(obj.network),
    'priority': obj.priority,
    'projectRef': toJson_ComputePacketMirroringSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Forwarding Rule resource of type `loadBalancingScheme=INTERNAL` that will be used as collector for mirrored traffic. The specified forwarding rule must have `isMirroringCollector` set to true.
 *
 * @schema ComputePacketMirroringSpecCollectorIlb
 */
export interface ComputePacketMirroringSpecCollectorIlb {
  /**
   * @schema ComputePacketMirroringSpecCollectorIlb#urlRef
   */
  readonly urlRef: ComputePacketMirroringSpecCollectorIlbUrlRef;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecCollectorIlb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecCollectorIlb(obj: ComputePacketMirroringSpecCollectorIlb | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'urlRef': toJson_ComputePacketMirroringSpecCollectorIlbUrlRef(obj.urlRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter for mirrored traffic. If unspecified, all traffic is mirrored.
 *
 * @schema ComputePacketMirroringSpecFilter
 */
export interface ComputePacketMirroringSpecFilter {
  /**
   * IP CIDR ranges that apply as filter on the source (ingress) or destination (egress) IP in the IP header. Only IPv4 is supported. If no ranges are specified, all traffic that matches the specified IPProtocols is mirrored. If neither cidrRanges nor IPProtocols is specified, all traffic is mirrored.
   *
   * @schema ComputePacketMirroringSpecFilter#cidrRanges
   */
  readonly cidrRanges?: string[];

  /**
   * Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
   *
   * @schema ComputePacketMirroringSpecFilter#direction
   */
  readonly direction?: string;

  /**
   * Protocols that apply as filter on mirrored traffic. If no protocols are specified, all traffic that matches the specified CIDR ranges is mirrored. If neither cidrRanges nor IPProtocols is specified, all traffic is mirrored.
   *
   * @schema ComputePacketMirroringSpecFilter#ipProtocols
   */
  readonly ipProtocols?: string[];

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecFilter(obj: ComputePacketMirroringSpecFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidrRanges': obj.cidrRanges?.map(y => y),
    'direction': obj.direction,
    'ipProtocols': obj.ipProtocols?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a set of mirrored VM instances, subnetworks and/or tags for which traffic from/to all VM instances will be mirrored.
 *
 * @schema ComputePacketMirroringSpecMirroredResources
 */
export interface ComputePacketMirroringSpecMirroredResources {
  /**
   * A set of virtual machine instances that are being mirrored. They must live in zones contained in the same region as this packetMirroring. Note that this config will apply only to those network interfaces of the Instances that belong to the network specified in this packetMirroring. You may specify a maximum of 50 Instances.
   *
   * @schema ComputePacketMirroringSpecMirroredResources#instances
   */
  readonly instances?: ComputePacketMirroringSpecMirroredResourcesInstances[];

  /**
   * Immutable. A set of subnetworks for which traffic from/to all VM instances will be mirrored. They must live in the same region as this packetMirroring. You may specify a maximum of 5 subnetworks.
   *
   * @schema ComputePacketMirroringSpecMirroredResources#subnetworks
   */
  readonly subnetworks?: ComputePacketMirroringSpecMirroredResourcesSubnetworks[];

  /**
   * A set of mirrored tags. Traffic from/to all VM instances that have one or more of these tags will be mirrored.
   *
   * @schema ComputePacketMirroringSpecMirroredResources#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecMirroredResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecMirroredResources(obj: ComputePacketMirroringSpecMirroredResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instances': obj.instances?.map(y => toJson_ComputePacketMirroringSpecMirroredResourcesInstances(y)),
    'subnetworks': obj.subnetworks?.map(y => toJson_ComputePacketMirroringSpecMirroredResourcesSubnetworks(y)),
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the mirrored VPC network. Only packets in this network will be mirrored. All mirrored VMs should have a NIC in the given network. All mirrored subnetworks should belong to the given network.
 *
 * @schema ComputePacketMirroringSpecNetwork
 */
export interface ComputePacketMirroringSpecNetwork {
  /**
   * Immutable.
   *
   * @schema ComputePacketMirroringSpecNetwork#urlRef
   */
  readonly urlRef: ComputePacketMirroringSpecNetworkUrlRef;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecNetwork(obj: ComputePacketMirroringSpecNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'urlRef': toJson_ComputePacketMirroringSpecNetworkUrlRef(obj.urlRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema ComputePacketMirroringSpecProjectRef
 */
export interface ComputePacketMirroringSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema ComputePacketMirroringSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputePacketMirroringSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputePacketMirroringSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecProjectRef(obj: ComputePacketMirroringSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputePacketMirroringSpecCollectorIlbUrlRef
 */
export interface ComputePacketMirroringSpecCollectorIlbUrlRef {
  /**
   * Resource URL to the forwarding rule representing the ILB configured as destination of the mirrored traffic.
   *
   * Allowed value: The `selfLink` field of a `ComputeForwardingRule` resource.
   *
   * @schema ComputePacketMirroringSpecCollectorIlbUrlRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputePacketMirroringSpecCollectorIlbUrlRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputePacketMirroringSpecCollectorIlbUrlRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecCollectorIlbUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecCollectorIlbUrlRef(obj: ComputePacketMirroringSpecCollectorIlbUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputePacketMirroringSpecMirroredResourcesInstances
 */
export interface ComputePacketMirroringSpecMirroredResourcesInstances {
  /**
   * Immutable. Output only. Unique identifier for the instance; defined by the server.
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesInstances#canonicalUrl
   */
  readonly canonicalUrl?: string;

  /**
   * @schema ComputePacketMirroringSpecMirroredResourcesInstances#urlRef
   */
  readonly urlRef?: ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecMirroredResourcesInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecMirroredResourcesInstances(obj: ComputePacketMirroringSpecMirroredResourcesInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canonicalUrl': obj.canonicalUrl,
    'urlRef': toJson_ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef(obj.urlRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworks
 */
export interface ComputePacketMirroringSpecMirroredResourcesSubnetworks {
  /**
   * Immutable. Output only. Unique identifier for the subnetwork; defined by the server.
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworks#canonicalUrl
   */
  readonly canonicalUrl?: string;

  /**
   * Immutable.
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworks#urlRef
   */
  readonly urlRef?: ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecMirroredResourcesSubnetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecMirroredResourcesSubnetworks(obj: ComputePacketMirroringSpecMirroredResourcesSubnetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canonicalUrl': obj.canonicalUrl,
    'urlRef': toJson_ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef(obj.urlRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputePacketMirroringSpecNetworkUrlRef
 */
export interface ComputePacketMirroringSpecNetworkUrlRef {
  /**
   * URL of the network resource.
   *
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputePacketMirroringSpecNetworkUrlRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputePacketMirroringSpecNetworkUrlRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputePacketMirroringSpecNetworkUrlRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecNetworkUrlRef(obj: ComputePacketMirroringSpecNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef
 */
export interface ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef {
  /**
   * Resource URL to the virtual machine instance which is being mirrored.
   *
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef(obj: ComputePacketMirroringSpecMirroredResourcesInstancesUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef
 */
export interface ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef {
  /**
   * Resource URL to the subnetwork for which traffic from/to all VM instances will be mirrored.
   *
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef(obj: ComputePacketMirroringSpecMirroredResourcesSubnetworksUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeProjectMetadata
 */
export class ComputeProjectMetadata extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeProjectMetadata"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeProjectMetadata',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeProjectMetadata".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeProjectMetadataProps): any {
    return {
      ...ComputeProjectMetadata.GVK,
      ...toJson_ComputeProjectMetadataProps(props),
    };
  }

  /**
   * Defines a "ComputeProjectMetadata" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeProjectMetadataProps) {
    super(scope, id, {
      ...ComputeProjectMetadata.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeProjectMetadata.GVK,
      ...toJson_ComputeProjectMetadataProps(resolved),
    };
  }
}

/**
 * @schema ComputeProjectMetadata
 */
export interface ComputeProjectMetadataProps {
  /**
   * @schema ComputeProjectMetadata#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeProjectMetadata#spec
   */
  readonly spec: ComputeProjectMetadataSpec;

}

/**
 * Converts an object of type 'ComputeProjectMetadataProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeProjectMetadataProps(obj: ComputeProjectMetadataProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeProjectMetadataSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeProjectMetadataSpec
 */
export interface ComputeProjectMetadataSpec {
  /**
   * A series of key value pairs.
   *
   * @schema ComputeProjectMetadataSpec#metadata
   */
  readonly metadata: { [key: string]: string };

}

/**
 * Converts an object of type 'ComputeProjectMetadataSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeProjectMetadataSpec(obj: ComputeProjectMetadataSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRegionNetworkEndpointGroup
 */
export class ComputeRegionNetworkEndpointGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRegionNetworkEndpointGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRegionNetworkEndpointGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRegionNetworkEndpointGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRegionNetworkEndpointGroupProps): any {
    return {
      ...ComputeRegionNetworkEndpointGroup.GVK,
      ...toJson_ComputeRegionNetworkEndpointGroupProps(props),
    };
  }

  /**
   * Defines a "ComputeRegionNetworkEndpointGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRegionNetworkEndpointGroupProps) {
    super(scope, id, {
      ...ComputeRegionNetworkEndpointGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRegionNetworkEndpointGroup.GVK,
      ...toJson_ComputeRegionNetworkEndpointGroupProps(resolved),
    };
  }
}

/**
 * @schema ComputeRegionNetworkEndpointGroup
 */
export interface ComputeRegionNetworkEndpointGroupProps {
  /**
   * @schema ComputeRegionNetworkEndpointGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRegionNetworkEndpointGroup#spec
   */
  readonly spec: ComputeRegionNetworkEndpointGroupSpec;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupProps(obj: ComputeRegionNetworkEndpointGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRegionNetworkEndpointGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRegionNetworkEndpointGroupSpec
 */
export interface ComputeRegionNetworkEndpointGroupSpec {
  /**
   * Immutable. Only valid when networkEndpointType is "SERVERLESS".
   * Only one of cloud_run, app_engine, cloud_function or serverless_deployment may be set.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#cloudFunction
   */
  readonly cloudFunction?: ComputeRegionNetworkEndpointGroupSpecCloudFunction;

  /**
   * Immutable. Only valid when networkEndpointType is "SERVERLESS".
   * Only one of cloud_run, app_engine, cloud_function or serverless_deployment may be set.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#cloudRun
   */
  readonly cloudRun?: ComputeRegionNetworkEndpointGroupSpecCloudRun;

  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Type of network endpoints in this network endpoint group. Defaults to SERVERLESS Default value: "SERVERLESS" Possible values: ["SERVERLESS", "PRIVATE_SERVICE_CONNECT"].
   *
   * @default SERVERLESS Default value: "SERVERLESS" Possible values: ["SERVERLESS", "PRIVATE_SERVICE_CONNECT"].
   * @schema ComputeRegionNetworkEndpointGroupSpec#networkEndpointType
   */
  readonly networkEndpointType?: string;

  /**
   * Immutable. This field is only used for PSC.
   * The URL of the network to which all network endpoints in the NEG belong. Uses
   * "default" project network if unspecified.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#networkRef
   */
  readonly networkRef?: ComputeRegionNetworkEndpointGroupSpecNetworkRef;

  /**
   * Immutable. The target service url used to set up private service connection to
   * a Google API or a PSC Producer Service Attachment.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#pscTargetService
   */
  readonly pscTargetService?: string;

  /**
   * Immutable. A reference to the region where the Serverless NEGs Reside.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. This field is only used for PSC.
   * Optional URL of the subnetwork to which all network endpoints in the NEG belong.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpec#subnetworkRef
   */
  readonly subnetworkRef?: ComputeRegionNetworkEndpointGroupSpecSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpec(obj: ComputeRegionNetworkEndpointGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudFunction': toJson_ComputeRegionNetworkEndpointGroupSpecCloudFunction(obj.cloudFunction),
    'cloudRun': toJson_ComputeRegionNetworkEndpointGroupSpecCloudRun(obj.cloudRun),
    'description': obj.description,
    'networkEndpointType': obj.networkEndpointType,
    'networkRef': toJson_ComputeRegionNetworkEndpointGroupSpecNetworkRef(obj.networkRef),
    'pscTargetService': obj.pscTargetService,
    'region': obj.region,
    'resourceID': obj.resourceId,
    'subnetworkRef': toJson_ComputeRegionNetworkEndpointGroupSpecSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Only valid when networkEndpointType is "SERVERLESS".
 * Only one of cloud_run, app_engine, cloud_function or serverless_deployment may be set.
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunction
 */
export interface ComputeRegionNetworkEndpointGroupSpecCloudFunction {
  /**
   * Immutable. A user-defined name of the Cloud Function.
   * The function name is case-sensitive and must be 1-63 characters long.
   * Example value: "func1".
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunction#functionRef
   */
  readonly functionRef?: ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef;

  /**
   * Immutable. A template to parse function field from a request URL. URL mask allows
   * for routing to multiple Cloud Functions without having to create
   * multiple Network Endpoint Groups and backend services.
   *
   * For example, request URLs "mydomain.com/function1" and "mydomain.com/function2"
   * can be backed by the same Serverless NEG with URL mask "/". The URL mask
   * will parse them to { function = "function1" } and { function = "function2" } respectively.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunction#urlMask
   */
  readonly urlMask?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecCloudFunction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecCloudFunction(obj: ComputeRegionNetworkEndpointGroupSpecCloudFunction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionRef': toJson_ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef(obj.functionRef),
    'urlMask': obj.urlMask,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Only valid when networkEndpointType is "SERVERLESS".
 * Only one of cloud_run, app_engine, cloud_function or serverless_deployment may be set.
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecCloudRun
 */
export interface ComputeRegionNetworkEndpointGroupSpecCloudRun {
  /**
   * Immutable. Cloud Run service is the main resource of Cloud Run.
   * The service must be 1-63 characters long, and comply with RFC1035.
   * Example value: "run-service".
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRun#serviceRef
   */
  readonly serviceRef?: ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef;

  /**
   * Immutable. Cloud Run tag represents the "named-revision" to provide
   * additional fine-grained traffic routing information.
   * The tag must be 1-63 characters long, and comply with RFC1035.
   * Example value: "revision-0010".
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRun#tag
   */
  readonly tag?: string;

  /**
   * Immutable. A template to parse service and tag fields from a request URL.
   * URL mask allows for routing to multiple Run services without having
   * to create multiple network endpoint groups and backend services.
   *
   * For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2"
   * an be backed by the same Serverless Network Endpoint Group (NEG) with
   * URL mask ".domain.com/". The URL mask will parse them to { service="bar1", tag="foo1" }
   * and { service="bar2", tag="foo2" } respectively.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRun#urlMask
   */
  readonly urlMask?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecCloudRun' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecCloudRun(obj: ComputeRegionNetworkEndpointGroupSpecCloudRun | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef(obj.serviceRef),
    'tag': obj.tag,
    'urlMask': obj.urlMask,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. This field is only used for PSC.
 * The URL of the network to which all network endpoints in the NEG belong. Uses
 * "default" project network if unspecified.
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecNetworkRef
 */
export interface ComputeRegionNetworkEndpointGroupSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecNetworkRef(obj: ComputeRegionNetworkEndpointGroupSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. This field is only used for PSC.
 * Optional URL of the subnetwork to which all network endpoints in the NEG belong.
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecSubnetworkRef
 */
export interface ComputeRegionNetworkEndpointGroupSpecSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecSubnetworkRef(obj: ComputeRegionNetworkEndpointGroupSpecSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. A user-defined name of the Cloud Function.
 * The function name is case-sensitive and must be 1-63 characters long.
 * Example value: "func1".
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef
 */
export interface ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef {
  /**
   * Allowed value: The `name` field of a `CloudFunctionsFunction` resource.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef(obj: ComputeRegionNetworkEndpointGroupSpecCloudFunctionFunctionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Cloud Run service is the main resource of Cloud Run.
 * The service must be 1-63 characters long, and comply with RFC1035.
 * Example value: "run-service".
 *
 * @schema ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef
 */
export interface ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef {
  /**
   * Allowed value: The `name` field of a `RunService` resource.
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef(obj: ComputeRegionNetworkEndpointGroupSpecCloudRunServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeReservation
 */
export class ComputeReservation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeReservation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeReservation',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeReservation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeReservationProps): any {
    return {
      ...ComputeReservation.GVK,
      ...toJson_ComputeReservationProps(props),
    };
  }

  /**
   * Defines a "ComputeReservation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeReservationProps) {
    super(scope, id, {
      ...ComputeReservation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeReservation.GVK,
      ...toJson_ComputeReservationProps(resolved),
    };
  }
}

/**
 * @schema ComputeReservation
 */
export interface ComputeReservationProps {
  /**
   * @schema ComputeReservation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeReservation#spec
   */
  readonly spec: ComputeReservationSpec;

}

/**
 * Converts an object of type 'ComputeReservationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationProps(obj: ComputeReservationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeReservationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeReservationSpec
 */
export interface ComputeReservationSpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeReservationSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeReservationSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Reservation for instances with specific machine shapes.
   *
   * @schema ComputeReservationSpec#specificReservation
   */
  readonly specificReservation: ComputeReservationSpecSpecificReservation;

  /**
   * Immutable. When set to true, only VMs that target this reservation by name can
   * consume this reservation. Otherwise, it can be consumed by VMs with
   * affinity for any reservation. Defaults to false.
   *
   * @default false.
   * @schema ComputeReservationSpec#specificReservationRequired
   */
  readonly specificReservationRequired?: boolean;

  /**
   * Immutable. The zone where the reservation is made.
   *
   * @schema ComputeReservationSpec#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'ComputeReservationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationSpec(obj: ComputeReservationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'resourceID': obj.resourceId,
    'specificReservation': toJson_ComputeReservationSpecSpecificReservation(obj.specificReservation),
    'specificReservationRequired': obj.specificReservationRequired,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reservation for instances with specific machine shapes.
 *
 * @schema ComputeReservationSpecSpecificReservation
 */
export interface ComputeReservationSpecSpecificReservation {
  /**
   * The number of resources that are allocated.
   *
   * @schema ComputeReservationSpecSpecificReservation#count
   */
  readonly count: number;

  /**
   * How many instances are in use.
   *
   * @schema ComputeReservationSpecSpecificReservation#inUseCount
   */
  readonly inUseCount?: number;

  /**
   * Immutable. The instance properties for the reservation.
   *
   * @schema ComputeReservationSpecSpecificReservation#instanceProperties
   */
  readonly instanceProperties: ComputeReservationSpecSpecificReservationInstanceProperties;

}

/**
 * Converts an object of type 'ComputeReservationSpecSpecificReservation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationSpecSpecificReservation(obj: ComputeReservationSpecSpecificReservation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'inUseCount': obj.inUseCount,
    'instanceProperties': toJson_ComputeReservationSpecSpecificReservationInstanceProperties(obj.instanceProperties),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The instance properties for the reservation.
 *
 * @schema ComputeReservationSpecSpecificReservationInstanceProperties
 */
export interface ComputeReservationSpecSpecificReservationInstanceProperties {
  /**
   * Immutable. Guest accelerator type and count.
   *
   * @schema ComputeReservationSpecSpecificReservationInstanceProperties#guestAccelerators
   */
  readonly guestAccelerators?: ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators[];

  /**
   * Immutable. The amount of local ssd to reserve with each instance. This
   * reserves disks of type 'local-ssd'.
   *
   * @schema ComputeReservationSpecSpecificReservationInstanceProperties#localSsds
   */
  readonly localSsds?: ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds[];

  /**
   * Immutable. The name of the machine type to reserve.
   *
   * @schema ComputeReservationSpecSpecificReservationInstanceProperties#machineType
   */
  readonly machineType: string;

  /**
   * Immutable. The minimum CPU platform for the reservation. For example,
   * '"Intel Skylake"'. See
   * the CPU platform availability reference](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform#availablezones)
   * for information on available CPU platforms.
   *
   * @schema ComputeReservationSpecSpecificReservationInstanceProperties#minCpuPlatform
   */
  readonly minCpuPlatform?: string;

}

/**
 * Converts an object of type 'ComputeReservationSpecSpecificReservationInstanceProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationSpecSpecificReservationInstanceProperties(obj: ComputeReservationSpecSpecificReservationInstanceProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'guestAccelerators': obj.guestAccelerators?.map(y => toJson_ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators(y)),
    'localSsds': obj.localSsds?.map(y => toJson_ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds(y)),
    'machineType': obj.machineType,
    'minCpuPlatform': obj.minCpuPlatform,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators
 */
export interface ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators {
  /**
   * Immutable. The number of the guest accelerator cards exposed to
   * this instance.
   *
   * @schema ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators#acceleratorCount
   */
  readonly acceleratorCount: number;

  /**
   * Immutable. The full or partial URL of the accelerator type to
   * attach to this instance. For example:
   * 'projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100'
   *
   * If you are creating an instance template, specify only the accelerator name.
   *
   * @schema ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators#acceleratorType
   */
  readonly acceleratorType: string;

}

/**
 * Converts an object of type 'ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators(obj: ComputeReservationSpecSpecificReservationInstancePropertiesGuestAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorCount': obj.acceleratorCount,
    'acceleratorType': obj.acceleratorType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds
 */
export interface ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds {
  /**
   * Immutable. The size of the disk in base-2 GB.
   *
   * @schema ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds#diskSizeGb
   */
  readonly diskSizeGb: number;

  /**
   * Immutable. The disk interface to use for attaching this disk. Default value: "SCSI" Possible values: ["SCSI", "NVME"].
   *
   * @schema ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds#interface
   */
  readonly interface?: string;

}

/**
 * Converts an object of type 'ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds(obj: ComputeReservationSpecSpecificReservationInstancePropertiesLocalSsds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'diskSizeGb': obj.diskSizeGb,
    'interface': obj.interface,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeResourcePolicy
 */
export class ComputeResourcePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeResourcePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeResourcePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeResourcePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeResourcePolicyProps): any {
    return {
      ...ComputeResourcePolicy.GVK,
      ...toJson_ComputeResourcePolicyProps(props),
    };
  }

  /**
   * Defines a "ComputeResourcePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeResourcePolicyProps) {
    super(scope, id, {
      ...ComputeResourcePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeResourcePolicy.GVK,
      ...toJson_ComputeResourcePolicyProps(resolved),
    };
  }
}

/**
 * @schema ComputeResourcePolicy
 */
export interface ComputeResourcePolicyProps {
  /**
   * @schema ComputeResourcePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeResourcePolicy#spec
   */
  readonly spec: ComputeResourcePolicySpec;

}

/**
 * Converts an object of type 'ComputeResourcePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicyProps(obj: ComputeResourcePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeResourcePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeResourcePolicySpec
 */
export interface ComputeResourcePolicySpec {
  /**
   * Immutable. An optional description of this resource. Provide this property when you create the resource.
   *
   * @schema ComputeResourcePolicySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Replication consistency group for asynchronous disk replication.
   *
   * @schema ComputeResourcePolicySpec#diskConsistencyGroupPolicy
   */
  readonly diskConsistencyGroupPolicy?: ComputeResourcePolicySpecDiskConsistencyGroupPolicy;

  /**
   * Immutable. Resource policy for instances used for placement configuration.
   *
   * @schema ComputeResourcePolicySpec#groupPlacementPolicy
   */
  readonly groupPlacementPolicy?: ComputeResourcePolicySpecGroupPlacementPolicy;

  /**
   * Immutable. Resource policy for scheduling instance operations.
   *
   * @schema ComputeResourcePolicySpec#instanceSchedulePolicy
   */
  readonly instanceSchedulePolicy?: ComputeResourcePolicySpecInstanceSchedulePolicy;

  /**
   * Immutable. Region where resource policy resides.
   *
   * @schema ComputeResourcePolicySpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeResourcePolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Policy for creating snapshots of persistent disks.
   *
   * @schema ComputeResourcePolicySpec#snapshotSchedulePolicy
   */
  readonly snapshotSchedulePolicy?: ComputeResourcePolicySpecSnapshotSchedulePolicy;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpec(obj: ComputeResourcePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'diskConsistencyGroupPolicy': toJson_ComputeResourcePolicySpecDiskConsistencyGroupPolicy(obj.diskConsistencyGroupPolicy),
    'groupPlacementPolicy': toJson_ComputeResourcePolicySpecGroupPlacementPolicy(obj.groupPlacementPolicy),
    'instanceSchedulePolicy': toJson_ComputeResourcePolicySpecInstanceSchedulePolicy(obj.instanceSchedulePolicy),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'snapshotSchedulePolicy': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicy(obj.snapshotSchedulePolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Replication consistency group for asynchronous disk replication.
 *
 * @schema ComputeResourcePolicySpecDiskConsistencyGroupPolicy
 */
export interface ComputeResourcePolicySpecDiskConsistencyGroupPolicy {
  /**
   * Immutable. Enable disk consistency on the resource policy.
   *
   * @schema ComputeResourcePolicySpecDiskConsistencyGroupPolicy#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecDiskConsistencyGroupPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecDiskConsistencyGroupPolicy(obj: ComputeResourcePolicySpecDiskConsistencyGroupPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Resource policy for instances used for placement configuration.
 *
 * @schema ComputeResourcePolicySpecGroupPlacementPolicy
 */
export interface ComputeResourcePolicySpecGroupPlacementPolicy {
  /**
   * Immutable. The number of availability domains instances will be spread across. If two instances are in different
   * availability domain, they will not be put in the same low latency network.
   *
   * @schema ComputeResourcePolicySpecGroupPlacementPolicy#availabilityDomainCount
   */
  readonly availabilityDomainCount?: number;

  /**
   * Immutable. Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
   * Specify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created
   * with a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy
   * attached. Possible values: ["COLLOCATED"].
   *
   * @schema ComputeResourcePolicySpecGroupPlacementPolicy#collocation
   */
  readonly collocation?: string;

  /**
   * Immutable. Specifies the number of max logical switches.
   *
   * @schema ComputeResourcePolicySpecGroupPlacementPolicy#maxDistance
   */
  readonly maxDistance?: number;

  /**
   * Immutable. Number of VMs in this placement group. Google does not recommend that you use this field
   * unless you use a compact policy and you want your policy to work only if it contains this
   * exact number of VMs.
   *
   * @schema ComputeResourcePolicySpecGroupPlacementPolicy#vmCount
   */
  readonly vmCount?: number;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecGroupPlacementPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecGroupPlacementPolicy(obj: ComputeResourcePolicySpecGroupPlacementPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityDomainCount': obj.availabilityDomainCount,
    'collocation': obj.collocation,
    'maxDistance': obj.maxDistance,
    'vmCount': obj.vmCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Resource policy for scheduling instance operations.
 *
 * @schema ComputeResourcePolicySpecInstanceSchedulePolicy
 */
export interface ComputeResourcePolicySpecInstanceSchedulePolicy {
  /**
   * Immutable. The expiration time of the schedule. The timestamp is an RFC3339 string.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicy#expirationTime
   */
  readonly expirationTime?: string;

  /**
   * Immutable. The start time of the schedule. The timestamp is an RFC3339 string.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicy#startTime
   */
  readonly startTime?: string;

  /**
   * Immutable. Specifies the time zone to be used in interpreting the schedule. The value of this field must be a time zone name
   * from the tz database: http://en.wikipedia.org/wiki/Tz_database.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicy#timeZone
   */
  readonly timeZone: string;

  /**
   * Immutable. Specifies the schedule for starting instances.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicy#vmStartSchedule
   */
  readonly vmStartSchedule?: ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule;

  /**
   * Immutable. Specifies the schedule for stopping instances.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicy#vmStopSchedule
   */
  readonly vmStopSchedule?: ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecInstanceSchedulePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecInstanceSchedulePolicy(obj: ComputeResourcePolicySpecInstanceSchedulePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expirationTime': obj.expirationTime,
    'startTime': obj.startTime,
    'timeZone': obj.timeZone,
    'vmStartSchedule': toJson_ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule(obj.vmStartSchedule),
    'vmStopSchedule': toJson_ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule(obj.vmStopSchedule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Policy for creating snapshots of persistent disks.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicy
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicy {
  /**
   * Immutable. Retention policy applied to snapshots created by this resource policy.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicy#retentionPolicy
   */
  readonly retentionPolicy?: ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy;

  /**
   * Immutable. Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicy#schedule
   */
  readonly schedule: ComputeResourcePolicySpecSnapshotSchedulePolicySchedule;

  /**
   * Immutable. Properties with which the snapshots are created, such as labels.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicy#snapshotProperties
   */
  readonly snapshotProperties?: ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicy(obj: ComputeResourcePolicySpecSnapshotSchedulePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionPolicy': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy(obj.retentionPolicy),
    'schedule': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicySchedule(obj.schedule),
    'snapshotProperties': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties(obj.snapshotProperties),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the schedule for starting instances.
 *
 * @schema ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule
 */
export interface ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule {
  /**
   * Immutable. Specifies the frequency for the operation, using the unix-cron format.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule#schedule
   */
  readonly schedule: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule(obj: ComputeResourcePolicySpecInstanceSchedulePolicyVmStartSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies the schedule for stopping instances.
 *
 * @schema ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule
 */
export interface ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule {
  /**
   * Immutable. Specifies the frequency for the operation, using the unix-cron format.
   *
   * @schema ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule#schedule
   */
  readonly schedule: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule(obj: ComputeResourcePolicySpecInstanceSchedulePolicyVmStopSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Retention policy applied to snapshots created by this resource policy.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy {
  /**
   * Immutable. Maximum age of the snapshot that is allowed to be kept.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy#maxRetentionDays
   */
  readonly maxRetentionDays: number;

  /**
   * Immutable. Specifies the behavior to apply to scheduled snapshots when
   * the source disk is deleted. Default value: "KEEP_AUTO_SNAPSHOTS" Possible values: ["KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY"].
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy#onSourceDiskDelete
   */
  readonly onSourceDiskDelete?: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy(obj: ComputeResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetentionDays': obj.maxRetentionDays,
    'onSourceDiskDelete': obj.onSourceDiskDelete,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySchedule
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicySchedule {
  /**
   * Immutable. The policy will execute every nth day at the specified time.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySchedule#dailySchedule
   */
  readonly dailySchedule?: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule;

  /**
   * Immutable. The policy will execute every nth hour starting at the specified time.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySchedule#hourlySchedule
   */
  readonly hourlySchedule?: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule;

  /**
   * Immutable. Allows specifying a snapshot time for each day of the week.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySchedule#weeklySchedule
   */
  readonly weeklySchedule?: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicySchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicySchedule(obj: ComputeResourcePolicySpecSnapshotSchedulePolicySchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dailySchedule': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule(obj.dailySchedule),
    'hourlySchedule': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule(obj.hourlySchedule),
    'weeklySchedule': toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule(obj.weeklySchedule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Properties with which the snapshots are created, such as labels.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties {
  /**
   * Immutable. Creates the new snapshot in the snapshot chain labeled with the
   * specified name. The chain name must be 1-63 characters long and comply
   * with RFC1035.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties#chainName
   */
  readonly chainName?: string;

  /**
   * Immutable. Whether to perform a 'guest aware' snapshot.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties#guestFlush
   */
  readonly guestFlush?: boolean;

  /**
   * Immutable. A set of key-value pairs.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Immutable. Cloud Storage bucket location to store the auto snapshot
   * (regional or multi-regional).
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties#storageLocations
   */
  readonly storageLocations?: string[];

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties(obj: ComputeResourcePolicySpecSnapshotSchedulePolicySnapshotProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chainName': obj.chainName,
    'guestFlush': obj.guestFlush,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'storageLocations': obj.storageLocations?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The policy will execute every nth day at the specified time.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule {
  /**
   * Immutable. Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle. Days in cycle for snapshot schedule policy must be 1.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule#daysInCycle
   */
  readonly daysInCycle: number;

  /**
   * Immutable. This must be in UTC format that resolves to one of
   * 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
   * both 13:00-5 and 08:00 are valid.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule#startTime
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule(obj: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daysInCycle': obj.daysInCycle,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The policy will execute every nth hour starting at the specified time.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule {
  /**
   * Immutable. The number of hours between snapshots.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule#hoursInCycle
   */
  readonly hoursInCycle: number;

  /**
   * Immutable. Time within the window to start the operations.
   * It must be in an hourly format "HH:MM",
   * where HH : [00-23] and MM : [00] GMT.
   * eg: 21:00.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule#startTime
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule(obj: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hoursInCycle': obj.hoursInCycle,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Allows specifying a snapshot time for each day of the week.
 *
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule {
  /**
   * Immutable. May contain up to seven (one for each day of the week) snapshot times.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule#dayOfWeeks
   */
  readonly dayOfWeeks: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks[];

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule(obj: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dayOfWeeks': obj.dayOfWeeks?.map(y => toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks
 */
export interface ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks {
  /**
   * Immutable. The day of the week to create the snapshot. e.g. MONDAY Possible values: ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"].
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks#day
   */
  readonly day: string;

  /**
   * Immutable. Time within the window to start the operations.
   * It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
   *
   * @schema ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks#startTime
   */
  readonly startTime: string;

}

/**
 * Converts an object of type 'ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks(obj: ComputeResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'startTime': obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRoute
 */
export class ComputeRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRoute',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRouteProps): any {
    return {
      ...ComputeRoute.GVK,
      ...toJson_ComputeRouteProps(props),
    };
  }

  /**
   * Defines a "ComputeRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRouteProps) {
    super(scope, id, {
      ...ComputeRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRoute.GVK,
      ...toJson_ComputeRouteProps(resolved),
    };
  }
}

/**
 * @schema ComputeRoute
 */
export interface ComputeRouteProps {
  /**
   * @schema ComputeRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRoute#spec
   */
  readonly spec: ComputeRouteSpec;

}

/**
 * Converts an object of type 'ComputeRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteProps(obj: ComputeRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouteSpec
 */
export interface ComputeRouteSpec {
  /**
   * Immutable. An optional description of this resource. Provide this property
   * when you create the resource.
   *
   * @schema ComputeRouteSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The destination range of outgoing packets that this route applies to.
   * Only IPv4 is supported.
   *
   * @schema ComputeRouteSpec#destRange
   */
  readonly destRange: string;

  /**
   * The network that this route applies to.
   *
   * @schema ComputeRouteSpec#networkRef
   */
  readonly networkRef: ComputeRouteSpecNetworkRef;

  /**
   * Immutable. URL to a gateway that should handle matching packets.
   * Currently, you can only specify the internet gateway, using a full or
   * partial valid URL:
   * * 'https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway'
   * * 'projects/project/global/gateways/default-internet-gateway'
   * * 'global/gateways/default-internet-gateway'
   * * The string 'default-internet-gateway'.
   *
   * @schema ComputeRouteSpec#nextHopGateway
   */
  readonly nextHopGateway?: string;

  /**
   * A forwarding rule of type loadBalancingScheme=INTERNAL that should
   * handle matching packets.  Note that this can only be used when the
   * destinationRange is a public (non-RFC 1918) IP CIDR range.
   *
   * @schema ComputeRouteSpec#nextHopILBRef
   */
  readonly nextHopIlbRef?: ComputeRouteSpecNextHopIlbRef;

  /**
   * Instance that should handle matching packets.
   *
   * @schema ComputeRouteSpec#nextHopInstanceRef
   */
  readonly nextHopInstanceRef?: ComputeRouteSpecNextHopInstanceRef;

  /**
   * Immutable. Network IP address of an instance that should handle matching packets.
   *
   * @schema ComputeRouteSpec#nextHopIp
   */
  readonly nextHopIp?: string;

  /**
   * The ComputeVPNTunnel that should handle matching packets
   *
   * @schema ComputeRouteSpec#nextHopVPNTunnelRef
   */
  readonly nextHopVpnTunnelRef?: ComputeRouteSpecNextHopVpnTunnelRef;

  /**
   * Immutable. The priority of this route. Priority is used to break ties in cases
   * where there is more than one matching route of equal prefix length.
   *
   * In the case of two routes with equal prefix length, the one with the
   * lowest-numbered priority value wins.
   *
   * Default value is 1000. Valid range is 0 through 65535.
   *
   * @schema ComputeRouteSpec#priority
   */
  readonly priority?: number;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRouteSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. A list of instance tags to which this route applies.
   *
   * @schema ComputeRouteSpec#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'ComputeRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteSpec(obj: ComputeRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'destRange': obj.destRange,
    'networkRef': toJson_ComputeRouteSpecNetworkRef(obj.networkRef),
    'nextHopGateway': obj.nextHopGateway,
    'nextHopILBRef': toJson_ComputeRouteSpecNextHopIlbRef(obj.nextHopIlbRef),
    'nextHopInstanceRef': toJson_ComputeRouteSpecNextHopInstanceRef(obj.nextHopInstanceRef),
    'nextHopIp': obj.nextHopIp,
    'nextHopVPNTunnelRef': toJson_ComputeRouteSpecNextHopVpnTunnelRef(obj.nextHopVpnTunnelRef),
    'priority': obj.priority,
    'resourceID': obj.resourceId,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network that this route applies to.
 *
 * @schema ComputeRouteSpecNetworkRef
 */
export interface ComputeRouteSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeRouteSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouteSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouteSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouteSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteSpecNetworkRef(obj: ComputeRouteSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A forwarding rule of type loadBalancingScheme=INTERNAL that should
 * handle matching packets.  Note that this can only be used when the
 * destinationRange is a public (non-RFC 1918) IP CIDR range.
 *
 * @schema ComputeRouteSpecNextHopIlbRef
 */
export interface ComputeRouteSpecNextHopIlbRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeForwardingRule` resource.
   *
   * @schema ComputeRouteSpecNextHopIlbRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouteSpecNextHopIlbRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouteSpecNextHopIlbRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouteSpecNextHopIlbRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteSpecNextHopIlbRef(obj: ComputeRouteSpecNextHopIlbRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Instance that should handle matching packets.
 *
 * @schema ComputeRouteSpecNextHopInstanceRef
 */
export interface ComputeRouteSpecNextHopInstanceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputeRouteSpecNextHopInstanceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouteSpecNextHopInstanceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouteSpecNextHopInstanceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouteSpecNextHopInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteSpecNextHopInstanceRef(obj: ComputeRouteSpecNextHopInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ComputeVPNTunnel that should handle matching packets
 *
 * @schema ComputeRouteSpecNextHopVpnTunnelRef
 */
export interface ComputeRouteSpecNextHopVpnTunnelRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeVPNTunnel` resource.
   *
   * @schema ComputeRouteSpecNextHopVpnTunnelRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouteSpecNextHopVpnTunnelRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouteSpecNextHopVpnTunnelRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouteSpecNextHopVpnTunnelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouteSpecNextHopVpnTunnelRef(obj: ComputeRouteSpecNextHopVpnTunnelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRouter
 */
export class ComputeRouter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRouter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRouter',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRouter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRouterProps): any {
    return {
      ...ComputeRouter.GVK,
      ...toJson_ComputeRouterProps(props),
    };
  }

  /**
   * Defines a "ComputeRouter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRouterProps) {
    super(scope, id, {
      ...ComputeRouter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRouter.GVK,
      ...toJson_ComputeRouterProps(resolved),
    };
  }
}

/**
 * @schema ComputeRouter
 */
export interface ComputeRouterProps {
  /**
   * @schema ComputeRouter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRouter#spec
   */
  readonly spec: ComputeRouterSpec;

}

/**
 * Converts an object of type 'ComputeRouterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterProps(obj: ComputeRouterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRouterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterSpec
 */
export interface ComputeRouterSpec {
  /**
   * BGP information specific to this router.
   *
   * @schema ComputeRouterSpec#bgp
   */
  readonly bgp?: ComputeRouterSpecBgp;

  /**
   * An optional description of this resource.
   *
   * @schema ComputeRouterSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Indicates if a router is dedicated for use with encrypted VLAN
   * attachments (interconnectAttachments).
   *
   * @schema ComputeRouterSpec#encryptedInterconnectRouter
   */
  readonly encryptedInterconnectRouter?: boolean;

  /**
   * A reference to the network to which this router belongs.
   *
   * @schema ComputeRouterSpec#networkRef
   */
  readonly networkRef: ComputeRouterSpecNetworkRef;

  /**
   * Immutable. Region where the router resides.
   *
   * @schema ComputeRouterSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRouterSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeRouterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterSpec(obj: ComputeRouterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bgp': toJson_ComputeRouterSpecBgp(obj.bgp),
    'description': obj.description,
    'encryptedInterconnectRouter': obj.encryptedInterconnectRouter,
    'networkRef': toJson_ComputeRouterSpecNetworkRef(obj.networkRef),
    'region': obj.region,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BGP information specific to this router.
 *
 * @schema ComputeRouterSpecBgp
 */
export interface ComputeRouterSpecBgp {
  /**
   * User-specified flag to indicate which mode to use for advertisement. Default value: "DEFAULT" Possible values: ["DEFAULT", "CUSTOM"].
   *
   * @schema ComputeRouterSpecBgp#advertiseMode
   */
  readonly advertiseMode?: string;

  /**
   * User-specified list of prefix groups to advertise in custom mode.
   * This field can only be populated if advertiseMode is CUSTOM and
   * is advertised to all peers of the router. These groups will be
   * advertised in addition to any specified prefixes. Leave this field
   * blank to advertise no custom groups.
   *
   * This enum field has the one valid value: ALL_SUBNETS.
   *
   * @schema ComputeRouterSpecBgp#advertisedGroups
   */
  readonly advertisedGroups?: string[];

  /**
   * User-specified list of individual IP ranges to advertise in
   * custom mode. This field can only be populated if advertiseMode
   * is CUSTOM and is advertised to all peers of the router. These IP
   * ranges will be advertised in addition to any specified groups.
   * Leave this field blank to advertise no custom IP ranges.
   *
   * @schema ComputeRouterSpecBgp#advertisedIpRanges
   */
  readonly advertisedIpRanges?: ComputeRouterSpecBgpAdvertisedIpRanges[];

  /**
   * Local BGP Autonomous System Number (ASN). Must be an RFC6996
   * private ASN, either 16-bit or 32-bit. The value will be fixed for
   * this router resource. All VPN tunnels that link to this router
   * will have the same local ASN.
   *
   * @schema ComputeRouterSpecBgp#asn
   */
  readonly asn: number;

  /**
   * The interval in seconds between BGP keepalive messages that are sent
   * to the peer. Hold time is three times the interval at which keepalive
   * messages are sent, and the hold time is the maximum number of seconds
   * allowed to elapse between successive keepalive messages that BGP
   * receives from a peer.
   *
   * BGP will use the smaller of either the local hold time value or the
   * peer's hold time value as the hold time for the BGP connection
   * between the two peers. If set, this value must be between 20 and 60.
   * The default is 20.
   *
   * @schema ComputeRouterSpecBgp#keepaliveInterval
   */
  readonly keepaliveInterval?: number;

}

/**
 * Converts an object of type 'ComputeRouterSpecBgp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterSpecBgp(obj: ComputeRouterSpecBgp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertiseMode': obj.advertiseMode,
    'advertisedGroups': obj.advertisedGroups?.map(y => y),
    'advertisedIpRanges': obj.advertisedIpRanges?.map(y => toJson_ComputeRouterSpecBgpAdvertisedIpRanges(y)),
    'asn': obj.asn,
    'keepaliveInterval': obj.keepaliveInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the network to which this router belongs.
 *
 * @schema ComputeRouterSpecNetworkRef
 */
export interface ComputeRouterSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeRouterSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterSpecNetworkRef(obj: ComputeRouterSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterSpecBgpAdvertisedIpRanges
 */
export interface ComputeRouterSpecBgpAdvertisedIpRanges {
  /**
   * User-specified description for the IP range.
   *
   * @schema ComputeRouterSpecBgpAdvertisedIpRanges#description
   */
  readonly description?: string;

  /**
   * The IP range to advertise. The value must be a
   * CIDR-formatted string.
   *
   * @schema ComputeRouterSpecBgpAdvertisedIpRanges#range
   */
  readonly range: string;

}

/**
 * Converts an object of type 'ComputeRouterSpecBgpAdvertisedIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterSpecBgpAdvertisedIpRanges(obj: ComputeRouterSpecBgpAdvertisedIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRouterInterface
 */
export class ComputeRouterInterface extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRouterInterface"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRouterInterface',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRouterInterface".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRouterInterfaceProps): any {
    return {
      ...ComputeRouterInterface.GVK,
      ...toJson_ComputeRouterInterfaceProps(props),
    };
  }

  /**
   * Defines a "ComputeRouterInterface" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRouterInterfaceProps) {
    super(scope, id, {
      ...ComputeRouterInterface.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRouterInterface.GVK,
      ...toJson_ComputeRouterInterfaceProps(resolved),
    };
  }
}

/**
 * @schema ComputeRouterInterface
 */
export interface ComputeRouterInterfaceProps {
  /**
   * @schema ComputeRouterInterface#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRouterInterface#spec
   */
  readonly spec: ComputeRouterInterfaceSpec;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceProps(obj: ComputeRouterInterfaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRouterInterfaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpec
 */
export interface ComputeRouterInterfaceSpec {
  /**
   * @schema ComputeRouterInterfaceSpec#interconnectAttachmentRef
   */
  readonly interconnectAttachmentRef?: ComputeRouterInterfaceSpecInterconnectAttachmentRef;

  /**
   * Immutable. The IP address and range of the interface. The IP range must be in the RFC3927 link-local IP space. Changing this forces a new interface to be created.
   *
   * @schema ComputeRouterInterfaceSpec#ipRange
   */
  readonly ipRange?: string;

  /**
   * @schema ComputeRouterInterfaceSpec#privateIpAddressRef
   */
  readonly privateIpAddressRef?: ComputeRouterInterfaceSpecPrivateIpAddressRef;

  /**
   * The interface the BGP peer is associated with.
   *
   * @schema ComputeRouterInterfaceSpec#redundantInterfaceRef
   */
  readonly redundantInterfaceRef?: ComputeRouterInterfaceSpecRedundantInterfaceRef;

  /**
   * Immutable. The region this interface's router sits in. If not specified, the project region will be used. Changing this forces a new interface to be created.
   *
   * @schema ComputeRouterInterfaceSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRouterInterfaceSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeRouterInterfaceSpec#routerRef
   */
  readonly routerRef: ComputeRouterInterfaceSpecRouterRef;

  /**
   * @schema ComputeRouterInterfaceSpec#subnetworkRef
   */
  readonly subnetworkRef?: ComputeRouterInterfaceSpecSubnetworkRef;

  /**
   * @schema ComputeRouterInterfaceSpec#vpnTunnelRef
   */
  readonly vpnTunnelRef?: ComputeRouterInterfaceSpecVpnTunnelRef;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpec(obj: ComputeRouterInterfaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interconnectAttachmentRef': toJson_ComputeRouterInterfaceSpecInterconnectAttachmentRef(obj.interconnectAttachmentRef),
    'ipRange': obj.ipRange,
    'privateIpAddressRef': toJson_ComputeRouterInterfaceSpecPrivateIpAddressRef(obj.privateIpAddressRef),
    'redundantInterfaceRef': toJson_ComputeRouterInterfaceSpecRedundantInterfaceRef(obj.redundantInterfaceRef),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'routerRef': toJson_ComputeRouterInterfaceSpecRouterRef(obj.routerRef),
    'subnetworkRef': toJson_ComputeRouterInterfaceSpecSubnetworkRef(obj.subnetworkRef),
    'vpnTunnelRef': toJson_ComputeRouterInterfaceSpecVpnTunnelRef(obj.vpnTunnelRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpecInterconnectAttachmentRef
 */
export interface ComputeRouterInterfaceSpecInterconnectAttachmentRef {
  /**
   * Allowed value: The `name` field of a `ComputeInterconnectAttachment` resource.
   *
   * @schema ComputeRouterInterfaceSpecInterconnectAttachmentRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecInterconnectAttachmentRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecInterconnectAttachmentRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecInterconnectAttachmentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecInterconnectAttachmentRef(obj: ComputeRouterInterfaceSpecInterconnectAttachmentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpecPrivateIpAddressRef
 */
export interface ComputeRouterInterfaceSpecPrivateIpAddressRef {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema ComputeRouterInterfaceSpecPrivateIpAddressRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecPrivateIpAddressRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecPrivateIpAddressRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecPrivateIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecPrivateIpAddressRef(obj: ComputeRouterInterfaceSpecPrivateIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The interface the BGP peer is associated with.
 *
 * @schema ComputeRouterInterfaceSpecRedundantInterfaceRef
 */
export interface ComputeRouterInterfaceSpecRedundantInterfaceRef {
  /**
   * Allowed value: The `name` field of a `ComputeRouterInterface` resource.
   *
   * @schema ComputeRouterInterfaceSpecRedundantInterfaceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecRedundantInterfaceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecRedundantInterfaceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecRedundantInterfaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecRedundantInterfaceRef(obj: ComputeRouterInterfaceSpecRedundantInterfaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpecRouterRef
 */
export interface ComputeRouterInterfaceSpecRouterRef {
  /**
   * Allowed value: The `name` field of a `ComputeRouter` resource.
   *
   * @schema ComputeRouterInterfaceSpecRouterRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecRouterRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecRouterRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecRouterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecRouterRef(obj: ComputeRouterInterfaceSpecRouterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpecSubnetworkRef
 */
export interface ComputeRouterInterfaceSpecSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeRouterInterfaceSpecSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecSubnetworkRef(obj: ComputeRouterInterfaceSpecSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterInterfaceSpecVpnTunnelRef
 */
export interface ComputeRouterInterfaceSpecVpnTunnelRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeVPNTunnel` resource.
   *
   * @schema ComputeRouterInterfaceSpecVpnTunnelRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterInterfaceSpecVpnTunnelRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterInterfaceSpecVpnTunnelRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterInterfaceSpecVpnTunnelRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterInterfaceSpecVpnTunnelRef(obj: ComputeRouterInterfaceSpecVpnTunnelRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRouterNAT
 */
export class ComputeRouterNat extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRouterNAT"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRouterNAT',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRouterNAT".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRouterNatProps): any {
    return {
      ...ComputeRouterNat.GVK,
      ...toJson_ComputeRouterNatProps(props),
    };
  }

  /**
   * Defines a "ComputeRouterNAT" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRouterNatProps) {
    super(scope, id, {
      ...ComputeRouterNat.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRouterNat.GVK,
      ...toJson_ComputeRouterNatProps(resolved),
    };
  }
}

/**
 * @schema ComputeRouterNAT
 */
export interface ComputeRouterNatProps {
  /**
   * @schema ComputeRouterNAT#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRouterNAT#spec
   */
  readonly spec: ComputeRouterNatSpec;

}

/**
 * Converts an object of type 'ComputeRouterNatProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatProps(obj: ComputeRouterNatProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRouterNatSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterNatSpec
 */
export interface ComputeRouterNatSpec {
  /**
   * @schema ComputeRouterNatSpec#drainNatIps
   */
  readonly drainNatIps?: ComputeRouterNatSpecDrainNatIps[];

  /**
   * Enable Dynamic Port Allocation.
   * If minPortsPerVm is set, minPortsPerVm must be set to a power of two greater than or equal to 32.
   * If minPortsPerVm is not set, a minimum of 32 ports will be allocated to a VM from this NAT config.
   * If maxPortsPerVm is set, maxPortsPerVm must be set to a power of two greater than minPortsPerVm.
   * If maxPortsPerVm is not set, a maximum of 65536 ports will be allocated to a VM from this NAT config.
   *
   * Mutually exclusive with enableEndpointIndependentMapping.
   *
   * @schema ComputeRouterNatSpec#enableDynamicPortAllocation
   */
  readonly enableDynamicPortAllocation?: boolean;

  /**
   * Specifies if endpoint independent mapping is enabled. This is enabled by default. For more information
   * see the [official documentation](https://cloud.google.com/nat/docs/overview#specs-rfcs).
   *
   * @schema ComputeRouterNatSpec#enableEndpointIndependentMapping
   */
  readonly enableEndpointIndependentMapping?: boolean;

  /**
   * Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
   *
   * @default 30s if not set.
   * @schema ComputeRouterNatSpec#icmpIdleTimeoutSec
   */
  readonly icmpIdleTimeoutSec?: number;

  /**
   * Configuration for logging on NAT.
   *
   * @schema ComputeRouterNatSpec#logConfig
   */
  readonly logConfig?: ComputeRouterNatSpecLogConfig;

  /**
   * Maximum number of ports allocated to a VM from this NAT.
   * This field can only be set when enableDynamicPortAllocation is enabled.
   *
   * @schema ComputeRouterNatSpec#maxPortsPerVm
   */
  readonly maxPortsPerVm?: number;

  /**
   * Minimum number of ports allocated to a VM from this NAT.
   *
   * @schema ComputeRouterNatSpec#minPortsPerVm
   */
  readonly minPortsPerVm?: number;

  /**
   * How external IPs should be allocated for this NAT. Valid values are
   * 'AUTO_ONLY' for only allowing NAT IPs allocated by Google Cloud
   * Platform, or 'MANUAL_ONLY' for only user-allocated NAT IP addresses. Possible values: ["MANUAL_ONLY", "AUTO_ONLY"].
   *
   * @schema ComputeRouterNatSpec#natIpAllocateOption
   */
  readonly natIpAllocateOption: string;

  /**
   * @schema ComputeRouterNatSpec#natIps
   */
  readonly natIps?: ComputeRouterNatSpecNatIps[];

  /**
   * Immutable. Region where the router and NAT reside.
   *
   * @schema ComputeRouterNatSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRouterNatSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The Cloud Router in which this NAT will be configured.
   *
   * @schema ComputeRouterNatSpec#routerRef
   */
  readonly routerRef: ComputeRouterNatSpecRouterRef;

  /**
   * A list of rules associated with this NAT.
   *
   * @schema ComputeRouterNatSpec#rules
   */
  readonly rules?: ComputeRouterNatSpecRules[];

  /**
   * How NAT should be configured per Subnetwork.
   * If 'ALL_SUBNETWORKS_ALL_IP_RANGES', all of the
   * IP ranges in every Subnetwork are allowed to Nat.
   * If 'ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES', all of the primary IP
   * ranges in every Subnetwork are allowed to Nat.
   * 'LIST_OF_SUBNETWORKS': A list of Subnetworks are allowed to Nat
   * (specified in the field subnetwork below). Note that if this field
   * contains ALL_SUBNETWORKS_ALL_IP_RANGES or
   * ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any
   * other RouterNat section in any Router for this network in this region. Possible values: ["ALL_SUBNETWORKS_ALL_IP_RANGES", "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES", "LIST_OF_SUBNETWORKS"].
   *
   * @schema ComputeRouterNatSpec#sourceSubnetworkIpRangesToNat
   */
  readonly sourceSubnetworkIpRangesToNat: string;

  /**
   * One or more subnetwork NAT configurations. Only used if
   * 'source_subnetwork_ip_ranges_to_nat' is set to 'LIST_OF_SUBNETWORKS'.
   *
   * @schema ComputeRouterNatSpec#subnetwork
   */
  readonly subnetwork?: ComputeRouterNatSpecSubnetwork[];

  /**
   * Timeout (in seconds) for TCP established connections.
   * Defaults to 1200s if not set.
   *
   * @default 1200s if not set.
   * @schema ComputeRouterNatSpec#tcpEstablishedIdleTimeoutSec
   */
  readonly tcpEstablishedIdleTimeoutSec?: number;

  /**
   * Timeout (in seconds) for TCP connections that are in TIME_WAIT state.
   * Defaults to 120s if not set.
   *
   * @default 120s if not set.
   * @schema ComputeRouterNatSpec#tcpTimeWaitTimeoutSec
   */
  readonly tcpTimeWaitTimeoutSec?: number;

  /**
   * Timeout (in seconds) for TCP transitory connections.
   * Defaults to 30s if not set.
   *
   * @default 30s if not set.
   * @schema ComputeRouterNatSpec#tcpTransitoryIdleTimeoutSec
   */
  readonly tcpTransitoryIdleTimeoutSec?: number;

  /**
   * Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
   *
   * @default 30s if not set.
   * @schema ComputeRouterNatSpec#udpIdleTimeoutSec
   */
  readonly udpIdleTimeoutSec?: number;

}

/**
 * Converts an object of type 'ComputeRouterNatSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpec(obj: ComputeRouterNatSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'drainNatIps': obj.drainNatIps?.map(y => toJson_ComputeRouterNatSpecDrainNatIps(y)),
    'enableDynamicPortAllocation': obj.enableDynamicPortAllocation,
    'enableEndpointIndependentMapping': obj.enableEndpointIndependentMapping,
    'icmpIdleTimeoutSec': obj.icmpIdleTimeoutSec,
    'logConfig': toJson_ComputeRouterNatSpecLogConfig(obj.logConfig),
    'maxPortsPerVm': obj.maxPortsPerVm,
    'minPortsPerVm': obj.minPortsPerVm,
    'natIpAllocateOption': obj.natIpAllocateOption,
    'natIps': obj.natIps?.map(y => toJson_ComputeRouterNatSpecNatIps(y)),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'routerRef': toJson_ComputeRouterNatSpecRouterRef(obj.routerRef),
    'rules': obj.rules?.map(y => toJson_ComputeRouterNatSpecRules(y)),
    'sourceSubnetworkIpRangesToNat': obj.sourceSubnetworkIpRangesToNat,
    'subnetwork': obj.subnetwork?.map(y => toJson_ComputeRouterNatSpecSubnetwork(y)),
    'tcpEstablishedIdleTimeoutSec': obj.tcpEstablishedIdleTimeoutSec,
    'tcpTimeWaitTimeoutSec': obj.tcpTimeWaitTimeoutSec,
    'tcpTransitoryIdleTimeoutSec': obj.tcpTransitoryIdleTimeoutSec,
    'udpIdleTimeoutSec': obj.udpIdleTimeoutSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of IP resources to be drained. These IPs must be valid
 * static external IPs that have been assigned to the NAT.
 *
 * @schema ComputeRouterNatSpecDrainNatIps
 */
export interface ComputeRouterNatSpecDrainNatIps {
  /**
   * Allowed value: The `selfLink` field of a `ComputeAddress` resource.
   *
   * @schema ComputeRouterNatSpecDrainNatIps#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecDrainNatIps#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecDrainNatIps#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecDrainNatIps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecDrainNatIps(obj: ComputeRouterNatSpecDrainNatIps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for logging on NAT.
 *
 * @schema ComputeRouterNatSpecLogConfig
 */
export interface ComputeRouterNatSpecLogConfig {
  /**
   * Indicates whether or not to export logs.
   *
   * @schema ComputeRouterNatSpecLogConfig#enable
   */
  readonly enable: boolean;

  /**
   * Specifies the desired filtering of logs on this NAT. Possible values: ["ERRORS_ONLY", "TRANSLATIONS_ONLY", "ALL"].
   *
   * @schema ComputeRouterNatSpecLogConfig#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecLogConfig(obj: ComputeRouterNatSpecLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NAT IPs. Only valid if natIpAllocateOption is set to MANUAL_ONLY.
 *
 * @schema ComputeRouterNatSpecNatIps
 */
export interface ComputeRouterNatSpecNatIps {
  /**
   * Allowed value: The `selfLink` field of a `ComputeAddress` resource.
   *
   * @schema ComputeRouterNatSpecNatIps#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecNatIps#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecNatIps#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecNatIps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecNatIps(obj: ComputeRouterNatSpecNatIps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Cloud Router in which this NAT will be configured.
 *
 * @schema ComputeRouterNatSpecRouterRef
 */
export interface ComputeRouterNatSpecRouterRef {
  /**
   * Allowed value: The `name` field of a `ComputeRouter` resource.
   *
   * @schema ComputeRouterNatSpecRouterRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecRouterRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecRouterRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecRouterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecRouterRef(obj: ComputeRouterNatSpecRouterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterNatSpecRules
 */
export interface ComputeRouterNatSpecRules {
  /**
   * The action to be enforced for traffic that matches this rule.
   *
   * @schema ComputeRouterNatSpecRules#action
   */
  readonly action?: ComputeRouterNatSpecRulesAction;

  /**
   * An optional description of this rule.
   *
   * @schema ComputeRouterNatSpecRules#description
   */
  readonly description?: string;

  /**
   * CEL expression that specifies the match condition that egress traffic from a VM is evaluated against.
   * If it evaluates to true, the corresponding action is enforced.
   *
   * The following examples are valid match expressions for public NAT:
   *
   * "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')"
   *
   * "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'"
   *
   * The following example is a valid match expression for private NAT:
   *
   * "nexthop.hub == 'https://networkconnectivity.googleapis.com/v1alpha1/projects/my-project/global/hub/hub-1'".
   *
   * @schema ComputeRouterNatSpecRules#match
   */
  readonly match: string;

  /**
   * An integer uniquely identifying a rule in the list.
   * The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
   *
   * @schema ComputeRouterNatSpecRules#ruleNumber
   */
  readonly ruleNumber: number;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecRules(obj: ComputeRouterNatSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_ComputeRouterNatSpecRulesAction(obj.action),
    'description': obj.description,
    'match': obj.match,
    'ruleNumber': obj.ruleNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterNatSpecSubnetwork
 */
export interface ComputeRouterNatSpecSubnetwork {
  /**
   * List of the secondary ranges of the subnetwork that are allowed
   * to use NAT. This can be populated only if
   * 'LIST_OF_SECONDARY_IP_RANGES' is one of the values in
   * sourceIpRangesToNat.
   *
   * @schema ComputeRouterNatSpecSubnetwork#secondaryIpRangeNames
   */
  readonly secondaryIpRangeNames?: string[];

  /**
   * List of options for which source IPs in the subnetwork
   * should have NAT enabled. Supported values include:
   * 'ALL_IP_RANGES', 'LIST_OF_SECONDARY_IP_RANGES',
   * 'PRIMARY_IP_RANGE'.
   *
   * @schema ComputeRouterNatSpecSubnetwork#sourceIpRangesToNat
   */
  readonly sourceIpRangesToNat: string[];

  /**
   * The subnetwork to NAT.
   *
   * @schema ComputeRouterNatSpecSubnetwork#subnetworkRef
   */
  readonly subnetworkRef: ComputeRouterNatSpecSubnetworkSubnetworkRef;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecSubnetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecSubnetwork(obj: ComputeRouterNatSpecSubnetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secondaryIpRangeNames': obj.secondaryIpRangeNames?.map(y => y),
    'sourceIpRangesToNat': obj.sourceIpRangesToNat?.map(y => y),
    'subnetworkRef': toJson_ComputeRouterNatSpecSubnetworkSubnetworkRef(obj.subnetworkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The action to be enforced for traffic that matches this rule.
 *
 * @schema ComputeRouterNatSpecRulesAction
 */
export interface ComputeRouterNatSpecRulesAction {
  /**
   * @schema ComputeRouterNatSpecRulesAction#sourceNatActiveIpsRefs
   */
  readonly sourceNatActiveIpsRefs?: ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs[];

  /**
   * @schema ComputeRouterNatSpecRulesAction#sourceNatDrainIpsRefs
   */
  readonly sourceNatDrainIpsRefs?: ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs[];

}

/**
 * Converts an object of type 'ComputeRouterNatSpecRulesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecRulesAction(obj: ComputeRouterNatSpecRulesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sourceNatActiveIpsRefs': obj.sourceNatActiveIpsRefs?.map(y => toJson_ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs(y)),
    'sourceNatDrainIpsRefs': obj.sourceNatDrainIpsRefs?.map(y => toJson_ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The subnetwork to NAT.
 *
 * @schema ComputeRouterNatSpecSubnetworkSubnetworkRef
 */
export interface ComputeRouterNatSpecSubnetworkSubnetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeRouterNatSpecSubnetworkSubnetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecSubnetworkSubnetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecSubnetworkSubnetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecSubnetworkSubnetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecSubnetworkSubnetworkRef(obj: ComputeRouterNatSpecSubnetworkSubnetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of URLs of the IP resources used for this NAT rule. These IP
 * addresses must be valid static external IP addresses assigned to the
 * project. This field is used for public NAT.
 *
 * @schema ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs
 */
export interface ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs {
  /**
   * Allowed value: The `selfLink` field of a `ComputeAddress` resource.
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs(obj: ComputeRouterNatSpecRulesActionSourceNatActiveIpsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of URLs of the IP resources to be drained. These IPs must be
 * valid static external IPs that have been assigned to the NAT. These
 * IPs should be used for updating/patching a NAT rule only. This field
 * is used for public NAT.
 *
 * @schema ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs
 */
export interface ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs {
  /**
   * Allowed value: The `selfLink` field of a `ComputeAddress` resource.
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs(obj: ComputeRouterNatSpecRulesActionSourceNatDrainIpsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeRouterPeer
 */
export class ComputeRouterPeer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeRouterPeer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeRouterPeer',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeRouterPeer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeRouterPeerProps): any {
    return {
      ...ComputeRouterPeer.GVK,
      ...toJson_ComputeRouterPeerProps(props),
    };
  }

  /**
   * Defines a "ComputeRouterPeer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeRouterPeerProps) {
    super(scope, id, {
      ...ComputeRouterPeer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeRouterPeer.GVK,
      ...toJson_ComputeRouterPeerProps(resolved),
    };
  }
}

/**
 * @schema ComputeRouterPeer
 */
export interface ComputeRouterPeerProps {
  /**
   * @schema ComputeRouterPeer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeRouterPeer#spec
   */
  readonly spec: ComputeRouterPeerSpec;

}

/**
 * Converts an object of type 'ComputeRouterPeerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerProps(obj: ComputeRouterPeerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeRouterPeerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterPeerSpec
 */
export interface ComputeRouterPeerSpec {
  /**
   * User-specified flag to indicate which mode to use for advertisement.
   * Valid values of this enum field are: 'DEFAULT', 'CUSTOM' Default value: "DEFAULT" Possible values: ["DEFAULT", "CUSTOM"].
   *
   * @schema ComputeRouterPeerSpec#advertiseMode
   */
  readonly advertiseMode?: string;

  /**
   * User-specified list of prefix groups to advertise in custom
   * mode, which can take one of the following options:
   *
   * * 'ALL_SUBNETS': Advertises all available subnets, including peer VPC subnets.
   * * 'ALL_VPC_SUBNETS': Advertises the router's own VPC subnets.
   * * 'ALL_PEER_VPC_SUBNETS': Advertises peer subnets of the router's VPC network.
   *
   *
   * Note that this field can only be populated if advertiseMode is 'CUSTOM'
   * and overrides the list defined for the router (in the "bgp" message).
   * These groups are advertised in addition to any specified prefixes.
   * Leave this field blank to advertise no custom groups.
   *
   * @schema ComputeRouterPeerSpec#advertisedGroups
   */
  readonly advertisedGroups?: string[];

  /**
   * User-specified list of individual IP ranges to advertise in
   * custom mode. This field can only be populated if advertiseMode
   * is 'CUSTOM' and is advertised to all peers of the router. These IP
   * ranges will be advertised in addition to any specified groups.
   * Leave this field blank to advertise no custom IP ranges.
   *
   * @schema ComputeRouterPeerSpec#advertisedIpRanges
   */
  readonly advertisedIpRanges?: ComputeRouterPeerSpecAdvertisedIpRanges[];

  /**
   * The priority of routes advertised to this BGP peer.
   * Where there is more than one matching route of maximum
   * length, the routes with the lowest priority value win.
   *
   * @schema ComputeRouterPeerSpec#advertisedRoutePriority
   */
  readonly advertisedRoutePriority?: number;

  /**
   * BFD configuration for the BGP peering.
   *
   * @schema ComputeRouterPeerSpec#bfd
   */
  readonly bfd?: ComputeRouterPeerSpecBfd;

  /**
   * The status of the BGP peer connection. If set to false, any active session
   * with the peer is terminated and all associated routing information is removed.
   * If set to true, the peer connection can be established with routing information.
   * The default is true.
   *
   * @schema ComputeRouterPeerSpec#enable
   */
  readonly enable?: boolean;

  /**
   * Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by default.
   *
   * @schema ComputeRouterPeerSpec#enableIpv6
   */
  readonly enableIpv6?: boolean;

  /**
   * IP address of the interface inside Google Cloud Platform.
   * Only IPv4 is supported.
   *
   * @schema ComputeRouterPeerSpec#ipAddress
   */
  readonly ipAddress?: ComputeRouterPeerSpecIpAddress;

  /**
   * IPv6 address of the interface inside Google Cloud Platform.
   * The address must be in the range 2600:2d00:0:2::/64 or 2600:2d00:0:3::/64.
   * If you do not specify the next hop addresses, Google Cloud automatically
   * assigns unused addresses from the 2600:2d00:0:2::/64 or 2600:2d00:0:3::/64 range for you.
   *
   * @schema ComputeRouterPeerSpec#ipv6NexthopAddress
   */
  readonly ipv6NexthopAddress?: string;

  /**
   * Peer BGP Autonomous System Number (ASN).
   * Each BGP interface may use a different value.
   *
   * @schema ComputeRouterPeerSpec#peerAsn
   */
  readonly peerAsn: number;

  /**
   * IP address of the BGP interface outside Google Cloud Platform.
   * Only IPv4 is supported. Required if 'ip_address' is set.
   *
   * @schema ComputeRouterPeerSpec#peerIpAddress
   */
  readonly peerIpAddress?: string;

  /**
   * IPv6 address of the BGP interface outside Google Cloud Platform.
   * The address must be in the range 2600:2d00:0:2::/64 or 2600:2d00:0:3::/64.
   * If you do not specify the next hop addresses, Google Cloud automatically
   * assigns unused addresses from the 2600:2d00:0:2::/64 or 2600:2d00:0:3::/64 range for you.
   *
   * @schema ComputeRouterPeerSpec#peerIpv6NexthopAddress
   */
  readonly peerIpv6NexthopAddress?: string;

  /**
   * Immutable. Region where the router and BgpPeer reside.
   * If it is not provided, the provider region is used.
   *
   * @schema ComputeRouterPeerSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeRouterPeerSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The URI of the VM instance that is used as third-party router
   * appliances such as Next Gen Firewalls, Virtual Routers, or Router
   * Appliances. The VM instance must be located in zones contained in
   * the same region as this Cloud Router. The VM instance is the peer
   * side of the BGP session.
   *
   * @schema ComputeRouterPeerSpec#routerApplianceInstanceRef
   */
  readonly routerApplianceInstanceRef?: ComputeRouterPeerSpecRouterApplianceInstanceRef;

  /**
   * The interface the BGP peer is associated with.
   *
   * @schema ComputeRouterPeerSpec#routerInterfaceRef
   */
  readonly routerInterfaceRef: ComputeRouterPeerSpecRouterInterfaceRef;

  /**
   * The Cloud Router in which this BGP peer will be configured.
   *
   * @schema ComputeRouterPeerSpec#routerRef
   */
  readonly routerRef: ComputeRouterPeerSpecRouterRef;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpec(obj: ComputeRouterPeerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advertiseMode': obj.advertiseMode,
    'advertisedGroups': obj.advertisedGroups?.map(y => y),
    'advertisedIpRanges': obj.advertisedIpRanges?.map(y => toJson_ComputeRouterPeerSpecAdvertisedIpRanges(y)),
    'advertisedRoutePriority': obj.advertisedRoutePriority,
    'bfd': toJson_ComputeRouterPeerSpecBfd(obj.bfd),
    'enable': obj.enable,
    'enableIpv6': obj.enableIpv6,
    'ipAddress': toJson_ComputeRouterPeerSpecIpAddress(obj.ipAddress),
    'ipv6NexthopAddress': obj.ipv6NexthopAddress,
    'peerAsn': obj.peerAsn,
    'peerIpAddress': obj.peerIpAddress,
    'peerIpv6NexthopAddress': obj.peerIpv6NexthopAddress,
    'region': obj.region,
    'resourceID': obj.resourceId,
    'routerApplianceInstanceRef': toJson_ComputeRouterPeerSpecRouterApplianceInstanceRef(obj.routerApplianceInstanceRef),
    'routerInterfaceRef': toJson_ComputeRouterPeerSpecRouterInterfaceRef(obj.routerInterfaceRef),
    'routerRef': toJson_ComputeRouterPeerSpecRouterRef(obj.routerRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeRouterPeerSpecAdvertisedIpRanges
 */
export interface ComputeRouterPeerSpecAdvertisedIpRanges {
  /**
   * User-specified description for the IP range.
   *
   * @schema ComputeRouterPeerSpecAdvertisedIpRanges#description
   */
  readonly description?: string;

  /**
   * The IP range to advertise. The value must be a
   * CIDR-formatted string.
   *
   * @schema ComputeRouterPeerSpecAdvertisedIpRanges#range
   */
  readonly range: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecAdvertisedIpRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecAdvertisedIpRanges(obj: ComputeRouterPeerSpecAdvertisedIpRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BFD configuration for the BGP peering.
 *
 * @schema ComputeRouterPeerSpecBfd
 */
export interface ComputeRouterPeerSpecBfd {
  /**
   * The minimum interval, in milliseconds, between BFD control packets
   * received from the peer router. The actual value is negotiated
   * between the two routers and is equal to the greater of this value
   * and the transmit interval of the other router. If set, this value
   * must be between 1000 and 30000.
   *
   * @schema ComputeRouterPeerSpecBfd#minReceiveInterval
   */
  readonly minReceiveInterval?: number;

  /**
   * The minimum interval, in milliseconds, between BFD control packets
   * transmitted to the peer router. The actual value is negotiated
   * between the two routers and is equal to the greater of this value
   * and the corresponding receive interval of the other router. If set,
   * this value must be between 1000 and 30000.
   *
   * @schema ComputeRouterPeerSpecBfd#minTransmitInterval
   */
  readonly minTransmitInterval?: number;

  /**
   * The number of consecutive BFD packets that must be missed before
   * BFD declares that a peer is unavailable. If set, the value must
   * be a value between 5 and 16.
   *
   * @schema ComputeRouterPeerSpecBfd#multiplier
   */
  readonly multiplier?: number;

  /**
   * The BFD session initialization mode for this BGP peer.
   * If set to 'ACTIVE', the Cloud Router will initiate the BFD session
   * for this BGP peer. If set to 'PASSIVE', the Cloud Router will wait
   * for the peer router to initiate the BFD session for this BGP peer.
   * If set to 'DISABLED', BFD is disabled for this BGP peer. Possible values: ["ACTIVE", "DISABLED", "PASSIVE"].
   *
   * @schema ComputeRouterPeerSpecBfd#sessionInitializationMode
   */
  readonly sessionInitializationMode: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecBfd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecBfd(obj: ComputeRouterPeerSpecBfd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minReceiveInterval': obj.minReceiveInterval,
    'minTransmitInterval': obj.minTransmitInterval,
    'multiplier': obj.multiplier,
    'sessionInitializationMode': obj.sessionInitializationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IP address of the interface inside Google Cloud Platform.
 * Only IPv4 is supported.
 *
 * @schema ComputeRouterPeerSpecIpAddress
 */
export interface ComputeRouterPeerSpecIpAddress {
  /**
   * @schema ComputeRouterPeerSpecIpAddress#external
   */
  readonly external?: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecIpAddress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecIpAddress(obj: ComputeRouterPeerSpecIpAddress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The URI of the VM instance that is used as third-party router
 * appliances such as Next Gen Firewalls, Virtual Routers, or Router
 * Appliances. The VM instance must be located in zones contained in
 * the same region as this Cloud Router. The VM instance is the peer
 * side of the BGP session.
 *
 * @schema ComputeRouterPeerSpecRouterApplianceInstanceRef
 */
export interface ComputeRouterPeerSpecRouterApplianceInstanceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputeRouterPeerSpecRouterApplianceInstanceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterPeerSpecRouterApplianceInstanceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterPeerSpecRouterApplianceInstanceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecRouterApplianceInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecRouterApplianceInstanceRef(obj: ComputeRouterPeerSpecRouterApplianceInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The interface the BGP peer is associated with.
 *
 * @schema ComputeRouterPeerSpecRouterInterfaceRef
 */
export interface ComputeRouterPeerSpecRouterInterfaceRef {
  /**
   * Allowed value: The `name` field of a `ComputeRouterInterface` resource.
   *
   * @schema ComputeRouterPeerSpecRouterInterfaceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterPeerSpecRouterInterfaceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterPeerSpecRouterInterfaceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecRouterInterfaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecRouterInterfaceRef(obj: ComputeRouterPeerSpecRouterInterfaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Cloud Router in which this BGP peer will be configured.
 *
 * @schema ComputeRouterPeerSpecRouterRef
 */
export interface ComputeRouterPeerSpecRouterRef {
  /**
   * Allowed value: The `name` field of a `ComputeRouter` resource.
   *
   * @schema ComputeRouterPeerSpecRouterRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeRouterPeerSpecRouterRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeRouterPeerSpecRouterRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeRouterPeerSpecRouterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeRouterPeerSpecRouterRef(obj: ComputeRouterPeerSpecRouterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSecurityPolicy
 */
export class ComputeSecurityPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSecurityPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSecurityPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSecurityPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSecurityPolicyProps = {}): any {
    return {
      ...ComputeSecurityPolicy.GVK,
      ...toJson_ComputeSecurityPolicyProps(props),
    };
  }

  /**
   * Defines a "ComputeSecurityPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSecurityPolicyProps = {}) {
    super(scope, id, {
      ...ComputeSecurityPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSecurityPolicy.GVK,
      ...toJson_ComputeSecurityPolicyProps(resolved),
    };
  }
}

/**
 * @schema ComputeSecurityPolicy
 */
export interface ComputeSecurityPolicyProps {
  /**
   * @schema ComputeSecurityPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSecurityPolicy#spec
   */
  readonly spec?: ComputeSecurityPolicySpec;

}

/**
 * Converts an object of type 'ComputeSecurityPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicyProps(obj: ComputeSecurityPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSecurityPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpec
 */
export interface ComputeSecurityPolicySpec {
  /**
   * Adaptive Protection Config of this security policy.
   *
   * @schema ComputeSecurityPolicySpec#adaptiveProtectionConfig
   */
  readonly adaptiveProtectionConfig?: ComputeSecurityPolicySpecAdaptiveProtectionConfig;

  /**
   * Advanced Options Config of this security policy.
   *
   * @schema ComputeSecurityPolicySpec#advancedOptionsConfig
   */
  readonly advancedOptionsConfig?: ComputeSecurityPolicySpecAdvancedOptionsConfig;

  /**
   * An optional description of this security policy. Max size is 2048.
   *
   * @schema ComputeSecurityPolicySpec#description
   */
  readonly description?: string;

  /**
   * reCAPTCHA configuration options to be applied for the security policy.
   *
   * @schema ComputeSecurityPolicySpec#recaptchaOptionsConfig
   */
  readonly recaptchaOptionsConfig?: ComputeSecurityPolicySpecRecaptchaOptionsConfig;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeSecurityPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The set of rules that belong to this policy. There must always be a default rule (rule with priority 2147483647 and match "*"). If no rules are provided when creating a security policy, a default rule with action "allow" will be added.
   *
   * @schema ComputeSecurityPolicySpec#rule
   */
  readonly rule?: ComputeSecurityPolicySpecRule[];

  /**
   * The type indicates the intended use of the security policy. CLOUD_ARMOR - Cloud Armor backend security policies can be configured to filter incoming HTTP requests targeting backend services. They filter requests before they hit the origin servers. CLOUD_ARMOR_EDGE - Cloud Armor edge security policies can be configured to filter incoming HTTP requests targeting backend services (including Cloud CDN-enabled) as well as backend buckets (Cloud Storage). They filter requests before the request is served from Google's cache.
   *
   * @schema ComputeSecurityPolicySpec#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpec(obj: ComputeSecurityPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adaptiveProtectionConfig': toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfig(obj.adaptiveProtectionConfig),
    'advancedOptionsConfig': toJson_ComputeSecurityPolicySpecAdvancedOptionsConfig(obj.advancedOptionsConfig),
    'description': obj.description,
    'recaptchaOptionsConfig': toJson_ComputeSecurityPolicySpecRecaptchaOptionsConfig(obj.recaptchaOptionsConfig),
    'resourceID': obj.resourceId,
    'rule': obj.rule?.map(y => toJson_ComputeSecurityPolicySpecRule(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Adaptive Protection Config of this security policy.
 *
 * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfig
 */
export interface ComputeSecurityPolicySpecAdaptiveProtectionConfig {
  /**
   * Auto Deploy Config of this security policy.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfig#autoDeployConfig
   */
  readonly autoDeployConfig?: ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig;

  /**
   * Layer 7 DDoS Defense Config of this security policy.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfig#layer7DdosDefenseConfig
   */
  readonly layer7DdosDefenseConfig?: ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecAdaptiveProtectionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfig(obj: ComputeSecurityPolicySpecAdaptiveProtectionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoDeployConfig': toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig(obj.autoDeployConfig),
    'layer7DdosDefenseConfig': toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig(obj.layer7DdosDefenseConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Advanced Options Config of this security policy.
 *
 * @schema ComputeSecurityPolicySpecAdvancedOptionsConfig
 */
export interface ComputeSecurityPolicySpecAdvancedOptionsConfig {
  /**
   * Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
   *
   * @schema ComputeSecurityPolicySpecAdvancedOptionsConfig#jsonCustomConfig
   */
  readonly jsonCustomConfig?: ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig;

  /**
   * JSON body parsing. Supported values include: "DISABLED", "STANDARD".
   *
   * @schema ComputeSecurityPolicySpecAdvancedOptionsConfig#jsonParsing
   */
  readonly jsonParsing?: string;

  /**
   * Logging level. Supported values include: "NORMAL", "VERBOSE".
   *
   * @schema ComputeSecurityPolicySpecAdvancedOptionsConfig#logLevel
   */
  readonly logLevel?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecAdvancedOptionsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecAdvancedOptionsConfig(obj: ComputeSecurityPolicySpecAdvancedOptionsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonCustomConfig': toJson_ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig(obj.jsonCustomConfig),
    'jsonParsing': obj.jsonParsing,
    'logLevel': obj.logLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * reCAPTCHA configuration options to be applied for the security policy.
 *
 * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfig
 */
export interface ComputeSecurityPolicySpecRecaptchaOptionsConfig {
  /**
   * A field to supply a reCAPTCHA site key to be used for all the rules
   * using the redirect action with the type of GOOGLE_RECAPTCHA under
   * the security policy. The specified site key needs to be created from
   * the reCAPTCHA API. The user is responsible for the validity of the
   * specified site key. If not specified, a Google-managed site key is
   * used.
   *
   * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfig#redirectSiteKeyRef
   */
  readonly redirectSiteKeyRef: ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRecaptchaOptionsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRecaptchaOptionsConfig(obj: ComputeSecurityPolicySpecRecaptchaOptionsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'redirectSiteKeyRef': toJson_ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef(obj.redirectSiteKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRule
 */
export interface ComputeSecurityPolicySpecRule {
  /**
   * Action to take when match matches the request.
   *
   * @schema ComputeSecurityPolicySpecRule#action
   */
  readonly action: string;

  /**
   * An optional description of this rule. Max size is 64.
   *
   * @schema ComputeSecurityPolicySpecRule#description
   */
  readonly description?: string;

  /**
   * Additional actions that are performed on headers.
   *
   * @schema ComputeSecurityPolicySpecRule#headerAction
   */
  readonly headerAction?: ComputeSecurityPolicySpecRuleHeaderAction;

  /**
   * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding action is enforced.
   *
   * @schema ComputeSecurityPolicySpecRule#match
   */
  readonly match: ComputeSecurityPolicySpecRuleMatch;

  /**
   * Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
   *
   * @schema ComputeSecurityPolicySpecRule#preconfiguredWafConfig
   */
  readonly preconfiguredWafConfig?: ComputeSecurityPolicySpecRulePreconfiguredWafConfig;

  /**
   * When set to true, the action specified above is not enforced. Stackdriver logs for requests that trigger a preview action are annotated as such.
   *
   * @schema ComputeSecurityPolicySpecRule#preview
   */
  readonly preview?: boolean;

  /**
   * An unique positive integer indicating the priority of evaluation for a rule. Rules are evaluated from highest priority (lowest numerically) to lowest priority (highest numerically) in order.
   *
   * @schema ComputeSecurityPolicySpecRule#priority
   */
  readonly priority: number;

  /**
   * Rate limit threshold for this security policy. Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
   *
   * @schema ComputeSecurityPolicySpecRule#rateLimitOptions
   */
  readonly rateLimitOptions?: ComputeSecurityPolicySpecRuleRateLimitOptions;

  /**
   * Parameters defining the redirect action. Cannot be specified for any other actions.
   *
   * @schema ComputeSecurityPolicySpecRule#redirectOptions
   */
  readonly redirectOptions?: ComputeSecurityPolicySpecRuleRedirectOptions;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRule(obj: ComputeSecurityPolicySpecRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'headerAction': toJson_ComputeSecurityPolicySpecRuleHeaderAction(obj.headerAction),
    'match': toJson_ComputeSecurityPolicySpecRuleMatch(obj.match),
    'preconfiguredWafConfig': toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfig(obj.preconfiguredWafConfig),
    'preview': obj.preview,
    'priority': obj.priority,
    'rateLimitOptions': toJson_ComputeSecurityPolicySpecRuleRateLimitOptions(obj.rateLimitOptions),
    'redirectOptions': toJson_ComputeSecurityPolicySpecRuleRedirectOptions(obj.redirectOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auto Deploy Config of this security policy.
 *
 * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig
 */
export interface ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig {
  /**
   * Rules are only automatically deployed for alerts on potential attacks with confidence scores greater than this threshold.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig#confidenceThreshold
   */
  readonly confidenceThreshold?: number;

  /**
   * Google Cloud Armor stops applying the action in the automatically deployed rule to an identified attacker after this duration. The rule continues to operate against new requests.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig#expirationSec
   */
  readonly expirationSec?: number;

  /**
   * Rules are only automatically deployed when the estimated impact to baseline traffic from the suggested mitigation is below this threshold.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig#impactedBaselineThreshold
   */
  readonly impactedBaselineThreshold?: number;

  /**
   * Identifies new attackers only when the load to the backend service that is under attack exceeds this threshold.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig#loadThreshold
   */
  readonly loadThreshold?: number;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig(obj: ComputeSecurityPolicySpecAdaptiveProtectionConfigAutoDeployConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confidenceThreshold': obj.confidenceThreshold,
    'expirationSec': obj.expirationSec,
    'impactedBaselineThreshold': obj.impactedBaselineThreshold,
    'loadThreshold': obj.loadThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Layer 7 DDoS Defense Config of this security policy.
 *
 * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig
 */
export interface ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig {
  /**
   * If set to true, enables CAAP for L7 DDoS detection.
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig#enable
   */
  readonly enable?: boolean;

  /**
   * Rule visibility. Supported values include: "STANDARD", "PREMIUM".
   *
   * @schema ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig#ruleVisibility
   */
  readonly ruleVisibility?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig(obj: ComputeSecurityPolicySpecAdaptiveProtectionConfigLayer7DdosDefenseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'ruleVisibility': obj.ruleVisibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Custom configuration to apply the JSON parsing. Only applicable when JSON parsing is set to STANDARD.
 *
 * @schema ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig
 */
export interface ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig {
  /**
   * A list of custom Content-Type header values to apply the JSON parsing.
   *
   * @schema ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig#contentTypes
   */
  readonly contentTypes: string[];

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig(obj: ComputeSecurityPolicySpecAdvancedOptionsConfigJsonCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentTypes': obj.contentTypes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A field to supply a reCAPTCHA site key to be used for all the rules
 * using the redirect action with the type of GOOGLE_RECAPTCHA under
 * the security policy. The specified site key needs to be created from
 * the reCAPTCHA API. The user is responsible for the validity of the
 * specified site key. If not specified, a Google-managed site key is
 * used.
 *
 * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef
 */
export interface ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef {
  /**
   * Allowed value: The `name` field of a `RecaptchaEnterpriseKey` resource.
   *
   * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef(obj: ComputeSecurityPolicySpecRecaptchaOptionsConfigRedirectSiteKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional actions that are performed on headers.
 *
 * @schema ComputeSecurityPolicySpecRuleHeaderAction
 */
export interface ComputeSecurityPolicySpecRuleHeaderAction {
  /**
   * The list of request headers to add or overwrite if they're already present.
   *
   * @schema ComputeSecurityPolicySpecRuleHeaderAction#requestHeadersToAdds
   */
  readonly requestHeadersToAdds: ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds[];

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleHeaderAction(obj: ComputeSecurityPolicySpecRuleHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdds': obj.requestHeadersToAdds?.map(y => toJson_ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding action is enforced.
 *
 * @schema ComputeSecurityPolicySpecRuleMatch
 */
export interface ComputeSecurityPolicySpecRuleMatch {
  /**
   * The configuration options available when specifying versioned_expr. This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
   *
   * @schema ComputeSecurityPolicySpecRuleMatch#config
   */
  readonly config?: ComputeSecurityPolicySpecRuleMatchConfig;

  /**
   * User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
   *
   * @schema ComputeSecurityPolicySpecRuleMatch#expr
   */
  readonly expr?: ComputeSecurityPolicySpecRuleMatchExpr;

  /**
   * Predefined rule expression. If this field is specified, config must also be specified. Available options:   SRC_IPS_V1: Must specify the corresponding src_ip_ranges field in config.
   *
   * @schema ComputeSecurityPolicySpecRuleMatch#versionedExpr
   */
  readonly versionedExpr?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleMatch(obj: ComputeSecurityPolicySpecRuleMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': toJson_ComputeSecurityPolicySpecRuleMatchConfig(obj.config),
    'expr': toJson_ComputeSecurityPolicySpecRuleMatchExpr(obj.expr),
    'versionedExpr': obj.versionedExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preconfigured WAF configuration to be applied for the rule. If the rule does not evaluate preconfigured WAF rules, i.e., if evaluatePreconfiguredWaf() is not used, this field will have no effect.
 *
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfig
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfig {
  /**
   * An exclusion to apply during preconfigured WAF evaluation.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfig#exclusion
   */
  readonly exclusion?: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion[];

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfig(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusion': obj.exclusion?.map(y => toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rate limit threshold for this security policy. Must be specified if the action is "rate_based_ban" or "throttle". Cannot be specified for any other actions.
 *
 * @schema ComputeSecurityPolicySpecRuleRateLimitOptions
 */
export interface ComputeSecurityPolicySpecRuleRateLimitOptions {
  /**
   * Can only be specified if the action for the rule is "rate_based_ban". If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#banDurationSec
   */
  readonly banDurationSec?: number;

  /**
   * Can only be specified if the action for the rule is "rate_based_ban". If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#banThreshold
   */
  readonly banThreshold?: ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold;

  /**
   * Action to take for requests that are under the configured rate limit threshold. Valid option is "allow" only.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#conformAction
   */
  readonly conformAction: string;

  /**
   * Determines the key to enforce the rateLimitThreshold on.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#enforceOnKey
   */
  readonly enforceOnKey?: string;

  /**
   * Immutable. Enforce On Key Config of this security policy.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#enforceOnKeyConfigs
   */
  readonly enforceOnKeyConfigs?: ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs[];

  /**
   * Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#enforceOnKeyName
   */
  readonly enforceOnKeyName?: string;

  /**
   * Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint. Valid options are "deny()" where valid values for status are 403, 404, 429, and 502, and "redirect" where the redirect parameters come from exceedRedirectOptions below.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#exceedAction
   */
  readonly exceedAction: string;

  /**
   * Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#exceedRedirectOptions
   */
  readonly exceedRedirectOptions?: ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions;

  /**
   * Threshold at which to begin ratelimiting.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptions#rateLimitThreshold
   */
  readonly rateLimitThreshold: ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRateLimitOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRateLimitOptions(obj: ComputeSecurityPolicySpecRuleRateLimitOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'banDurationSec': obj.banDurationSec,
    'banThreshold': toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold(obj.banThreshold),
    'conformAction': obj.conformAction,
    'enforceOnKey': obj.enforceOnKey,
    'enforceOnKeyConfigs': obj.enforceOnKeyConfigs?.map(y => toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs(y)),
    'enforceOnKeyName': obj.enforceOnKeyName,
    'exceedAction': obj.exceedAction,
    'exceedRedirectOptions': toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions(obj.exceedRedirectOptions),
    'rateLimitThreshold': toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold(obj.rateLimitThreshold),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters defining the redirect action. Cannot be specified for any other actions.
 *
 * @schema ComputeSecurityPolicySpecRuleRedirectOptions
 */
export interface ComputeSecurityPolicySpecRuleRedirectOptions {
  /**
   * Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
   *
   * @schema ComputeSecurityPolicySpecRuleRedirectOptions#target
   */
  readonly target?: string;

  /**
   * Type of the redirect action. Available options: EXTERNAL_302: Must specify the corresponding target field in config. GOOGLE_RECAPTCHA: Cannot specify target field in config.
   *
   * @schema ComputeSecurityPolicySpecRuleRedirectOptions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRedirectOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRedirectOptions(obj: ComputeSecurityPolicySpecRuleRedirectOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'target': obj.target,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds
 */
export interface ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds {
  /**
   * The name of the header to set.
   *
   * @schema ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds#headerName
   */
  readonly headerName: string;

  /**
   * The value to set the named header to.
   *
   * @schema ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds#headerValue
   */
  readonly headerValue?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds(obj: ComputeSecurityPolicySpecRuleHeaderActionRequestHeadersToAdds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration options available when specifying versioned_expr. This field must be specified if versioned_expr is specified and cannot be specified if versioned_expr is not specified.
 *
 * @schema ComputeSecurityPolicySpecRuleMatchConfig
 */
export interface ComputeSecurityPolicySpecRuleMatchConfig {
  /**
   * Set of IP addresses or ranges (IPV4 or IPV6) in CIDR notation to match against inbound traffic. There is a limit of 10 IP ranges per rule. A value of '*' matches all IPs (can be used to override the default behavior).
   *
   * @schema ComputeSecurityPolicySpecRuleMatchConfig#srcIpRanges
   */
  readonly srcIpRanges: string[];

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleMatchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleMatchConfig(obj: ComputeSecurityPolicySpecRuleMatchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'srcIpRanges': obj.srcIpRanges?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * User defined CEVAL expression. A CEVAL expression is used to specify match criteria such as origin.ip, source.region_code and contents in the request header.
 *
 * @schema ComputeSecurityPolicySpecRuleMatchExpr
 */
export interface ComputeSecurityPolicySpecRuleMatchExpr {
  /**
   * Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
   *
   * @schema ComputeSecurityPolicySpecRuleMatchExpr#expression
   */
  readonly expression: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleMatchExpr' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleMatchExpr(obj: ComputeSecurityPolicySpecRuleMatchExpr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion {
  /**
   * Request cookie whose value will be excluded from inspection during preconfigured WAF evaluation.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#requestCookie
   */
  readonly requestCookie?: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie[];

  /**
   * Request header whose value will be excluded from inspection during preconfigured WAF evaluation.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#requestHeader
   */
  readonly requestHeader?: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader[];

  /**
   * Request query parameter whose value will be excluded from inspection during preconfigured WAF evaluation.  Note that the parameter can be in the query string or in the POST body.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#requestQueryParam
   */
  readonly requestQueryParam?: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam[];

  /**
   * Request URI from the request line to be excluded from inspection during preconfigured WAF evaluation. When specifying this field, the query or fragment part should be excluded.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#requestUri
   */
  readonly requestUri?: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri[];

  /**
   * A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion. If omitted, it refers to all the rule IDs under the WAF rule set.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#targetRuleIds
   */
  readonly targetRuleIds?: string[];

  /**
   * Target WAF rule set to apply the preconfigured WAF exclusion.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion#targetRuleSet
   */
  readonly targetRuleSet: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestCookie': obj.requestCookie?.map(y => toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie(y)),
    'requestHeader': obj.requestHeader?.map(y => toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader(y)),
    'requestQueryParam': obj.requestQueryParam?.map(y => toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam(y)),
    'requestUri': obj.requestUri?.map(y => toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri(y)),
    'targetRuleIds': obj.targetRuleIds?.map(y => y),
    'targetRuleSet': obj.targetRuleSet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Can only be specified if the action for the rule is "rate_based_ban". If specified, the key will be banned for the configured 'banDurationSec' when the number of requests that exceed the 'rateLimitThreshold' also exceed this 'banThreshold'.
 *
 * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold
 */
export interface ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold {
  /**
   * Number of HTTP(S) requests for calculating the threshold.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold#count
   */
  readonly count: number;

  /**
   * Interval over which the threshold is computed.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold#intervalSec
   */
  readonly intervalSec: number;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold(obj: ComputeSecurityPolicySpecRuleRateLimitOptionsBanThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'intervalSec': obj.intervalSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs
 */
export interface ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs {
  /**
   * Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs#enforceOnKeyName
   */
  readonly enforceOnKeyName?: string;

  /**
   * Determines the key to enforce the rate_limit_threshold on.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs#enforceOnKeyType
   */
  readonly enforceOnKeyType?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs(obj: ComputeSecurityPolicySpecRuleRateLimitOptionsEnforceOnKeyConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforceOnKeyName': obj.enforceOnKeyName,
    'enforceOnKeyType': obj.enforceOnKeyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters defining the redirect action that is used as the exceed action. Cannot be specified if the exceed action is not redirect.
 *
 * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions
 */
export interface ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions {
  /**
   * Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions#target
   */
  readonly target?: string;

  /**
   * Type of the redirect action.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions(obj: ComputeSecurityPolicySpecRuleRateLimitOptionsExceedRedirectOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'target': obj.target,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Threshold at which to begin ratelimiting.
 *
 * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold
 */
export interface ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold {
  /**
   * Number of HTTP(S) requests for calculating the threshold.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold#count
   */
  readonly count: number;

  /**
   * Interval over which the threshold is computed.
   *
   * @schema ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold#intervalSec
   */
  readonly intervalSec: number;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold(obj: ComputeSecurityPolicySpecRuleRateLimitOptionsRateLimitThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'intervalSec': obj.intervalSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie {
  /**
   * You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie#operator
   */
  readonly operator: string;

  /**
   * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader {
  /**
   * You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader#operator
   */
  readonly operator: string;

  /**
   * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam {
  /**
   * You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam#operator
   */
  readonly operator: string;

  /**
   * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestQueryParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri
 */
export interface ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri {
  /**
   * You can specify an exact match or a partial match by using a field operator and a field value. Available options: EQUALS: The operator matches if the field value equals the specified value. STARTS_WITH: The operator matches if the field value starts with the specified value. ENDS_WITH: The operator matches if the field value ends with the specified value. CONTAINS: The operator matches if the field value contains the specified value. EQUALS_ANY: The operator matches if the field value is any value.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri#operator
   */
  readonly operator: string;

  /**
   * A request field matching the specified value will be excluded from inspection during preconfigured WAF evaluation. The field value must be given if the field operator is not EQUALS_ANY, and cannot be given if the field operator is EQUALS_ANY.
   *
   * @schema ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri(obj: ComputeSecurityPolicySpecRulePreconfiguredWafConfigExclusionRequestUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeServiceAttachment
 */
export class ComputeServiceAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeServiceAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeServiceAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeServiceAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeServiceAttachmentProps): any {
    return {
      ...ComputeServiceAttachment.GVK,
      ...toJson_ComputeServiceAttachmentProps(props),
    };
  }

  /**
   * Defines a "ComputeServiceAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeServiceAttachmentProps) {
    super(scope, id, {
      ...ComputeServiceAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeServiceAttachment.GVK,
      ...toJson_ComputeServiceAttachmentProps(resolved),
    };
  }
}

/**
 * @schema ComputeServiceAttachment
 */
export interface ComputeServiceAttachmentProps {
  /**
   * @schema ComputeServiceAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeServiceAttachment#spec
   */
  readonly spec: ComputeServiceAttachmentSpec;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentProps(obj: ComputeServiceAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeServiceAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeServiceAttachmentSpec
 */
export interface ComputeServiceAttachmentSpec {
  /**
   * The connection preference of service attachment. The value can be set to `ACCEPT_AUTOMATIC`. An `ACCEPT_AUTOMATIC` service attachment is one that always accepts the connection from consumer forwarding rules. Possible values: CONNECTION_PREFERENCE_UNSPECIFIED, ACCEPT_AUTOMATIC, ACCEPT_MANUAL
   *
   * @schema ComputeServiceAttachmentSpec#connectionPreference
   */
  readonly connectionPreference: string;

  /**
   * Projects that are allowed to connect to this service attachment.
   *
   * @schema ComputeServiceAttachmentSpec#consumerAcceptLists
   */
  readonly consumerAcceptLists?: ComputeServiceAttachmentSpecConsumerAcceptLists[];

  /**
   * @schema ComputeServiceAttachmentSpec#consumerRejectLists
   */
  readonly consumerRejectLists?: ComputeServiceAttachmentSpecConsumerRejectLists[];

  /**
   * An optional description of this resource. Provide this property when you create the resource.
   *
   * @schema ComputeServiceAttachmentSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. If true, enable the proxy protocol which is for supplying client TCP/IP address data in TCP connections that traverse proxies on their way to destination servers.
   *
   * @schema ComputeServiceAttachmentSpec#enableProxyProtocol
   */
  readonly enableProxyProtocol?: boolean;

  /**
   * Immutable. The location for the resource
   *
   * @schema ComputeServiceAttachmentSpec#location
   */
  readonly location: string;

  /**
   * @schema ComputeServiceAttachmentSpec#natSubnets
   */
  readonly natSubnets: ComputeServiceAttachmentSpecNatSubnets[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema ComputeServiceAttachmentSpec#projectRef
   */
  readonly projectRef: ComputeServiceAttachmentSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeServiceAttachmentSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable.
   *
   * @schema ComputeServiceAttachmentSpec#targetServiceRef
   */
  readonly targetServiceRef: ComputeServiceAttachmentSpecTargetServiceRef;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpec(obj: ComputeServiceAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPreference': obj.connectionPreference,
    'consumerAcceptLists': obj.consumerAcceptLists?.map(y => toJson_ComputeServiceAttachmentSpecConsumerAcceptLists(y)),
    'consumerRejectLists': obj.consumerRejectLists?.map(y => toJson_ComputeServiceAttachmentSpecConsumerRejectLists(y)),
    'description': obj.description,
    'enableProxyProtocol': obj.enableProxyProtocol,
    'location': obj.location,
    'natSubnets': obj.natSubnets?.map(y => toJson_ComputeServiceAttachmentSpecNatSubnets(y)),
    'projectRef': toJson_ComputeServiceAttachmentSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'targetServiceRef': toJson_ComputeServiceAttachmentSpecTargetServiceRef(obj.targetServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeServiceAttachmentSpecConsumerAcceptLists
 */
export interface ComputeServiceAttachmentSpecConsumerAcceptLists {
  /**
   * The value of the limit to set.
   *
   * @schema ComputeServiceAttachmentSpecConsumerAcceptLists#connectionLimit
   */
  readonly connectionLimit?: number;

  /**
   * @schema ComputeServiceAttachmentSpecConsumerAcceptLists#projectRef
   */
  readonly projectRef: ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecConsumerAcceptLists' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecConsumerAcceptLists(obj: ComputeServiceAttachmentSpecConsumerAcceptLists | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionLimit': obj.connectionLimit,
    'projectRef': toJson_ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef(obj.projectRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeServiceAttachmentSpecConsumerRejectLists
 */
export interface ComputeServiceAttachmentSpecConsumerRejectLists {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema ComputeServiceAttachmentSpecConsumerRejectLists#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeServiceAttachmentSpecConsumerRejectLists#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeServiceAttachmentSpecConsumerRejectLists#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecConsumerRejectLists' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecConsumerRejectLists(obj: ComputeServiceAttachmentSpecConsumerRejectLists | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeServiceAttachmentSpecNatSubnets
 */
export interface ComputeServiceAttachmentSpecNatSubnets {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSubnetwork` resource.
   *
   * @schema ComputeServiceAttachmentSpecNatSubnets#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeServiceAttachmentSpecNatSubnets#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeServiceAttachmentSpecNatSubnets#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecNatSubnets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecNatSubnets(obj: ComputeServiceAttachmentSpecNatSubnets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema ComputeServiceAttachmentSpecProjectRef
 */
export interface ComputeServiceAttachmentSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema ComputeServiceAttachmentSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeServiceAttachmentSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeServiceAttachmentSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecProjectRef(obj: ComputeServiceAttachmentSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema ComputeServiceAttachmentSpecTargetServiceRef
 */
export interface ComputeServiceAttachmentSpecTargetServiceRef {
  /**
   * The URL of a service serving the endpoint identified by this service attachment.
   *
   * Allowed value: The `selfLink` field of a `ComputeForwardingRule` resource.
   *
   * @schema ComputeServiceAttachmentSpecTargetServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeServiceAttachmentSpecTargetServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeServiceAttachmentSpecTargetServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecTargetServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecTargetServiceRef(obj: ComputeServiceAttachmentSpecTargetServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef
 */
export interface ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef {
  /**
   * The project id or number for the project to set the limit for.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef(obj: ComputeServiceAttachmentSpecConsumerAcceptListsProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSharedVPCHostProject
 */
export class ComputeSharedVpcHostProject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSharedVPCHostProject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSharedVPCHostProject',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSharedVPCHostProject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSharedVpcHostProjectProps = {}): any {
    return {
      ...ComputeSharedVpcHostProject.GVK,
      ...toJson_ComputeSharedVpcHostProjectProps(props),
    };
  }

  /**
   * Defines a "ComputeSharedVPCHostProject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSharedVpcHostProjectProps = {}) {
    super(scope, id, {
      ...ComputeSharedVpcHostProject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSharedVpcHostProject.GVK,
      ...toJson_ComputeSharedVpcHostProjectProps(resolved),
    };
  }
}

/**
 * @schema ComputeSharedVPCHostProject
 */
export interface ComputeSharedVpcHostProjectProps {
  /**
   * @schema ComputeSharedVPCHostProject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

}

/**
 * Converts an object of type 'ComputeSharedVpcHostProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSharedVpcHostProjectProps(obj: ComputeSharedVpcHostProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSharedVPCServiceProject
 */
export class ComputeSharedVpcServiceProject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSharedVPCServiceProject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSharedVPCServiceProject',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSharedVPCServiceProject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSharedVpcServiceProjectProps): any {
    return {
      ...ComputeSharedVpcServiceProject.GVK,
      ...toJson_ComputeSharedVpcServiceProjectProps(props),
    };
  }

  /**
   * Defines a "ComputeSharedVPCServiceProject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSharedVpcServiceProjectProps) {
    super(scope, id, {
      ...ComputeSharedVpcServiceProject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSharedVpcServiceProject.GVK,
      ...toJson_ComputeSharedVpcServiceProjectProps(resolved),
    };
  }
}

/**
 * @schema ComputeSharedVPCServiceProject
 */
export interface ComputeSharedVpcServiceProjectProps {
  /**
   * @schema ComputeSharedVPCServiceProject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSharedVPCServiceProject#spec
   */
  readonly spec: ComputeSharedVpcServiceProjectSpec;

}

/**
 * Converts an object of type 'ComputeSharedVpcServiceProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSharedVpcServiceProjectProps(obj: ComputeSharedVpcServiceProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSharedVpcServiceProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSharedVpcServiceProjectSpec
 */
export interface ComputeSharedVpcServiceProjectSpec {
  /**
   * The deletion policy for the shared VPC service. Setting ABANDON allows the resource
   * to be abandoned rather than deleted. Possible values are: "ABANDON".
   *
   * @schema ComputeSharedVpcServiceProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: string;

  /**
   * @schema ComputeSharedVpcServiceProjectSpec#projectRef
   */
  readonly projectRef: ComputeSharedVpcServiceProjectSpecProjectRef;

}

/**
 * Converts an object of type 'ComputeSharedVpcServiceProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSharedVpcServiceProjectSpec(obj: ComputeSharedVpcServiceProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'projectRef': toJson_ComputeSharedVpcServiceProjectSpecProjectRef(obj.projectRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSharedVpcServiceProjectSpecProjectRef
 */
export interface ComputeSharedVpcServiceProjectSpecProjectRef {
  /**
   * Allowed value: The `name` field of a `Project` resource.
   *
   * @schema ComputeSharedVpcServiceProjectSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSharedVpcServiceProjectSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSharedVpcServiceProjectSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSharedVpcServiceProjectSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSharedVpcServiceProjectSpecProjectRef(obj: ComputeSharedVpcServiceProjectSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSnapshot
 */
export class ComputeSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSnapshotProps): any {
    return {
      ...ComputeSnapshot.GVK,
      ...toJson_ComputeSnapshotProps(props),
    };
  }

  /**
   * Defines a "ComputeSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSnapshotProps) {
    super(scope, id, {
      ...ComputeSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSnapshot.GVK,
      ...toJson_ComputeSnapshotProps(resolved),
    };
  }
}

/**
 * @schema ComputeSnapshot
 */
export interface ComputeSnapshotProps {
  /**
   * @schema ComputeSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSnapshot#spec
   */
  readonly spec: ComputeSnapshotSpec;

}

/**
 * Converts an object of type 'ComputeSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotProps(obj: ComputeSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSnapshotSpec
 */
export interface ComputeSnapshotSpec {
  /**
   * Immutable. Creates the new snapshot in the snapshot chain labeled with the
   * specified name. The chain name must be 1-63 characters long and
   * comply with RFC1035. This is an uncommon option only for advanced
   * service owners who needs to create separate snapshot chains, for
   * example, for chargeback tracking.  When you describe your snapshot
   * resource, this field is visible only if it has a non-empty value.
   *
   * @schema ComputeSnapshotSpec#chainName
   */
  readonly chainName?: string;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeSnapshotSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeSnapshotSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Encrypts the snapshot using a customer-supplied encryption key.
   *
   * After you encrypt a snapshot using a customer-supplied key, you must
   * provide the same key if you use the snapshot later. For example, you
   * must provide the encryption key when you create a disk from the
   * encrypted snapshot in a future request.
   *
   * Customer-supplied encryption keys do not protect access to metadata of
   * the snapshot.
   *
   * If you do not provide an encryption key when creating the snapshot,
   * then the snapshot will be encrypted using an automatically generated
   * key and you do not need to provide a key to use the snapshot later.
   *
   * @schema ComputeSnapshotSpec#snapshotEncryptionKey
   */
  readonly snapshotEncryptionKey?: ComputeSnapshotSpecSnapshotEncryptionKey;

  /**
   * Immutable. The customer-supplied encryption key of the source snapshot. Required
   * if the source snapshot is protected by a customer-supplied encryption
   * key.
   *
   * @schema ComputeSnapshotSpec#sourceDiskEncryptionKey
   */
  readonly sourceDiskEncryptionKey?: ComputeSnapshotSpecSourceDiskEncryptionKey;

  /**
   * A reference to the disk used to create this snapshot.
   *
   * @schema ComputeSnapshotSpec#sourceDiskRef
   */
  readonly sourceDiskRef: ComputeSnapshotSpecSourceDiskRef;

  /**
   * Immutable. Cloud Storage bucket storage location of the snapshot (regional or multi-regional).
   *
   * @schema ComputeSnapshotSpec#storageLocations
   */
  readonly storageLocations?: string[];

  /**
   * Immutable. A reference to the zone where the disk is hosted.
   *
   * @schema ComputeSnapshotSpec#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpec(obj: ComputeSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chainName': obj.chainName,
    'description': obj.description,
    'resourceID': obj.resourceId,
    'snapshotEncryptionKey': toJson_ComputeSnapshotSpecSnapshotEncryptionKey(obj.snapshotEncryptionKey),
    'sourceDiskEncryptionKey': toJson_ComputeSnapshotSpecSourceDiskEncryptionKey(obj.sourceDiskEncryptionKey),
    'sourceDiskRef': toJson_ComputeSnapshotSpecSourceDiskRef(obj.sourceDiskRef),
    'storageLocations': obj.storageLocations?.map(y => y),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Encrypts the snapshot using a customer-supplied encryption key.
 *
 * After you encrypt a snapshot using a customer-supplied key, you must
 * provide the same key if you use the snapshot later. For example, you
 * must provide the encryption key when you create a disk from the
 * encrypted snapshot in a future request.
 *
 * Customer-supplied encryption keys do not protect access to metadata of
 * the snapshot.
 *
 * If you do not provide an encryption key when creating the snapshot,
 * then the snapshot will be encrypted using an automatically generated
 * key and you do not need to provide a key to use the snapshot later.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKey
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKey {
  /**
   * The encryption key that is stored in Google Cloud KMS.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKey#kmsKeyRef
   */
  readonly kmsKeyRef?: ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef;

  /**
   * The service account used for the encryption request for the given KMS key.
   * If absent, the Compute Engine Service Agent service account is used.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef;

  /**
   * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
   * RFC 4648 base64 to either encrypt or decrypt this resource.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKey#rawKey
   */
  readonly rawKey?: ComputeSnapshotSpecSnapshotEncryptionKeyRawKey;

  /**
   * The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
   * encryption key that protects this resource.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKey#sha256
   */
  readonly sha256?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKey(obj: ComputeSnapshotSpecSnapshotEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyRef': toJson_ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef(obj.kmsKeyRef),
    'kmsKeyServiceAccountRef': toJson_ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
    'rawKey': toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKey(obj.rawKey),
    'sha256': obj.sha256,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The customer-supplied encryption key of the source snapshot. Required
 * if the source snapshot is protected by a customer-supplied encryption
 * key.
 *
 * @schema ComputeSnapshotSpecSourceDiskEncryptionKey
 */
export interface ComputeSnapshotSpecSourceDiskEncryptionKey {
  /**
   * The service account used for the encryption request for the given KMS key.
   * If absent, the Compute Engine Service Agent service account is used.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKey#kmsKeyServiceAccountRef
   */
  readonly kmsKeyServiceAccountRef?: ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef;

  /**
   * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
   * RFC 4648 base64 to either encrypt or decrypt this resource.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKey#rawKey
   */
  readonly rawKey?: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskEncryptionKey(obj: ComputeSnapshotSpecSourceDiskEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyServiceAccountRef': toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef(obj.kmsKeyServiceAccountRef),
    'rawKey': toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey(obj.rawKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the disk used to create this snapshot.
 *
 * @schema ComputeSnapshotSpecSourceDiskRef
 */
export interface ComputeSnapshotSpecSourceDiskRef {
  /**
   * Allowed value: The `name` field of a `ComputeDisk` resource.
   *
   * @schema ComputeSnapshotSpecSourceDiskRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSnapshotSpecSourceDiskRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSnapshotSpecSourceDiskRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskRef(obj: ComputeSnapshotSpecSourceDiskRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The encryption key that is stored in Google Cloud KMS.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef {
  /**
   * Allowed value: The `selfLink` field of a `KMSCryptoKey` resource.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef(obj: ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account used for the encryption request for the given KMS key.
 * If absent, the Compute Engine Service Agent service account is used.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeSnapshotSpecSnapshotEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
 * RFC 4648 base64 to either encrypt or decrypt this resource.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKey
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKeyRawKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKey#valueFrom
   */
  readonly valueFrom?: ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKeyRawKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKey(obj: ComputeSnapshotSpecSnapshotEncryptionKeyRawKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The service account used for the encryption request for the given KMS key.
 * If absent, the Compute Engine Service Agent service account is used.
 *
 * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef
 */
export interface ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef {
  /**
   * Allowed value: The `email` field of an `IAMServiceAccount` resource.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef(obj: ComputeSnapshotSpecSourceDiskEncryptionKeyKmsKeyServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Specifies a 256-bit customer-supplied encryption key, encoded in
 * RFC 4648 base64 to either encrypt or decrypt this resource.
 *
 * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey
 */
export interface ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey#valueFrom
   */
  readonly valueFrom?: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey(obj: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom(obj: ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom
 */
export interface ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom(obj: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef
 */
export interface ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef(obj: ComputeSnapshotSpecSnapshotEncryptionKeyRawKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef
 */
export interface ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef(obj: ComputeSnapshotSpecSourceDiskEncryptionKeyRawKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSSLCertificate
 */
export class ComputeSslCertificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSSLCertificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSSLCertificate',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSSLCertificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSslCertificateProps): any {
    return {
      ...ComputeSslCertificate.GVK,
      ...toJson_ComputeSslCertificateProps(props),
    };
  }

  /**
   * Defines a "ComputeSSLCertificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSslCertificateProps) {
    super(scope, id, {
      ...ComputeSslCertificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSslCertificate.GVK,
      ...toJson_ComputeSslCertificateProps(resolved),
    };
  }
}

/**
 * @schema ComputeSSLCertificate
 */
export interface ComputeSslCertificateProps {
  /**
   * @schema ComputeSSLCertificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSSLCertificate#spec
   */
  readonly spec: ComputeSslCertificateSpec;

}

/**
 * Converts an object of type 'ComputeSslCertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateProps(obj: ComputeSslCertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSslCertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSslCertificateSpec
 */
export interface ComputeSslCertificateSpec {
  /**
   * Immutable. The certificate in PEM format.
   * The certificate chain must be no greater than 5 certs long.
   * The chain must include at least one intermediate cert.
   *
   * @schema ComputeSslCertificateSpec#certificate
   */
  readonly certificate: ComputeSslCertificateSpecCertificate;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeSslCertificateSpec#description
   */
  readonly description?: string;

  /**
   * Location represents the geographical location of the ComputeSSLCertificate. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeSslCertificateSpec#location
   */
  readonly location: string;

  /**
   * Immutable. The write-only private key in PEM format.
   *
   * @schema ComputeSslCertificateSpec#privateKey
   */
  readonly privateKey: ComputeSslCertificateSpecPrivateKey;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeSslCertificateSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpec(obj: ComputeSslCertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': toJson_ComputeSslCertificateSpecCertificate(obj.certificate),
    'description': obj.description,
    'location': obj.location,
    'privateKey': toJson_ComputeSslCertificateSpecPrivateKey(obj.privateKey),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The certificate in PEM format.
 * The certificate chain must be no greater than 5 certs long.
 * The chain must include at least one intermediate cert.
 *
 * @schema ComputeSslCertificateSpecCertificate
 */
export interface ComputeSslCertificateSpecCertificate {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeSslCertificateSpecCertificate#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeSslCertificateSpecCertificate#valueFrom
   */
  readonly valueFrom?: ComputeSslCertificateSpecCertificateValueFrom;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecCertificate(obj: ComputeSslCertificateSpecCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeSslCertificateSpecCertificateValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The write-only private key in PEM format.
 *
 * @schema ComputeSslCertificateSpecPrivateKey
 */
export interface ComputeSslCertificateSpecPrivateKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeSslCertificateSpecPrivateKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeSslCertificateSpecPrivateKey#valueFrom
   */
  readonly valueFrom?: ComputeSslCertificateSpecPrivateKeyValueFrom;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecPrivateKey(obj: ComputeSslCertificateSpecPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeSslCertificateSpecPrivateKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeSslCertificateSpecCertificateValueFrom
 */
export interface ComputeSslCertificateSpecCertificateValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeSslCertificateSpecCertificateValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeSslCertificateSpecCertificateValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecCertificateValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecCertificateValueFrom(obj: ComputeSslCertificateSpecCertificateValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeSslCertificateSpecCertificateValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeSslCertificateSpecPrivateKeyValueFrom
 */
export interface ComputeSslCertificateSpecPrivateKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeSslCertificateSpecPrivateKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecPrivateKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecPrivateKeyValueFrom(obj: ComputeSslCertificateSpecPrivateKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeSslCertificateSpecCertificateValueFromSecretKeyRef
 */
export interface ComputeSslCertificateSpecCertificateValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeSslCertificateSpecCertificateValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeSslCertificateSpecCertificateValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecCertificateValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecCertificateValueFromSecretKeyRef(obj: ComputeSslCertificateSpecCertificateValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef
 */
export interface ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef(obj: ComputeSslCertificateSpecPrivateKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSSLPolicy
 */
export class ComputeSslPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSSLPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSSLPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSSLPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSslPolicyProps = {}): any {
    return {
      ...ComputeSslPolicy.GVK,
      ...toJson_ComputeSslPolicyProps(props),
    };
  }

  /**
   * Defines a "ComputeSSLPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSslPolicyProps = {}) {
    super(scope, id, {
      ...ComputeSslPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSslPolicy.GVK,
      ...toJson_ComputeSslPolicyProps(resolved),
    };
  }
}

/**
 * @schema ComputeSSLPolicy
 */
export interface ComputeSslPolicyProps {
  /**
   * @schema ComputeSSLPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSSLPolicy#spec
   */
  readonly spec?: ComputeSslPolicySpec;

}

/**
 * Converts an object of type 'ComputeSslPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslPolicyProps(obj: ComputeSslPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSslPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSslPolicySpec
 */
export interface ComputeSslPolicySpec {
  /**
   * Profile specifies the set of SSL features that can be used by the
   * load balancer when negotiating SSL with clients. This can be one of
   * 'COMPATIBLE', 'MODERN', 'RESTRICTED', or 'CUSTOM'. If using 'CUSTOM',
   * the set of SSL features to enable must be specified in the
   * 'customFeatures' field.
   *
   * See the [official documentation](https://cloud.google.com/compute/docs/load-balancing/ssl-policies#profilefeaturesupport)
   * for which ciphers are available to use. **Note**: this argument
   * *must* be present when using the 'CUSTOM' profile. This argument
   * *must not* be present when using any other profile.
   *
   * @schema ComputeSslPolicySpec#customFeatures
   */
  readonly customFeatures?: string[];

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeSslPolicySpec#description
   */
  readonly description?: string;

  /**
   * The minimum version of SSL protocol that can be used by the clients
   * to establish a connection with the load balancer. Default value: "TLS_1_0" Possible values: ["TLS_1_0", "TLS_1_1", "TLS_1_2"].
   *
   * @schema ComputeSslPolicySpec#minTlsVersion
   */
  readonly minTlsVersion?: string;

  /**
   * Profile specifies the set of SSL features that can be used by the
   * load balancer when negotiating SSL with clients. If using 'CUSTOM',
   * the set of SSL features to enable must be specified in the
   * 'customFeatures' field.
   *
   * See the [official documentation](https://cloud.google.com/compute/docs/load-balancing/ssl-policies#profilefeaturesupport)
   * for information on what cipher suites each profile provides. If
   * 'CUSTOM' is used, the 'custom_features' attribute **must be set**. Default value: "COMPATIBLE" Possible values: ["COMPATIBLE", "MODERN", "RESTRICTED", "CUSTOM"].
   *
   * @schema ComputeSslPolicySpec#profile
   */
  readonly profile?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeSslPolicySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeSslPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSslPolicySpec(obj: ComputeSslPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customFeatures': obj.customFeatures?.map(y => y),
    'description': obj.description,
    'minTlsVersion': obj.minTlsVersion,
    'profile': obj.profile,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeSubnetwork
 */
export class ComputeSubnetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeSubnetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeSubnetwork',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeSubnetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeSubnetworkProps): any {
    return {
      ...ComputeSubnetwork.GVK,
      ...toJson_ComputeSubnetworkProps(props),
    };
  }

  /**
   * Defines a "ComputeSubnetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeSubnetworkProps) {
    super(scope, id, {
      ...ComputeSubnetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeSubnetwork.GVK,
      ...toJson_ComputeSubnetworkProps(resolved),
    };
  }
}

/**
 * @schema ComputeSubnetwork
 */
export interface ComputeSubnetworkProps {
  /**
   * @schema ComputeSubnetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeSubnetwork#spec
   */
  readonly spec: ComputeSubnetworkSpec;

}

/**
 * Converts an object of type 'ComputeSubnetworkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSubnetworkProps(obj: ComputeSubnetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeSubnetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSubnetworkSpec
 */
export interface ComputeSubnetworkSpec {
  /**
   * Immutable. An optional description of this resource. Provide this property when
   * you create the resource. This field can be set only at resource
   * creation time.
   *
   * @schema ComputeSubnetworkSpec#description
   */
  readonly description?: string;

  /**
   * The range of internal addresses that are owned by this subnetwork.
   * Provide this property when you create the subnetwork. For example,
   * 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and
   * non-overlapping within a network. Only IPv4 is supported.
   *
   * @schema ComputeSubnetworkSpec#ipCidrRange
   */
  readonly ipCidrRange: string;

  /**
   * The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation
   * or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet
   * cannot enable direct path. Possible values: ["EXTERNAL", "INTERNAL"].
   *
   * @schema ComputeSubnetworkSpec#ipv6AccessType
   */
  readonly ipv6AccessType?: string;

  /**
   * Denotes the logging options for the subnetwork flow logs. If logging is enabled
   * logs will be exported to Stackdriver. This field cannot be set if the 'purpose' of this
   * subnetwork is 'INTERNAL_HTTPS_LOAD_BALANCER'.
   *
   * @schema ComputeSubnetworkSpec#logConfig
   */
  readonly logConfig?: ComputeSubnetworkSpecLogConfig;

  /**
   * The network this subnet belongs to. Only networks that are in the
   * distributed mode can have subnetworks.
   *
   * @schema ComputeSubnetworkSpec#networkRef
   */
  readonly networkRef: ComputeSubnetworkSpecNetworkRef;

  /**
   * When enabled, VMs in this subnetwork without external IP addresses can
   * access Google APIs and services by using Private Google Access.
   *
   * @schema ComputeSubnetworkSpec#privateIpGoogleAccess
   */
  readonly privateIpGoogleAccess?: boolean;

  /**
   * The private IPv6 google access type for the VMs in this subnet.
   *
   * @schema ComputeSubnetworkSpec#privateIpv6GoogleAccess
   */
  readonly privateIpv6GoogleAccess?: string;

  /**
   * Immutable. The purpose of the resource. This field can be either 'PRIVATE_RFC_1918', 'INTERNAL_HTTPS_LOAD_BALANCER', 'REGIONAL_MANAGED_PROXY', or 'PRIVATE_SERVICE_CONNECT'.
   * A subnetwork with purpose set to 'INTERNAL_HTTPS_LOAD_BALANCER' is a user-created subnetwork that is reserved for Internal HTTP(S) Load Balancing.
   * A subnetwork in a given region with purpose set to 'REGIONAL_MANAGED_PROXY' is a proxy-only subnet and is shared between all the regional Envoy-based load balancers.
   * A subnetwork with purpose set to 'PRIVATE_SERVICE_CONNECT' reserves the subnet for hosting a Private Service Connect published service.
   * If unspecified, the purpose defaults to 'PRIVATE_RFC_1918'.
   * The enableFlowLogs field isn't supported with the purpose field set to 'INTERNAL_HTTPS_LOAD_BALANCER'.
   *
   * @schema ComputeSubnetworkSpec#purpose
   */
  readonly purpose?: string;

  /**
   * Immutable. The GCP region for this subnetwork.
   *
   * @schema ComputeSubnetworkSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeSubnetworkSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The role of subnetwork.
   * The value can be set to 'ACTIVE' or 'BACKUP'.
   * An 'ACTIVE' subnetwork is one that is currently being used.
   * A 'BACKUP' subnetwork is one that is ready to be promoted to 'ACTIVE' or is currently draining.
   *
   * Subnetwork role must be specified when purpose is set to 'INTERNAL_HTTPS_LOAD_BALANCER' or 'REGIONAL_MANAGED_PROXY'. Possible values: ["ACTIVE", "BACKUP"].
   *
   * @schema ComputeSubnetworkSpec#role
   */
  readonly role?: string;

  /**
   * @schema ComputeSubnetworkSpec#secondaryIpRange
   */
  readonly secondaryIpRange?: ComputeSubnetworkSpecSecondaryIpRange[];

  /**
   * The stack type for this subnet to identify whether the IPv6 feature is enabled or not.
   * If not specified IPV4_ONLY will be used. Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
   *
   * @schema ComputeSubnetworkSpec#stackType
   */
  readonly stackType?: string;

}

/**
 * Converts an object of type 'ComputeSubnetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSubnetworkSpec(obj: ComputeSubnetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'ipCidrRange': obj.ipCidrRange,
    'ipv6AccessType': obj.ipv6AccessType,
    'logConfig': toJson_ComputeSubnetworkSpecLogConfig(obj.logConfig),
    'networkRef': toJson_ComputeSubnetworkSpecNetworkRef(obj.networkRef),
    'privateIpGoogleAccess': obj.privateIpGoogleAccess,
    'privateIpv6GoogleAccess': obj.privateIpv6GoogleAccess,
    'purpose': obj.purpose,
    'region': obj.region,
    'resourceID': obj.resourceId,
    'role': obj.role,
    'secondaryIpRange': obj.secondaryIpRange?.map(y => toJson_ComputeSubnetworkSpecSecondaryIpRange(y)),
    'stackType': obj.stackType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Denotes the logging options for the subnetwork flow logs. If logging is enabled
 * logs will be exported to Stackdriver. This field cannot be set if the 'purpose' of this
 * subnetwork is 'INTERNAL_HTTPS_LOAD_BALANCER'.
 *
 * @schema ComputeSubnetworkSpecLogConfig
 */
export interface ComputeSubnetworkSpecLogConfig {
  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Toggles the aggregation interval for collecting flow logs. Increasing the
   * interval time will reduce the amount of generated flow logs for long
   * lasting connections. Default is an interval of 5 seconds per connection. Default value: "INTERVAL_5_SEC" Possible values: ["INTERVAL_5_SEC", "INTERVAL_30_SEC", "INTERVAL_1_MIN", "INTERVAL_5_MIN", "INTERVAL_10_MIN", "INTERVAL_15_MIN"].
   *
   * @default an interval of 5 seconds per connection. Default value: "INTERVAL_5_SEC" Possible values: ["INTERVAL_5_SEC", "INTERVAL_30_SEC", "INTERVAL_1_MIN", "INTERVAL_5_MIN", "INTERVAL_10_MIN", "INTERVAL_15_MIN"].
   * @schema ComputeSubnetworkSpecLogConfig#aggregationInterval
   */
  readonly aggregationInterval?: string;

  /**
   * Export filter used to define which VPC flow logs should be logged, as as CEL expression. See
   * https://cloud.google.com/vpc/docs/flow-logs#filtering for details on how to format this field.
   * The default value is 'true', which evaluates to include everything.
   *
   * @schema ComputeSubnetworkSpecLogConfig#filterExpr
   */
  readonly filterExpr?: string;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * The value of the field must be in [0, 1]. Set the sampling rate of VPC
   * flow logs within the subnetwork where 1.0 means all collected logs are
   * reported and 0.0 means no logs are reported. Default is 0.5 which means
   * half of all collected logs are reported.
   *
   * @default 0.5 which means
   * @schema ComputeSubnetworkSpecLogConfig#flowSampling
   */
  readonly flowSampling?: number;

  /**
   * Can only be specified if VPC flow logging for this subnetwork is enabled.
   * Configures whether metadata fields should be added to the reported VPC
   * flow logs. Default value: "INCLUDE_ALL_METADATA" Possible values: ["EXCLUDE_ALL_METADATA", "INCLUDE_ALL_METADATA", "CUSTOM_METADATA"].
   *
   * @schema ComputeSubnetworkSpecLogConfig#metadata
   */
  readonly metadata?: string;

  /**
   * List of metadata fields that should be added to reported logs.
   * Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" is set to CUSTOM_METADATA.
   *
   * @schema ComputeSubnetworkSpecLogConfig#metadataFields
   */
  readonly metadataFields?: string[];

}

/**
 * Converts an object of type 'ComputeSubnetworkSpecLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSubnetworkSpecLogConfig(obj: ComputeSubnetworkSpecLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationInterval': obj.aggregationInterval,
    'filterExpr': obj.filterExpr,
    'flowSampling': obj.flowSampling,
    'metadata': obj.metadata,
    'metadataFields': obj.metadataFields?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network this subnet belongs to. Only networks that are in the
 * distributed mode can have subnetworks.
 *
 * @schema ComputeSubnetworkSpecNetworkRef
 */
export interface ComputeSubnetworkSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeSubnetworkSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeSubnetworkSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeSubnetworkSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeSubnetworkSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSubnetworkSpecNetworkRef(obj: ComputeSubnetworkSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeSubnetworkSpecSecondaryIpRange
 */
export interface ComputeSubnetworkSpecSecondaryIpRange {
  /**
   * The range of IP addresses belonging to this subnetwork secondary
   * range. Provide this property when you create the subnetwork.
   * Ranges must be unique and non-overlapping with all primary and
   * secondary IP ranges within a network. Only IPv4 is supported.
   *
   * @schema ComputeSubnetworkSpecSecondaryIpRange#ipCidrRange
   */
  readonly ipCidrRange: string;

  /**
   * The name associated with this subnetwork secondary range, used
   * when adding an alias IP range to a VM instance. The name must
   * be 1-63 characters long, and comply with RFC1035. The name
   * must be unique within the subnetwork.
   *
   * @schema ComputeSubnetworkSpecSecondaryIpRange#rangeName
   */
  readonly rangeName: string;

}

/**
 * Converts an object of type 'ComputeSubnetworkSpecSecondaryIpRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeSubnetworkSpecSecondaryIpRange(obj: ComputeSubnetworkSpecSecondaryIpRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipCidrRange': obj.ipCidrRange,
    'rangeName': obj.rangeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetGRPCProxy
 */
export class ComputeTargetGrpcProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetGRPCProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetGRPCProxy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetGRPCProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetGrpcProxyProps = {}): any {
    return {
      ...ComputeTargetGrpcProxy.GVK,
      ...toJson_ComputeTargetGrpcProxyProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetGRPCProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetGrpcProxyProps = {}) {
    super(scope, id, {
      ...ComputeTargetGrpcProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetGrpcProxy.GVK,
      ...toJson_ComputeTargetGrpcProxyProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetGRPCProxy
 */
export interface ComputeTargetGrpcProxyProps {
  /**
   * @schema ComputeTargetGRPCProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetGRPCProxy#spec
   */
  readonly spec?: ComputeTargetGrpcProxySpec;

}

/**
 * Converts an object of type 'ComputeTargetGrpcProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetGrpcProxyProps(obj: ComputeTargetGrpcProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetGrpcProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetGrpcProxySpec
 */
export interface ComputeTargetGrpcProxySpec {
  /**
   * An optional description of this resource.
   *
   * @schema ComputeTargetGrpcProxySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetGrpcProxySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The UrlMap resource that defines the mapping from URL to the BackendService.
   * The protocol field in the BackendService must be set to GRPC.
   *
   * @schema ComputeTargetGrpcProxySpec#urlMapRef
   */
  readonly urlMapRef?: ComputeTargetGrpcProxySpecUrlMapRef;

  /**
   * Immutable. If true, indicates that the BackendServices referenced by
   * the urlMap may be accessed by gRPC applications without using
   * a sidecar proxy. This will enable configuration checks on urlMap
   * and its referenced BackendServices to not allow unsupported features.
   * A gRPC application must use "xds:///" scheme in the target URI
   * of the service it is connecting to. If false, indicates that the
   * BackendServices referenced by the urlMap will be accessed by gRPC
   * applications via a sidecar proxy. In this case, a gRPC application
   * must not use "xds:///" scheme in the target URI of the service
   * it is connecting to.
   *
   * @schema ComputeTargetGrpcProxySpec#validateForProxyless
   */
  readonly validateForProxyless?: boolean;

}

/**
 * Converts an object of type 'ComputeTargetGrpcProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetGrpcProxySpec(obj: ComputeTargetGrpcProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'resourceID': obj.resourceId,
    'urlMapRef': toJson_ComputeTargetGrpcProxySpecUrlMapRef(obj.urlMapRef),
    'validateForProxyless': obj.validateForProxyless,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The UrlMap resource that defines the mapping from URL to the BackendService.
 * The protocol field in the BackendService must be set to GRPC.
 *
 * @schema ComputeTargetGrpcProxySpecUrlMapRef
 */
export interface ComputeTargetGrpcProxySpecUrlMapRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeURLMap` resource.
   *
   * @schema ComputeTargetGrpcProxySpecUrlMapRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetGrpcProxySpecUrlMapRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetGrpcProxySpecUrlMapRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetGrpcProxySpecUrlMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetGrpcProxySpecUrlMapRef(obj: ComputeTargetGrpcProxySpecUrlMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetHTTPProxy
 */
export class ComputeTargetHttpProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetHTTPProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetHTTPProxy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetHTTPProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetHttpProxyProps): any {
    return {
      ...ComputeTargetHttpProxy.GVK,
      ...toJson_ComputeTargetHttpProxyProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetHTTPProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetHttpProxyProps) {
    super(scope, id, {
      ...ComputeTargetHttpProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetHttpProxy.GVK,
      ...toJson_ComputeTargetHttpProxyProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetHTTPProxy
 */
export interface ComputeTargetHttpProxyProps {
  /**
   * @schema ComputeTargetHTTPProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetHTTPProxy#spec
   */
  readonly spec: ComputeTargetHttpProxySpec;

}

/**
 * Converts an object of type 'ComputeTargetHttpProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpProxyProps(obj: ComputeTargetHttpProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetHttpProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetHttpProxySpec
 */
export interface ComputeTargetHttpProxySpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetHttpProxySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Specifies how long to keep a connection open, after completing a response,
   * while there is no matching traffic (in seconds). If an HTTP keepalive is
   * not specified, a default value (610 seconds) will be used. For Global
   * external HTTP(S) load balancer, the minimum allowed value is 5 seconds and
   * the maximum allowed value is 1200 seconds. For Global external HTTP(S)
   * load balancer (classic), this option is not available publicly.
   *
   * @schema ComputeTargetHttpProxySpec#httpKeepAliveTimeoutSec
   */
  readonly httpKeepAliveTimeoutSec?: number;

  /**
   * Location represents the geographical location of the ComputeTargetHTTPProxy. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeTargetHttpProxySpec#location
   */
  readonly location: string;

  /**
   * Immutable. This field only applies when the forwarding rule that references
   * this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeTargetHttpProxySpec#proxyBind
   */
  readonly proxyBind?: boolean;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetHttpProxySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * A reference to the ComputeURLMap resource that defines the mapping
   * from URL to the BackendService.
   *
   * @schema ComputeTargetHttpProxySpec#urlMapRef
   */
  readonly urlMapRef: ComputeTargetHttpProxySpecUrlMapRef;

}

/**
 * Converts an object of type 'ComputeTargetHttpProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpProxySpec(obj: ComputeTargetHttpProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'httpKeepAliveTimeoutSec': obj.httpKeepAliveTimeoutSec,
    'location': obj.location,
    'proxyBind': obj.proxyBind,
    'resourceID': obj.resourceId,
    'urlMapRef': toJson_ComputeTargetHttpProxySpecUrlMapRef(obj.urlMapRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeURLMap resource that defines the mapping
 * from URL to the BackendService.
 *
 * @schema ComputeTargetHttpProxySpecUrlMapRef
 */
export interface ComputeTargetHttpProxySpecUrlMapRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeURLMap` resource.
   *
   * @schema ComputeTargetHttpProxySpecUrlMapRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetHttpProxySpecUrlMapRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetHttpProxySpecUrlMapRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetHttpProxySpecUrlMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpProxySpecUrlMapRef(obj: ComputeTargetHttpProxySpecUrlMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetHTTPSProxy
 */
export class ComputeTargetHttpsProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetHTTPSProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetHTTPSProxy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetHTTPSProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetHttpsProxyProps): any {
    return {
      ...ComputeTargetHttpsProxy.GVK,
      ...toJson_ComputeTargetHttpsProxyProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetHTTPSProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetHttpsProxyProps) {
    super(scope, id, {
      ...ComputeTargetHttpsProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetHttpsProxy.GVK,
      ...toJson_ComputeTargetHttpsProxyProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetHTTPSProxy
 */
export interface ComputeTargetHttpsProxyProps {
  /**
   * @schema ComputeTargetHTTPSProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetHTTPSProxy#spec
   */
  readonly spec: ComputeTargetHttpsProxySpec;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxyProps(obj: ComputeTargetHttpsProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetHttpsProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetHttpsProxySpec
 */
export interface ComputeTargetHttpsProxySpec {
  /**
   * Only the `external` field is supported to configure the reference.
   *
   * A reference to the CertificateMap resource uri that identifies a
   * certificate map associated with the given target proxy. This field
   * can only be set for global target proxies.
   *
   * @schema ComputeTargetHttpsProxySpec#certificateMapRef
   */
  readonly certificateMapRef?: ComputeTargetHttpsProxySpecCertificateMapRef;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetHttpsProxySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Specifies how long to keep a connection open, after completing a response,
   * while there is no matching traffic (in seconds). If an HTTP keepalive is
   * not specified, a default value (610 seconds) will be used. For Global
   * external HTTP(S) load balancer, the minimum allowed value is 5 seconds and
   * the maximum allowed value is 1200 seconds. For Global external HTTP(S)
   * load balancer (classic), this option is not available publicly.
   *
   * @schema ComputeTargetHttpsProxySpec#httpKeepAliveTimeoutSec
   */
  readonly httpKeepAliveTimeoutSec?: number;

  /**
   * Location represents the geographical location of the ComputeTargetHTTPSProxy. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeTargetHttpsProxySpec#location
   */
  readonly location: string;

  /**
   * Immutable. This field only applies when the forwarding rule that references
   * this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeTargetHttpsProxySpec#proxyBind
   */
  readonly proxyBind?: boolean;

  /**
   * Specifies the QUIC override policy for this resource. This determines
   * whether the load balancer will attempt to negotiate QUIC with clients
   * or not. Can specify one of NONE, ENABLE, or DISABLE. If NONE is
   * specified, Google manages whether QUIC is used. Default value: "NONE" Possible values: ["NONE", "ENABLE", "DISABLE"].
   *
   * @schema ComputeTargetHttpsProxySpec#quicOverride
   */
  readonly quicOverride?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetHttpsProxySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeTargetHttpsProxySpec#sslCertificates
   */
  readonly sslCertificates?: ComputeTargetHttpsProxySpecSslCertificates[];

  /**
   * A reference to the ComputeSSLPolicy resource that will be
   * associated with the ComputeTargetHTTPSProxy resource. If not set,
   * the ComputeTargetHTTPSProxy resource will not have any SSL policy
   * configured.
   *
   * @schema ComputeTargetHttpsProxySpec#sslPolicyRef
   */
  readonly sslPolicyRef?: ComputeTargetHttpsProxySpecSslPolicyRef;

  /**
   * A reference to the ComputeURLMap resource that defines the mapping
   * from URL to the BackendService.
   *
   * @schema ComputeTargetHttpsProxySpec#urlMapRef
   */
  readonly urlMapRef: ComputeTargetHttpsProxySpecUrlMapRef;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxySpec(obj: ComputeTargetHttpsProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateMapRef': toJson_ComputeTargetHttpsProxySpecCertificateMapRef(obj.certificateMapRef),
    'description': obj.description,
    'httpKeepAliveTimeoutSec': obj.httpKeepAliveTimeoutSec,
    'location': obj.location,
    'proxyBind': obj.proxyBind,
    'quicOverride': obj.quicOverride,
    'resourceID': obj.resourceId,
    'sslCertificates': obj.sslCertificates?.map(y => toJson_ComputeTargetHttpsProxySpecSslCertificates(y)),
    'sslPolicyRef': toJson_ComputeTargetHttpsProxySpecSslPolicyRef(obj.sslPolicyRef),
    'urlMapRef': toJson_ComputeTargetHttpsProxySpecUrlMapRef(obj.urlMapRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Only the `external` field is supported to configure the reference.
 *
 * A reference to the CertificateMap resource uri that identifies a
 * certificate map associated with the given target proxy. This field
 * can only be set for global target proxies.
 *
 * @schema ComputeTargetHttpsProxySpecCertificateMapRef
 */
export interface ComputeTargetHttpsProxySpecCertificateMapRef {
  /**
   * Allowed value: string of the format `//certificatemanager.googleapis.com/projects/{{project}}/locations/{{location}}/certificateMaps/{{value}}`, where {{value}} is the `name` field of a `CertificateManagerCertificateMap` resource.
   *
   * @schema ComputeTargetHttpsProxySpecCertificateMapRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetHttpsProxySpecCertificateMapRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetHttpsProxySpecCertificateMapRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxySpecCertificateMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxySpecCertificateMapRef(obj: ComputeTargetHttpsProxySpecCertificateMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of ComputeSSLCertificate resources that are used to
 * authenticate connections between users and the load balancer. At
 * least one SSL certificate must be specified.
 *
 * @schema ComputeTargetHttpsProxySpecSslCertificates
 */
export interface ComputeTargetHttpsProxySpecSslCertificates {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSSLCertificate` resource.
   *
   * @schema ComputeTargetHttpsProxySpecSslCertificates#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetHttpsProxySpecSslCertificates#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetHttpsProxySpecSslCertificates#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxySpecSslCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxySpecSslCertificates(obj: ComputeTargetHttpsProxySpecSslCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeSSLPolicy resource that will be
 * associated with the ComputeTargetHTTPSProxy resource. If not set,
 * the ComputeTargetHTTPSProxy resource will not have any SSL policy
 * configured.
 *
 * @schema ComputeTargetHttpsProxySpecSslPolicyRef
 */
export interface ComputeTargetHttpsProxySpecSslPolicyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSSLPolicy` resource.
   *
   * @schema ComputeTargetHttpsProxySpecSslPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetHttpsProxySpecSslPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetHttpsProxySpecSslPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxySpecSslPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxySpecSslPolicyRef(obj: ComputeTargetHttpsProxySpecSslPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeURLMap resource that defines the mapping
 * from URL to the BackendService.
 *
 * @schema ComputeTargetHttpsProxySpecUrlMapRef
 */
export interface ComputeTargetHttpsProxySpecUrlMapRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeURLMap` resource.
   *
   * @schema ComputeTargetHttpsProxySpecUrlMapRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetHttpsProxySpecUrlMapRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetHttpsProxySpecUrlMapRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetHttpsProxySpecUrlMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetHttpsProxySpecUrlMapRef(obj: ComputeTargetHttpsProxySpecUrlMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetInstance
 */
export class ComputeTargetInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetInstanceProps): any {
    return {
      ...ComputeTargetInstance.GVK,
      ...toJson_ComputeTargetInstanceProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetInstanceProps) {
    super(scope, id, {
      ...ComputeTargetInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetInstance.GVK,
      ...toJson_ComputeTargetInstanceProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetInstance
 */
export interface ComputeTargetInstanceProps {
  /**
   * @schema ComputeTargetInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetInstance#spec
   */
  readonly spec: ComputeTargetInstanceSpec;

}

/**
 * Converts an object of type 'ComputeTargetInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetInstanceProps(obj: ComputeTargetInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetInstanceSpec
 */
export interface ComputeTargetInstanceSpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetInstanceSpec#description
   */
  readonly description?: string;

  /**
   * The ComputeInstance handling traffic for this target instance.
   *
   * @schema ComputeTargetInstanceSpec#instanceRef
   */
  readonly instanceRef: ComputeTargetInstanceSpecInstanceRef;

  /**
   * Immutable. NAT option controlling how IPs are NAT'ed to the instance.
   * Currently only NO_NAT (default value) is supported. Default value: "NO_NAT" Possible values: ["NO_NAT"].
   *
   * @schema ComputeTargetInstanceSpec#natPolicy
   */
  readonly natPolicy?: string;

  /**
   * The network this target instance uses to forward
   * traffic. If not specified, the traffic will be forwarded to the network
   * that the default network interface belongs to.
   *
   * @schema ComputeTargetInstanceSpec#networkRef
   */
  readonly networkRef?: ComputeTargetInstanceSpecNetworkRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetInstanceSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. URL of the zone where the target instance resides.
   *
   * @schema ComputeTargetInstanceSpec#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'ComputeTargetInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetInstanceSpec(obj: ComputeTargetInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceRef': toJson_ComputeTargetInstanceSpecInstanceRef(obj.instanceRef),
    'natPolicy': obj.natPolicy,
    'networkRef': toJson_ComputeTargetInstanceSpecNetworkRef(obj.networkRef),
    'resourceID': obj.resourceId,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ComputeInstance handling traffic for this target instance.
 *
 * @schema ComputeTargetInstanceSpecInstanceRef
 */
export interface ComputeTargetInstanceSpecInstanceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputeTargetInstanceSpecInstanceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetInstanceSpecInstanceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetInstanceSpecInstanceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetInstanceSpecInstanceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetInstanceSpecInstanceRef(obj: ComputeTargetInstanceSpecInstanceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network this target instance uses to forward
 * traffic. If not specified, the traffic will be forwarded to the network
 * that the default network interface belongs to.
 *
 * @schema ComputeTargetInstanceSpecNetworkRef
 */
export interface ComputeTargetInstanceSpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeTargetInstanceSpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetInstanceSpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetInstanceSpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetInstanceSpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetInstanceSpecNetworkRef(obj: ComputeTargetInstanceSpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetPool
 */
export class ComputeTargetPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetPool',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetPoolProps): any {
    return {
      ...ComputeTargetPool.GVK,
      ...toJson_ComputeTargetPoolProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetPoolProps) {
    super(scope, id, {
      ...ComputeTargetPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetPool.GVK,
      ...toJson_ComputeTargetPoolProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetPool
 */
export interface ComputeTargetPoolProps {
  /**
   * @schema ComputeTargetPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetPool#spec
   */
  readonly spec: ComputeTargetPoolSpec;

}

/**
 * Converts an object of type 'ComputeTargetPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolProps(obj: ComputeTargetPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetPoolSpec
 */
export interface ComputeTargetPoolSpec {
  /**
   * @schema ComputeTargetPoolSpec#backupTargetPoolRef
   */
  readonly backupTargetPoolRef?: ComputeTargetPoolSpecBackupTargetPoolRef;

  /**
   * Immutable. Textual description field.
   *
   * @schema ComputeTargetPoolSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. Ratio (0 to 1) of failed nodes before using the backup pool (which must also be set).
   *
   * @schema ComputeTargetPoolSpec#failoverRatio
   */
  readonly failoverRatio?: number;

  /**
   * @schema ComputeTargetPoolSpec#healthChecks
   */
  readonly healthChecks?: ComputeTargetPoolSpecHealthChecks[];

  /**
   * @schema ComputeTargetPoolSpec#instances
   */
  readonly instances?: ComputeTargetPoolSpecInstances[];

  /**
   * Immutable. Where the target pool resides. Defaults to project region.
   *
   * @default project region.
   * @schema ComputeTargetPoolSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetPoolSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. How to distribute load. Options are "NONE" (no affinity). "CLIENT_IP" (hash of the source/dest addresses / ports), and "CLIENT_IP_PROTO" also includes the protocol (default "NONE").
   *
   * @schema ComputeTargetPoolSpec#sessionAffinity
   */
  readonly sessionAffinity?: string;

}

/**
 * Converts an object of type 'ComputeTargetPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolSpec(obj: ComputeTargetPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupTargetPoolRef': toJson_ComputeTargetPoolSpecBackupTargetPoolRef(obj.backupTargetPoolRef),
    'description': obj.description,
    'failoverRatio': obj.failoverRatio,
    'healthChecks': obj.healthChecks?.map(y => toJson_ComputeTargetPoolSpecHealthChecks(y)),
    'instances': obj.instances?.map(y => toJson_ComputeTargetPoolSpecInstances(y)),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'sessionAffinity': obj.sessionAffinity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetPoolSpecBackupTargetPoolRef
 */
export interface ComputeTargetPoolSpecBackupTargetPoolRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetPool` resource.
   *
   * @schema ComputeTargetPoolSpecBackupTargetPoolRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetPoolSpecBackupTargetPoolRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetPoolSpecBackupTargetPoolRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetPoolSpecBackupTargetPoolRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolSpecBackupTargetPoolRef(obj: ComputeTargetPoolSpecBackupTargetPoolRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetPoolSpecHealthChecks
 */
export interface ComputeTargetPoolSpecHealthChecks {
  /**
   * @schema ComputeTargetPoolSpecHealthChecks#httpHealthCheckRef
   */
  readonly httpHealthCheckRef?: ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef;

}

/**
 * Converts an object of type 'ComputeTargetPoolSpecHealthChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolSpecHealthChecks(obj: ComputeTargetPoolSpecHealthChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHealthCheckRef': toJson_ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef(obj.httpHealthCheckRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetPoolSpecInstances
 */
export interface ComputeTargetPoolSpecInstances {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInstance` resource.
   *
   * @schema ComputeTargetPoolSpecInstances#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetPoolSpecInstances#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetPoolSpecInstances#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetPoolSpecInstances' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolSpecInstances(obj: ComputeTargetPoolSpecInstances | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef
 */
export interface ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeHTTPHealthCheck` resource.
   *
   * @schema ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef(obj: ComputeTargetPoolSpecHealthChecksHttpHealthCheckRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetSSLProxy
 */
export class ComputeTargetSslProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetSSLProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetSSLProxy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetSSLProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetSslProxyProps): any {
    return {
      ...ComputeTargetSslProxy.GVK,
      ...toJson_ComputeTargetSslProxyProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetSSLProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetSslProxyProps) {
    super(scope, id, {
      ...ComputeTargetSslProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetSslProxy.GVK,
      ...toJson_ComputeTargetSslProxyProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetSSLProxy
 */
export interface ComputeTargetSslProxyProps {
  /**
   * @schema ComputeTargetSSLProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetSSLProxy#spec
   */
  readonly spec: ComputeTargetSslProxySpec;

}

/**
 * Converts an object of type 'ComputeTargetSslProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxyProps(obj: ComputeTargetSslProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetSslProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetSslProxySpec
 */
export interface ComputeTargetSslProxySpec {
  /**
   * A reference to the ComputeBackendService resource.
   *
   * @schema ComputeTargetSslProxySpec#backendServiceRef
   */
  readonly backendServiceRef: ComputeTargetSslProxySpecBackendServiceRef;

  /**
   * Only `external` field is supported to configure the reference.
   *
   * A reference to the CertificateMap resource uri that identifies a
   * certificate map associated with the given target proxy. This
   * field can only be set for global target proxies. Accepted format is
   * '//certificatemanager.googleapis.com/projects/{project}/locations/{location}/certificateMaps/{resourceName}'.
   *
   * @schema ComputeTargetSslProxySpec#certificateMapRef
   */
  readonly certificateMapRef?: ComputeTargetSslProxySpecCertificateMapRef;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetSslProxySpec#description
   */
  readonly description?: string;

  /**
   * Specifies the type of proxy header to append before sending data to
   * the backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeTargetSslProxySpec#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetSslProxySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema ComputeTargetSslProxySpec#sslCertificates
   */
  readonly sslCertificates?: ComputeTargetSslProxySpecSslCertificates[];

  /**
   * A reference to the ComputeSSLPolicy resource that will be
   * associated with the TargetSslProxy resource. If not set, the
   * ComputeTargetSSLProxy resource will not have any SSL policy
   * configured.
   *
   * @schema ComputeTargetSslProxySpec#sslPolicyRef
   */
  readonly sslPolicyRef?: ComputeTargetSslProxySpecSslPolicyRef;

}

/**
 * Converts an object of type 'ComputeTargetSslProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxySpec(obj: ComputeTargetSslProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeTargetSslProxySpecBackendServiceRef(obj.backendServiceRef),
    'certificateMapRef': toJson_ComputeTargetSslProxySpecCertificateMapRef(obj.certificateMapRef),
    'description': obj.description,
    'proxyHeader': obj.proxyHeader,
    'resourceID': obj.resourceId,
    'sslCertificates': obj.sslCertificates?.map(y => toJson_ComputeTargetSslProxySpecSslCertificates(y)),
    'sslPolicyRef': toJson_ComputeTargetSslProxySpecSslPolicyRef(obj.sslPolicyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeBackendService resource.
 *
 * @schema ComputeTargetSslProxySpecBackendServiceRef
 */
export interface ComputeTargetSslProxySpecBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeTargetSslProxySpecBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetSslProxySpecBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetSslProxySpecBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetSslProxySpecBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxySpecBackendServiceRef(obj: ComputeTargetSslProxySpecBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Only `external` field is supported to configure the reference.
 *
 * A reference to the CertificateMap resource uri that identifies a
 * certificate map associated with the given target proxy. This
 * field can only be set for global target proxies. Accepted format is
 * '//certificatemanager.googleapis.com/projects/{project}/locations/{location}/certificateMaps/{resourceName}'.
 *
 * @schema ComputeTargetSslProxySpecCertificateMapRef
 */
export interface ComputeTargetSslProxySpecCertificateMapRef {
  /**
   * Allowed value: The `name` field of a `CertificateManagerCertificateMap` resource.
   *
   * @schema ComputeTargetSslProxySpecCertificateMapRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetSslProxySpecCertificateMapRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetSslProxySpecCertificateMapRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetSslProxySpecCertificateMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxySpecCertificateMapRef(obj: ComputeTargetSslProxySpecCertificateMapRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of ComputeSSLCertificate resources that are used to
 * authenticate connections between users and the load balancer.
 * Currently, exactly one SSL certificate must be specified.
 *
 * @schema ComputeTargetSslProxySpecSslCertificates
 */
export interface ComputeTargetSslProxySpecSslCertificates {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSSLCertificate` resource.
   *
   * @schema ComputeTargetSslProxySpecSslCertificates#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetSslProxySpecSslCertificates#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetSslProxySpecSslCertificates#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetSslProxySpecSslCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxySpecSslCertificates(obj: ComputeTargetSslProxySpecSslCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeSSLPolicy resource that will be
 * associated with the TargetSslProxy resource. If not set, the
 * ComputeTargetSSLProxy resource will not have any SSL policy
 * configured.
 *
 * @schema ComputeTargetSslProxySpecSslPolicyRef
 */
export interface ComputeTargetSslProxySpecSslPolicyRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeSSLPolicy` resource.
   *
   * @schema ComputeTargetSslProxySpecSslPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetSslProxySpecSslPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetSslProxySpecSslPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetSslProxySpecSslPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetSslProxySpecSslPolicyRef(obj: ComputeTargetSslProxySpecSslPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetTCPProxy
 */
export class ComputeTargetTcpProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetTCPProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetTCPProxy',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetTCPProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetTcpProxyProps): any {
    return {
      ...ComputeTargetTcpProxy.GVK,
      ...toJson_ComputeTargetTcpProxyProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetTCPProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetTcpProxyProps) {
    super(scope, id, {
      ...ComputeTargetTcpProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetTcpProxy.GVK,
      ...toJson_ComputeTargetTcpProxyProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetTCPProxy
 */
export interface ComputeTargetTcpProxyProps {
  /**
   * @schema ComputeTargetTCPProxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetTCPProxy#spec
   */
  readonly spec: ComputeTargetTcpProxySpec;

}

/**
 * Converts an object of type 'ComputeTargetTcpProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetTcpProxyProps(obj: ComputeTargetTcpProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetTcpProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetTcpProxySpec
 */
export interface ComputeTargetTcpProxySpec {
  /**
   * A reference to the ComputeBackendService resource.
   *
   * @schema ComputeTargetTcpProxySpec#backendServiceRef
   */
  readonly backendServiceRef: ComputeTargetTcpProxySpecBackendServiceRef;

  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetTcpProxySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. This field only applies when the forwarding rule that references
   * this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeTargetTcpProxySpec#proxyBind
   */
  readonly proxyBind?: boolean;

  /**
   * Specifies the type of proxy header to append before sending data to
   * the backend. Default value: "NONE" Possible values: ["NONE", "PROXY_V1"].
   *
   * @schema ComputeTargetTcpProxySpec#proxyHeader
   */
  readonly proxyHeader?: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetTcpProxySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeTargetTcpProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetTcpProxySpec(obj: ComputeTargetTcpProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeTargetTcpProxySpecBackendServiceRef(obj.backendServiceRef),
    'description': obj.description,
    'proxyBind': obj.proxyBind,
    'proxyHeader': obj.proxyHeader,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to the ComputeBackendService resource.
 *
 * @schema ComputeTargetTcpProxySpecBackendServiceRef
 */
export interface ComputeTargetTcpProxySpecBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeTargetTcpProxySpecBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetTcpProxySpecBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetTcpProxySpecBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetTcpProxySpecBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetTcpProxySpecBackendServiceRef(obj: ComputeTargetTcpProxySpecBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeTargetVPNGateway
 */
export class ComputeTargetVpnGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeTargetVPNGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeTargetVPNGateway',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeTargetVPNGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeTargetVpnGatewayProps): any {
    return {
      ...ComputeTargetVpnGateway.GVK,
      ...toJson_ComputeTargetVpnGatewayProps(props),
    };
  }

  /**
   * Defines a "ComputeTargetVPNGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeTargetVpnGatewayProps) {
    super(scope, id, {
      ...ComputeTargetVpnGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeTargetVpnGateway.GVK,
      ...toJson_ComputeTargetVpnGatewayProps(resolved),
    };
  }
}

/**
 * @schema ComputeTargetVPNGateway
 */
export interface ComputeTargetVpnGatewayProps {
  /**
   * @schema ComputeTargetVPNGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeTargetVPNGateway#spec
   */
  readonly spec: ComputeTargetVpnGatewaySpec;

}

/**
 * Converts an object of type 'ComputeTargetVpnGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetVpnGatewayProps(obj: ComputeTargetVpnGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeTargetVpnGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeTargetVpnGatewaySpec
 */
export interface ComputeTargetVpnGatewaySpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeTargetVpnGatewaySpec#description
   */
  readonly description?: string;

  /**
   * The network this VPN gateway is accepting traffic for.
   *
   * @schema ComputeTargetVpnGatewaySpec#networkRef
   */
  readonly networkRef: ComputeTargetVpnGatewaySpecNetworkRef;

  /**
   * Immutable. The region this gateway should sit in.
   *
   * @schema ComputeTargetVpnGatewaySpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeTargetVpnGatewaySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'ComputeTargetVpnGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetVpnGatewaySpec(obj: ComputeTargetVpnGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'networkRef': toJson_ComputeTargetVpnGatewaySpecNetworkRef(obj.networkRef),
    'region': obj.region,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network this VPN gateway is accepting traffic for.
 *
 * @schema ComputeTargetVpnGatewaySpecNetworkRef
 */
export interface ComputeTargetVpnGatewaySpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeTargetVpnGatewaySpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeTargetVpnGatewaySpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeTargetVpnGatewaySpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeTargetVpnGatewaySpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeTargetVpnGatewaySpecNetworkRef(obj: ComputeTargetVpnGatewaySpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeURLMap
 */
export class ComputeUrlMap extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeURLMap"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeURLMap',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeURLMap".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeUrlMapProps): any {
    return {
      ...ComputeUrlMap.GVK,
      ...toJson_ComputeUrlMapProps(props),
    };
  }

  /**
   * Defines a "ComputeURLMap" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeUrlMapProps) {
    super(scope, id, {
      ...ComputeUrlMap.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeUrlMap.GVK,
      ...toJson_ComputeUrlMapProps(resolved),
    };
  }
}

/**
 * @schema ComputeURLMap
 */
export interface ComputeUrlMapProps {
  /**
   * @schema ComputeURLMap#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeURLMap#spec
   */
  readonly spec: ComputeUrlMapSpec;

}

/**
 * Converts an object of type 'ComputeUrlMapProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapProps(obj: ComputeUrlMapProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeUrlMapSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpec
 */
export interface ComputeUrlMapSpec {
  /**
   * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
   * Only one of defaultRouteAction or defaultUrlRedirect must be set.
   * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
   * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
   *
   * @schema ComputeUrlMapSpec#defaultRouteAction
   */
  readonly defaultRouteAction?: ComputeUrlMapSpecDefaultRouteAction;

  /**
   * The defaultService resource to which traffic is directed if none of
   * the hostRules match.
   * For the Global URL Map, it should be a reference to the backend
   * service or backend bucket.
   * For the Regional URL Map, it should be a reference to the backend
   * service.
   * If defaultRouteAction is additionally specified, advanced routing
   * actions like URL Rewrites, etc. take effect prior to sending the
   * request to the backend. However, if defaultService is specified,
   * defaultRouteAction cannot contain any weightedBackendServices.
   * Conversely, if routeAction specifies any weightedBackendServices,
   * service must not be specified. Only one of defaultService,
   * defaultUrlRedirect or defaultRouteAction.weightedBackendService
   * must be set.
   *
   * @schema ComputeUrlMapSpec#defaultService
   */
  readonly defaultService?: ComputeUrlMapSpecDefaultService;

  /**
   * When none of the specified hostRules match, the request is redirected to a URL specified
   * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
   * defaultRouteAction must not be set.
   *
   * @schema ComputeUrlMapSpec#defaultUrlRedirect
   */
  readonly defaultUrlRedirect?: ComputeUrlMapSpecDefaultUrlRedirect;

  /**
   * An optional description of this resource. Provide this property when
   * you create the resource.
   *
   * @schema ComputeUrlMapSpec#description
   */
  readonly description?: string;

  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService. The headerAction specified here take effect after
   * headerAction specified under pathMatcher.
   *
   * @schema ComputeUrlMapSpec#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecHeaderAction;

  /**
   * The list of HostRules to use against the URL.
   *
   * @schema ComputeUrlMapSpec#hostRule
   */
  readonly hostRule?: ComputeUrlMapSpecHostRule[];

  /**
   * Location represents the geographical location of the ComputeURLMap. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/)
   *
   * @schema ComputeUrlMapSpec#location
   */
  readonly location: string;

  /**
   * The list of named PathMatchers to use against the URL.
   *
   * @schema ComputeUrlMapSpec#pathMatcher
   */
  readonly pathMatcher?: ComputeUrlMapSpecPathMatcher[];

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeUrlMapSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The list of expected URL mappings. Requests to update this UrlMap will
   * succeed only if all of the test cases pass.
   *
   * @schema ComputeUrlMapSpec#test
   */
  readonly test?: ComputeUrlMapSpecTest[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpec(obj: ComputeUrlMapSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultRouteAction': toJson_ComputeUrlMapSpecDefaultRouteAction(obj.defaultRouteAction),
    'defaultService': toJson_ComputeUrlMapSpecDefaultService(obj.defaultService),
    'defaultUrlRedirect': toJson_ComputeUrlMapSpecDefaultUrlRedirect(obj.defaultUrlRedirect),
    'description': obj.description,
    'headerAction': toJson_ComputeUrlMapSpecHeaderAction(obj.headerAction),
    'hostRule': obj.hostRule?.map(y => toJson_ComputeUrlMapSpecHostRule(y)),
    'location': obj.location,
    'pathMatcher': obj.pathMatcher?.map(y => toJson_ComputeUrlMapSpecPathMatcher(y)),
    'resourceID': obj.resourceId,
    'test': obj.test?.map(y => toJson_ComputeUrlMapSpecTest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * defaultRouteAction takes effect when none of the hostRules match. The load balancer performs advanced routing actions, such as URL rewrites and header transformations, before forwarding the request to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set. Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
 * Only one of defaultRouteAction or defaultUrlRedirect must be set.
 * URL maps for Classic external HTTP(S) load balancers only support the urlRewrite action within defaultRouteAction.
 * defaultRouteAction has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
 *
 * @schema ComputeUrlMapSpecDefaultRouteAction
 */
export interface ComputeUrlMapSpecDefaultRouteAction {
  /**
   * The specification for allowing client side cross-origin requests. Please see
   * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#corsPolicy
   */
  readonly corsPolicy?: ComputeUrlMapSpecDefaultRouteActionCorsPolicy;

  /**
   * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
   * As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
   * Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
   * timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
   * Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy;

  /**
   * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
   * The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
   * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#requestMirrorPolicy
   */
  readonly requestMirrorPolicy?: ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy;

  /**
   * Specifies the retry policy associated with this route.
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#retryPolicy
   */
  readonly retryPolicy?: ComputeUrlMapSpecDefaultRouteActionRetryPolicy;

  /**
   * Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
   * If not specified, this field uses the largest timeout among all backend services associated with the route.
   * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#timeout
   */
  readonly timeout?: ComputeUrlMapSpecDefaultRouteActionTimeout;

  /**
   * The spec to modify the URL of the request, before forwarding the request to the matched service.
   * urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
   * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#urlRewrite
   */
  readonly urlRewrite?: ComputeUrlMapSpecDefaultRouteActionUrlRewrite;

  /**
   * A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number.
   * After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
   *
   * @schema ComputeUrlMapSpecDefaultRouteAction#weightedBackendServices
   */
  readonly weightedBackendServices?: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteAction(obj: ComputeUrlMapSpecDefaultRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_ComputeUrlMapSpecDefaultRouteActionCorsPolicy(obj.corsPolicy),
    'faultInjectionPolicy': toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'requestMirrorPolicy': toJson_ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy(obj.requestMirrorPolicy),
    'retryPolicy': toJson_ComputeUrlMapSpecDefaultRouteActionRetryPolicy(obj.retryPolicy),
    'timeout': toJson_ComputeUrlMapSpecDefaultRouteActionTimeout(obj.timeout),
    'urlRewrite': toJson_ComputeUrlMapSpecDefaultRouteActionUrlRewrite(obj.urlRewrite),
    'weightedBackendServices': obj.weightedBackendServices?.map(y => toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The defaultService resource to which traffic is directed if none of
 * the hostRules match.
 * For the Global URL Map, it should be a reference to the backend
 * service or backend bucket.
 * For the Regional URL Map, it should be a reference to the backend
 * service.
 * If defaultRouteAction is additionally specified, advanced routing
 * actions like URL Rewrites, etc. take effect prior to sending the
 * request to the backend. However, if defaultService is specified,
 * defaultRouteAction cannot contain any weightedBackendServices.
 * Conversely, if routeAction specifies any weightedBackendServices,
 * service must not be specified. Only one of defaultService,
 * defaultUrlRedirect or defaultRouteAction.weightedBackendService
 * must be set.
 *
 * @schema ComputeUrlMapSpecDefaultService
 */
export interface ComputeUrlMapSpecDefaultService {
  /**
   * @schema ComputeUrlMapSpecDefaultService#backendBucketRef
   */
  readonly backendBucketRef?: ComputeUrlMapSpecDefaultServiceBackendBucketRef;

  /**
   * @schema ComputeUrlMapSpecDefaultService#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecDefaultServiceBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultService(obj: ComputeUrlMapSpecDefaultService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendBucketRef': toJson_ComputeUrlMapSpecDefaultServiceBackendBucketRef(obj.backendBucketRef),
    'backendServiceRef': toJson_ComputeUrlMapSpecDefaultServiceBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When none of the specified hostRules match, the request is redirected to a URL specified
 * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
 * defaultRouteAction must not be set.
 *
 * @schema ComputeUrlMapSpecDefaultUrlRedirect
 */
export interface ComputeUrlMapSpecDefaultUrlRedirect {
  /**
   * The host that will be used in the redirect response instead of the one that was
   * supplied in the request. The value must be between 1 and 255 characters.
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#hostRedirect
   */
  readonly hostRedirect?: string;

  /**
   * If set to true, the URL scheme in the redirected request is set to https. If set to
   * false, the URL scheme of the redirected request will remain the same as that of the
   * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
   * true for TargetHttpsProxy is not permitted. The default is set to false.
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * The path that will be used in the redirect response instead of the one that was
   * supplied in the request. pathRedirect cannot be supplied together with
   * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
   * original request will be used for the redirect. The value must be between 1 and 1024
   * characters.
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#pathRedirect
   */
  readonly pathRedirect?: string;

  /**
   * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
   * retaining the remaining portion of the URL before redirecting the request.
   * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
   * neither. If neither is supplied, the path of the original request will be used for
   * the redirect. The value must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#prefixRedirect
   */
  readonly prefixRedirect?: string;

  /**
   * The HTTP Status code to use for this RedirectAction. Supported values are:
   *
   * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
   *
   * * FOUND, which corresponds to 302.
   *
   * * SEE_OTHER which corresponds to 303.
   *
   * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
   * will be retained.
   *
   * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
   * the request method will be retained. Possible values: ["FOUND", "MOVED_PERMANENTLY_DEFAULT", "PERMANENT_REDIRECT", "SEE_OTHER", "TEMPORARY_REDIRECT"].
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#redirectResponseCode
   */
  readonly redirectResponseCode?: string;

  /**
   * If set to true, any accompanying query portion of the original URL is removed prior
   * to redirecting the request. If set to false, the query portion of the original URL is
   * retained.
   * This field is required to ensure an empty block is not set. The normal default value is false.
   *
   * @schema ComputeUrlMapSpecDefaultUrlRedirect#stripQuery
   */
  readonly stripQuery: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultUrlRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultUrlRedirect(obj: ComputeUrlMapSpecDefaultUrlRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRedirect': obj.hostRedirect,
    'httpsRedirect': obj.httpsRedirect,
    'pathRedirect': obj.pathRedirect,
    'prefixRedirect': obj.prefixRedirect,
    'redirectResponseCode': obj.redirectResponseCode,
    'stripQuery': obj.stripQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService. The headerAction specified here take effect after
 * headerAction specified under pathMatcher.
 *
 * @schema ComputeUrlMapSpecHeaderAction
 */
export interface ComputeUrlMapSpecHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the
   * backendService.
   *
   * @schema ComputeUrlMapSpecHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request
   * prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response
   * prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecHeaderAction(obj: ComputeUrlMapSpecHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecHostRule
 */
export interface ComputeUrlMapSpecHostRule {
  /**
   * An optional description of this HostRule. Provide this property
   * when you create the resource.
   *
   * @schema ComputeUrlMapSpecHostRule#description
   */
  readonly description?: string;

  /**
   * The list of host patterns to match. They must be valid
   * hostnames, except * will match any string of ([a-z0-9-.]*). In
   * that case, * must be the first character and must be followed in
   * the pattern by either - or ..
   *
   * @schema ComputeUrlMapSpecHostRule#hosts
   */
  readonly hosts: string[];

  /**
   * The name of the PathMatcher to use to match the path portion of
   * the URL if the hostRule matches the URL's host portion.
   *
   * @schema ComputeUrlMapSpecHostRule#pathMatcher
   */
  readonly pathMatcher: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecHostRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecHostRule(obj: ComputeUrlMapSpecHostRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'hosts': obj.hosts?.map(y => y),
    'pathMatcher': obj.pathMatcher,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcher
 */
export interface ComputeUrlMapSpecPathMatcher {
  /**
   * defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
   * advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
   * to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
   * Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
   *
   * Only one of defaultRouteAction or defaultUrlRedirect must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcher#defaultRouteAction
   */
  readonly defaultRouteAction?: ComputeUrlMapSpecPathMatcherDefaultRouteAction;

  /**
   * The default service to use if none of the pathRules defined by this
   * PathMatcher is matched by the URL's path portion.
   * For the Global URL Map, it should be a reference to the backend
   * service or backend bucket.
   * For the Regional URL Map, it should be a reference to the backend
   * service.
   *
   * @schema ComputeUrlMapSpecPathMatcher#defaultService
   */
  readonly defaultService?: ComputeUrlMapSpecPathMatcherDefaultService;

  /**
   * When none of the specified hostRules match, the request is redirected to a URL specified
   * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
   * defaultRouteAction must not be set.
   *
   * @schema ComputeUrlMapSpecPathMatcher#defaultUrlRedirect
   */
  readonly defaultUrlRedirect?: ComputeUrlMapSpecPathMatcherDefaultUrlRedirect;

  /**
   * An optional description of this resource.
   *
   * @schema ComputeUrlMapSpecPathMatcher#description
   */
  readonly description?: string;

  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService. HeaderAction specified here are applied after the
   * matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap.
   *
   * @schema ComputeUrlMapSpecPathMatcher#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecPathMatcherHeaderAction;

  /**
   * The name to which this PathMatcher is referred by the HostRule.
   *
   * @schema ComputeUrlMapSpecPathMatcher#name
   */
  readonly name: string;

  /**
   * The list of path rules. Use this list instead of routeRules when routing based
   * on simple path matching is all that's required. The order by which path rules
   * are specified does not matter. Matches are always done on the longest-path-first
   * basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/*
   * irrespective of the order in which those paths appear in this list. Within a
   * given pathMatcher, only one of pathRules or routeRules must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcher#pathRule
   */
  readonly pathRule?: ComputeUrlMapSpecPathMatcherPathRule[];

  /**
   * The list of ordered HTTP route rules. Use this list instead of pathRules when
   * advanced route matching and routing actions are desired. The order of specifying
   * routeRules matters: the first rule that matches will cause its specified routing
   * action to take effect. Within a given pathMatcher, only one of pathRules or
   * routeRules must be set. routeRules are not supported in UrlMaps intended for
   * External load balancers.
   *
   * @schema ComputeUrlMapSpecPathMatcher#routeRules
   */
  readonly routeRules?: ComputeUrlMapSpecPathMatcherRouteRules[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcher(obj: ComputeUrlMapSpecPathMatcher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultRouteAction': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteAction(obj.defaultRouteAction),
    'defaultService': toJson_ComputeUrlMapSpecPathMatcherDefaultService(obj.defaultService),
    'defaultUrlRedirect': toJson_ComputeUrlMapSpecPathMatcherDefaultUrlRedirect(obj.defaultUrlRedirect),
    'description': obj.description,
    'headerAction': toJson_ComputeUrlMapSpecPathMatcherHeaderAction(obj.headerAction),
    'name': obj.name,
    'pathRule': obj.pathRule?.map(y => toJson_ComputeUrlMapSpecPathMatcherPathRule(y)),
    'routeRules': obj.routeRules?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecTest
 */
export interface ComputeUrlMapSpecTest {
  /**
   * Description of this test case.
   *
   * @schema ComputeUrlMapSpecTest#description
   */
  readonly description?: string;

  /**
   * Host portion of the URL.
   *
   * @schema ComputeUrlMapSpecTest#host
   */
  readonly host: string;

  /**
   * Path portion of the URL.
   *
   * @schema ComputeUrlMapSpecTest#path
   */
  readonly path: string;

  /**
   * The backend service resource that should be matched by this test.
   * For the Global URL Map, it should be a reference to the backend
   * service or backend bucket.
   * For the Regional URL Map, it should be a reference to the backend
   * service.
   *
   * @schema ComputeUrlMapSpecTest#service
   */
  readonly service: ComputeUrlMapSpecTestService;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecTest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecTest(obj: ComputeUrlMapSpecTest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'host': obj.host,
    'path': obj.path,
    'service': toJson_ComputeUrlMapSpecTestService(obj.service),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for allowing client side cross-origin requests. Please see
 * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy
 */
export interface ComputeUrlMapSpecDefaultRouteActionCorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header.
   * Default is false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Specifies the content for the Access-Control-Allow-Headers header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Specifies the content for the Access-Control-Allow-Methods header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Specifies the regualar expression patterns that match allowed origins. For regular expression grammar
   * please see en.cppreference.com/w/cpp/regex/ecmascript
   * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#allowOriginRegexes
   */
  readonly allowOriginRegexes?: string[];

  /**
   * Specifies the list of origins that will be allowed to do CORS requests.
   * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#disabled
   */
  readonly disabled?: boolean;

  /**
   * Specifies the content for the Access-Control-Expose-Headers header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long results of a preflight request can be cached in seconds.
   * This translates to the Access-Control-Max-Age header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionCorsPolicy#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionCorsPolicy(obj: ComputeUrlMapSpecDefaultRouteActionCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOriginRegexes': obj.allowOriginRegexes?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'disabled': obj.disabled,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
 * As part of fault injection, when clients send requests to a backend service, delays can be introduced by a load balancer on a percentage of requests before sending those requests to the backend service.
 * Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
 * timeout and retryPolicy is ignored by clients that are configured with a faultInjectionPolicy if: 1. The traffic is generated by fault injection AND 2. The fault injection is not a delay fault injection.
 * Fault injection is not supported with the global external HTTP(S) load balancer (classic). To see which load balancers support fault injection, see Load balancing: [Routing and traffic management features](https://cloud.google.com/load-balancing/docs/features#routing-traffic-management).
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy
 */
export interface ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy {
  /**
   * The specification for how client requests are aborted as part of fault injection.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy#abort
   */
  readonly abort?: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort;

  /**
   * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy#delay
   */
  readonly delay?: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy(obj: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
 * The load balancer does not wait for responses from the shadow service. Before sending traffic to the shadow service, the host / authority header is suffixed with -shadow.
 * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy
 */
export interface ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy {
  /**
   * The backend service resource being mirrored to.
   * The backend service configured for a mirroring policy must reference
   * backends that are of the same type as the original backend service
   * matched in the URL map.
   * Serverless NEG backends are not currently supported as a mirrored
   * backend service.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy(obj: ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the retry policy associated with this route.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicy
 */
export interface ComputeUrlMapSpecDefaultRouteActionRetryPolicy {
  /**
   * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicy#numRetries
   */
  readonly numRetries?: number;

  /**
   * Specifies a non-zero timeout per retry attempt.
   *
   * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
   * will use the largest timeout among all backend services associated with the route.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout;

  /**
   * Specifies one or more conditions when this retry policy applies.
   * Valid values are listed below. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
   * - 5xx : retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams.
   * - gateway-error : Similar to 5xx, but only applies to response codes 502, 503 or 504.
   * - connect-failure : a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts.
   * - retriable-4xx : a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409.
   * - refused-stream : a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
   * - cancelled : a retry is attempted if the gRPC status code in the response header is set to cancelled.
   * - deadline-exceeded : a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded.
   * - internal :  a retry is attempted if the gRPC status code in the response header is set to internal.
   * - resource-exhausted : a retry is attempted if the gRPC status code in the response header is set to resource-exhausted.
   * - unavailable : a retry is attempted if the gRPC status code in the response header is set to unavailable.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionRetryPolicy(obj: ComputeUrlMapSpecDefaultRouteActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'perTryTimeout': toJson_ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout(obj.perTryTimeout),
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the timeout for the selected route. Timeout is computed from the time the request has been fully processed (known as end-of-stream) up until the response has been processed. Timeout includes all retries.
 * If not specified, this field uses the largest timeout among all backend services associated with the route.
 * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionTimeout
 */
export interface ComputeUrlMapSpecDefaultRouteActionTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionTimeout#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionTimeout(obj: ComputeUrlMapSpecDefaultRouteActionTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The spec to modify the URL of the request, before forwarding the request to the matched service.
 * urlRewrite is the only action supported in UrlMaps for external HTTP(S) load balancers.
 * Not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionUrlRewrite
 */
export interface ComputeUrlMapSpecDefaultRouteActionUrlRewrite {
  /**
   * Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite.
   * The value must be from 1 to 255 characters.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionUrlRewrite#hostRewrite
   */
  readonly hostRewrite?: string;

  /**
   * Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite.
   * The value must be from 1 to 1024 characters.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionUrlRewrite#pathPrefixRewrite
   */
  readonly pathPrefixRewrite?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionUrlRewrite(obj: ComputeUrlMapSpecDefaultRouteActionUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRewrite': obj.hostRewrite,
    'pathPrefixRewrite': obj.pathPrefixRewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices
 */
export interface ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices {
  /**
   * The default backend service resource.
   * Before forwarding the request to backendService, the loadbalancer
   * applies any relevant headerActions specified as part of this
   * backendServiceWeight.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef;

  /**
   * Specifies changes to request and response headers that need to take effect for the selected backendService.
   * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
   * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
   * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction;

  /**
   * Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) .
   * The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy.
   * The value must be from 0 to 1000.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices(obj: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef(obj.backendServiceRef),
    'headerAction': toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction(obj.headerAction),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecDefaultServiceBackendBucketRef
 */
export interface ComputeUrlMapSpecDefaultServiceBackendBucketRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendBucket` resource.
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultServiceBackendBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultServiceBackendBucketRef(obj: ComputeUrlMapSpecDefaultServiceBackendBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecDefaultServiceBackendServiceRef
 */
export interface ComputeUrlMapSpecDefaultServiceBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecDefaultServiceBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultServiceBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultServiceBackendServiceRef(obj: ComputeUrlMapSpecDefaultServiceBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * defaultRouteAction takes effect when none of the pathRules or routeRules match. The load balancer performs
 * advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request
 * to the selected backend. If defaultRouteAction specifies any weightedBackendServices, defaultService must not be set.
 * Conversely if defaultService is set, defaultRouteAction cannot contain any weightedBackendServices.
 *
 * Only one of defaultRouteAction or defaultUrlRedirect must be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteAction {
  /**
   * The specification for allowing client side cross-origin requests. Please see
   * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#corsPolicy
   */
  readonly corsPolicy?: ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy;

  /**
   * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
   * As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
   * percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
   * by the Loadbalancer for a percentage of requests.
   *
   * timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy;

  /**
   * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
   * Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
   * the host / authority header is suffixed with -shadow.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#requestMirrorPolicy
   */
  readonly requestMirrorPolicy?: ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy;

  /**
   * Specifies the retry policy associated with this route.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#retryPolicy
   */
  readonly retryPolicy?: ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy;

  /**
   * Specifies the timeout for the selected route. Timeout is computed from the time the request has been
   * fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
   *
   * If not specified, will use the largest timeout among all backend services associated with the route.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#timeout
   */
  readonly timeout?: ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout;

  /**
   * The spec to modify the URL of the request, prior to forwarding the request to the matched service.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#urlRewrite
   */
  readonly urlRewrite?: ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite;

  /**
   * A list of weighted backend services to send traffic to when a route match occurs.
   * The weights determine the fraction of traffic that flows to their corresponding backend service.
   * If all traffic needs to go to a single backend service, there must be one weightedBackendService
   * with weight set to a non 0 number.
   *
   * Once a backendService is identified and before forwarding the request to the backend service,
   * advanced routing actions like Url rewrites and header transformations are applied depending on
   * additional settings specified in this HttpRouteAction.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteAction#weightedBackendServices
   */
  readonly weightedBackendServices?: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteAction(obj: ComputeUrlMapSpecPathMatcherDefaultRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy(obj.corsPolicy),
    'faultInjectionPolicy': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'requestMirrorPolicy': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy(obj.requestMirrorPolicy),
    'retryPolicy': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy(obj.retryPolicy),
    'timeout': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout(obj.timeout),
    'urlRewrite': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite(obj.urlRewrite),
    'weightedBackendServices': obj.weightedBackendServices?.map(y => toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The default service to use if none of the pathRules defined by this
 * PathMatcher is matched by the URL's path portion.
 * For the Global URL Map, it should be a reference to the backend
 * service or backend bucket.
 * For the Regional URL Map, it should be a reference to the backend
 * service.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultService
 */
export interface ComputeUrlMapSpecPathMatcherDefaultService {
  /**
   * @schema ComputeUrlMapSpecPathMatcherDefaultService#backendBucketRef
   */
  readonly backendBucketRef?: ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef;

  /**
   * @schema ComputeUrlMapSpecPathMatcherDefaultService#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultService(obj: ComputeUrlMapSpecPathMatcherDefaultService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendBucketRef': toJson_ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef(obj.backendBucketRef),
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When none of the specified hostRules match, the request is redirected to a URL specified
 * by defaultUrlRedirect. If defaultUrlRedirect is specified, defaultService or
 * defaultRouteAction must not be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect
 */
export interface ComputeUrlMapSpecPathMatcherDefaultUrlRedirect {
  /**
   * The host that will be used in the redirect response instead of the one that was
   * supplied in the request. The value must be between 1 and 255 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#hostRedirect
   */
  readonly hostRedirect?: string;

  /**
   * If set to true, the URL scheme in the redirected request is set to https. If set to
   * false, the URL scheme of the redirected request will remain the same as that of the
   * request. This must only be set for UrlMaps used in TargetHttpProxys. Setting this
   * true for TargetHttpsProxy is not permitted. The default is set to false.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * The path that will be used in the redirect response instead of the one that was
   * supplied in the request. pathRedirect cannot be supplied together with
   * prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the
   * original request will be used for the redirect. The value must be between 1 and 1024
   * characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#pathRedirect
   */
  readonly pathRedirect?: string;

  /**
   * The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch,
   * retaining the remaining portion of the URL before redirecting the request.
   * prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or
   * neither. If neither is supplied, the path of the original request will be used for
   * the redirect. The value must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#prefixRedirect
   */
  readonly prefixRedirect?: string;

  /**
   * The HTTP Status code to use for this RedirectAction. Supported values are:
   *
   * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
   *
   * * FOUND, which corresponds to 302.
   *
   * * SEE_OTHER which corresponds to 303.
   *
   * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
   * will be retained.
   *
   * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
   * the request method will be retained. Possible values: ["FOUND", "MOVED_PERMANENTLY_DEFAULT", "PERMANENT_REDIRECT", "SEE_OTHER", "TEMPORARY_REDIRECT"].
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#redirectResponseCode
   */
  readonly redirectResponseCode?: string;

  /**
   * If set to true, any accompanying query portion of the original URL is removed prior
   * to redirecting the request. If set to false, the query portion of the original URL is
   * retained.
   * This field is required to ensure an empty block is not set. The normal default value is false.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultUrlRedirect#stripQuery
   */
  readonly stripQuery: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultUrlRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultUrlRedirect(obj: ComputeUrlMapSpecPathMatcherDefaultUrlRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRedirect': obj.hostRedirect,
    'httpsRedirect': obj.httpsRedirect,
    'pathRedirect': obj.pathRedirect,
    'prefixRedirect': obj.prefixRedirect,
    'redirectResponseCode': obj.redirectResponseCode,
    'stripQuery': obj.stripQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService. HeaderAction specified here are applied after the
 * matching HttpRouteRule HeaderAction and before the HeaderAction in the UrlMap.
 *
 * @schema ComputeUrlMapSpecPathMatcherHeaderAction
 */
export interface ComputeUrlMapSpecPathMatcherHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the
   * backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request
   * prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response
   * prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherHeaderAction(obj: ComputeUrlMapSpecPathMatcherHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRule
 */
export interface ComputeUrlMapSpecPathMatcherPathRule {
  /**
   * The list of path patterns to match. Each must start with / and the only place a
   * \* is allowed is at the end following a /. The string fed to the path matcher
   * does not include any text after the first ? or #, and those chars are not
   * allowed here.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRule#paths
   */
  readonly paths: string[];

  /**
   * In response to a matching path, the load balancer performs advanced routing
   * actions like URL rewrites, header transformations, etc. prior to forwarding the
   * request to the selected backend. If routeAction specifies any
   * weightedBackendServices, service must not be set. Conversely if service is set,
   * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
   * or urlRedirect must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRule#routeAction
   */
  readonly routeAction?: ComputeUrlMapSpecPathMatcherPathRuleRouteAction;

  /**
   * The backend service to which traffic is directed if this rule is
   * matched.
   * For the Global URL Map, it should be a reference to the backend
   * service or backend bucket.
   * For the Regional URL Map, it should be a reference to the backend
   * service.
   * If routeAction is additionally specified, advanced routing actions
   * like URL Rewrites, etc. take effect prior to sending the request to
   * the backend. However, if service is specified, routeAction cannot
   * contain any weightedBackendServices. Conversely, if routeAction
   * specifies any weightedBackendServices, service must not be
   * specified. Only one of urlRedirect, service or
   * routeAction.weightedBackendService must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRule#service
   */
  readonly service?: ComputeUrlMapSpecPathMatcherPathRuleService;

  /**
   * When a path pattern is matched, the request is redirected to a URL specified
   * by urlRedirect. If urlRedirect is specified, service or routeAction must not
   * be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRule#urlRedirect
   */
  readonly urlRedirect?: ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRule(obj: ComputeUrlMapSpecPathMatcherPathRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'paths': obj.paths?.map(y => y),
    'routeAction': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteAction(obj.routeAction),
    'service': toJson_ComputeUrlMapSpecPathMatcherPathRuleService(obj.service),
    'urlRedirect': toJson_ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect(obj.urlRedirect),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRules
 */
export interface ComputeUrlMapSpecPathMatcherRouteRules {
  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService. The headerAction specified here are applied before
   * the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
   * outeAction.weightedBackendService.backendServiceWeightAction[].headerAction.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction;

  /**
   * The rules for determining a match.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#matchRules
   */
  readonly matchRules?: ComputeUrlMapSpecPathMatcherRouteRulesMatchRules[];

  /**
   * For routeRules within a given pathMatcher, priority determines the order
   * in which load balancer will interpret routeRules. RouteRules are evaluated
   * in order of priority, from the lowest to highest number. The priority of
   * a rule decreases as its number increases (1, 2, 3, N+1). The first rule
   * that matches the request is applied.
   *
   * You cannot configure two or more routeRules with the same priority.
   * Priority for each rule must be set to a number between 0 and
   * 2147483647 inclusive.
   *
   * Priority numbers can have gaps, which enable you to add or remove rules
   * in the future without affecting the rest of the rules. For example,
   * 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which
   * you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the
   * future without any impact on existing rules.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#priority
   */
  readonly priority: number;

  /**
   * In response to a matching matchRule, the load balancer performs advanced routing
   * actions like URL rewrites, header transformations, etc. prior to forwarding the
   * request to the selected backend. If  routeAction specifies any
   * weightedBackendServices, service must not be set. Conversely if service is set,
   * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
   * or urlRedirect must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#routeAction
   */
  readonly routeAction?: ComputeUrlMapSpecPathMatcherRouteRulesRouteAction;

  /**
   * The region backend service resource to which traffic is
   * directed if this rule is matched. If routeAction is additionally specified,
   * advanced routing actions like URL Rewrites, etc. take effect prior to sending
   * the request to the backend. However, if service is specified, routeAction cannot
   * contain any weightedBackendService s. Conversely, if routeAction specifies any
   * weightedBackendServices, service must not be specified. Only one of urlRedirect,
   * service or routeAction.weightedBackendService must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#service
   */
  readonly service?: string;

  /**
   * When this rule is matched, the request is redirected to a URL specified by
   * urlRedirect. If urlRedirect is specified, service or routeAction must not be
   * set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRules#urlRedirect
   */
  readonly urlRedirect?: ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRules(obj: ComputeUrlMapSpecPathMatcherRouteRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerAction': toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction(obj.headerAction),
    'matchRules': obj.matchRules?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRules(y)),
    'priority': obj.priority,
    'routeAction': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteAction(obj.routeAction),
    'service': obj.service,
    'urlRedirect': toJson_ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect(obj.urlRedirect),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backend service resource that should be matched by this test.
 * For the Global URL Map, it should be a reference to the backend
 * service or backend bucket.
 * For the Regional URL Map, it should be a reference to the backend
 * service.
 *
 * @schema ComputeUrlMapSpecTestService
 */
export interface ComputeUrlMapSpecTestService {
  /**
   * @schema ComputeUrlMapSpecTestService#backendBucketRef
   */
  readonly backendBucketRef?: ComputeUrlMapSpecTestServiceBackendBucketRef;

  /**
   * @schema ComputeUrlMapSpecTestService#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecTestServiceBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecTestService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecTestService(obj: ComputeUrlMapSpecTestService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendBucketRef': toJson_ComputeUrlMapSpecTestServiceBackendBucketRef(obj.backendBucketRef),
    'backendServiceRef': toJson_ComputeUrlMapSpecTestServiceBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are aborted as part of fault injection.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort
 */
export interface ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request.
   * The value must be between 200 and 599 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
   * The value must be between 0.0 and 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort(obj: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay
 */
export interface ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay {
  /**
   * Specifies the value of the fixed delay interval.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay?: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay;

  /**
   * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
   * The value must be between 0.0 and 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay(obj: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(obj.fixedDelay),
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backend service resource being mirrored to.
 * The backend service configured for a mirroring policy must reference
 * backends that are of the same type as the original backend service
 * matched in the URL map.
 * Serverless NEG backends are not currently supported as a mirrored
 * backend service.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef
 */
export interface ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef(obj: ComputeUrlMapSpecDefaultRouteActionRequestMirrorPolicyBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a non-zero timeout per retry attempt.
 *
 * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
 * will use the largest timeout among all backend services associated with the route.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout
 */
export interface ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
   * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
   * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout(obj: ComputeUrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The default backend service resource.
 * Before forwarding the request to backendService, the loadbalancer
 * applies any relevant headerActions specified as part of this
 * backendServiceWeight.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef
 */
export interface ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef(obj: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for the selected backendService.
 * headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
 * headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL.
 * Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction
 */
export interface ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction {
  /**
   * Headers to add to a matching request before forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response before sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response before sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction(obj: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for allowing client side cross-origin requests. Please see
 * [W3C Recommendation for Cross Origin Resource Sharing](https://www.w3.org/TR/cors/).
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
   * This translates to the Access-Control-Allow-Credentials header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Specifies the content for the Access-Control-Allow-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Specifies the content for the Access-Control-Allow-Methods header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Specifies the regular expression patterns that match allowed origins. For regular expression grammar
   * please see en.cppreference.com/w/cpp/regex/ecmascript
   * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#allowOriginRegexes
   */
  readonly allowOriginRegexes?: string[];

  /**
   * Specifies the list of origins that will be allowed to do CORS requests.
   * An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#disabled
   */
  readonly disabled?: boolean;

  /**
   * Specifies the content for the Access-Control-Expose-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long results of a preflight request can be cached in seconds.
   * This translates to the Access-Control-Max-Age header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOriginRegexes': obj.allowOriginRegexes?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'disabled': obj.disabled,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
 * As part of fault injection, when clients send requests to a backend service, delays can be introduced by Loadbalancer on a
 * percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted
 * by the Loadbalancer for a percentage of requests.
 *
 * timeout and retryPolicy will be ignored by clients that are configured with a faultInjectionPolicy.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy {
  /**
   * The specification for how client requests are aborted as part of fault injection.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy#abort
   */
  readonly abort?: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort;

  /**
   * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy#delay
   */
  readonly delay?: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the policy on how requests intended for the route's backends are shadowed to a separate mirrored backend service.
 * Loadbalancer does not wait for responses from the shadow service. Prior to sending traffic to the shadow service,
 * the host / authority header is suffixed with -shadow.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy {
  /**
   * Required. The backend service resource being mirrored to.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy#backendServiceRef
   */
  readonly backendServiceRef: ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the retry policy associated with this route.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy {
  /**
   * Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy#numRetries
   */
  readonly numRetries?: number;

  /**
   * Specifies a non-zero timeout per retry attempt.
   *
   * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
   * will use the largest timeout among all backend services associated with the route.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout;

  /**
   * Specfies one or more conditions when this retry rule applies. Valid values are:
   *
   * * 5xx: Loadbalancer will attempt a retry if the backend service responds with any 5xx response code,
   * or if the backend service does not respond at all, example: disconnects, reset, read timeout,
   * * connection failure, and refused streams.
   * * gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504.
   * * connect-failure: Loadbalancer will retry on failures connecting to backend services,
   * for example due to connection timeouts.
   * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
   * Currently the only retriable error supported is 409.
   * * refused-stream:Loadbalancer will retry if the backend service resets the stream with a REFUSED_STREAM error code.
   * This reset type indicates that it is safe to retry.
   * * cancelled: Loadbalancer will retry if the gRPC status code in the response header is set to cancelled
   * * deadline-exceeded: Loadbalancer will retry if the gRPC status code in the response header is set to deadline-exceeded
   * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response header is set to resource-exhausted
   * * unavailable: Loadbalancer will retry if the gRPC status code in the response header is set to unavailable.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'perTryTimeout': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(obj.perTryTimeout),
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the timeout for the selected route. Timeout is computed from the time the request has been
 * fully processed (i.e. end-of-stream) up until the response has been completely processed. Timeout includes all retries.
 *
 * If not specified, will use the largest timeout among all backend services associated with the route.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented
   * with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
   * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The spec to modify the URL of the request, prior to forwarding the request to the matched service.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite {
  /**
   * Prior to forwarding the request to the selected service, the request's host header is replaced
   * with contents of hostRewrite.
   *
   * The value must be between 1 and 255 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite#hostRewrite
   */
  readonly hostRewrite?: string;

  /**
   * Prior to forwarding the request to the selected backend service, the matching portion of the
   * request's path is replaced by pathPrefixRewrite.
   *
   * The value must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite#pathPrefixRewrite
   */
  readonly pathPrefixRewrite?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRewrite': obj.hostRewrite,
    'pathPrefixRewrite': obj.pathPrefixRewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices {
  /**
   * The default backend service resource.
   * Before forwarding the request to backendService, the loadbalancer
   * applies any relevant headerActions specified as part of this
   * backendServiceWeight.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef;

  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService.
   *
   * headerAction specified here take effect before headerAction in the enclosing
   * HttpRouteRule, PathMatcher and UrlMap.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction;

  /**
   * Specifies the fraction of traffic sent to backendService, computed as
   * weight / (sum of all weightedBackendService weights in routeAction) .
   *
   * The selection of a backend service is determined only for new traffic. Once a user's request
   * has been directed to a backendService, subsequent requests will be sent to the same backendService
   * as determined by the BackendService's session affinity policy.
   *
   * The value must be between 0 and 1000.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef(obj.backendServiceRef),
    'headerAction': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction(obj.headerAction),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef
 */
export interface ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendBucket` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef(obj: ComputeUrlMapSpecPathMatcherDefaultServiceBackendBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherDefaultServiceBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * In response to a matching path, the load balancer performs advanced routing
 * actions like URL rewrites, header transformations, etc. prior to forwarding the
 * request to the selected backend. If routeAction specifies any
 * weightedBackendServices, service must not be set. Conversely if service is set,
 * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
 * or urlRedirect must be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteAction {
  /**
   * The specification for allowing client side cross-origin requests. Please see W3C
   * Recommendation for Cross Origin Resource Sharing.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#corsPolicy
   */
  readonly corsPolicy?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy;

  /**
   * The specification for fault injection introduced into traffic to test the
   * resiliency of clients to backend service failure. As part of fault injection,
   * when clients send requests to a backend service, delays can be introduced by
   * Loadbalancer on a percentage of requests before sending those request to the
   * backend service. Similarly requests from clients can be aborted by the
   * Loadbalancer for a percentage of requests. timeout and retry_policy will be
   * ignored by clients that are configured with a fault_injection_policy.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy;

  /**
   * Specifies the policy on how requests intended for the route's backends are
   * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
   * responses from the shadow service. Prior to sending traffic to the shadow
   * service, the host / authority header is suffixed with -shadow.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#requestMirrorPolicy
   */
  readonly requestMirrorPolicy?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy;

  /**
   * Specifies the retry policy associated with this route.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#retryPolicy
   */
  readonly retryPolicy?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy;

  /**
   * Specifies the timeout for the selected route. Timeout is computed from the time
   * the request is has been fully processed (i.e. end-of-stream) up until the
   * response has been completely processed. Timeout includes all retries. If not
   * specified, the default value is 15 seconds.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#timeout
   */
  readonly timeout?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout;

  /**
   * The spec to modify the URL of the request, prior to forwarding the request to
   * the matched service.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#urlRewrite
   */
  readonly urlRewrite?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite;

  /**
   * A list of weighted backend services to send traffic to when a route match
   * occurs. The weights determine the fraction of traffic that flows to their
   * corresponding backend service. If all traffic needs to go to a single backend
   * service, there must be one  weightedBackendService with weight set to a non 0
   * number. Once a backendService is identified and before forwarding the request to
   * the backend service, advanced routing actions like Url rewrites and header
   * transformations are applied depending on additional settings specified in this
   * HttpRouteAction.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteAction#weightedBackendServices
   */
  readonly weightedBackendServices?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteAction(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy(obj.corsPolicy),
    'faultInjectionPolicy': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'requestMirrorPolicy': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy(obj.requestMirrorPolicy),
    'retryPolicy': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy(obj.retryPolicy),
    'timeout': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout(obj.timeout),
    'urlRewrite': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite(obj.urlRewrite),
    'weightedBackendServices': obj.weightedBackendServices?.map(y => toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The backend service to which traffic is directed if this rule is
 * matched.
 * For the Global URL Map, it should be a reference to the backend
 * service or backend bucket.
 * For the Regional URL Map, it should be a reference to the backend
 * service.
 * If routeAction is additionally specified, advanced routing actions
 * like URL Rewrites, etc. take effect prior to sending the request to
 * the backend. However, if service is specified, routeAction cannot
 * contain any weightedBackendServices. Conversely, if routeAction
 * specifies any weightedBackendServices, service must not be
 * specified. Only one of urlRedirect, service or
 * routeAction.weightedBackendService must be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleService
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleService {
  /**
   * @schema ComputeUrlMapSpecPathMatcherPathRuleService#backendBucketRef
   */
  readonly backendBucketRef?: ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef;

  /**
   * @schema ComputeUrlMapSpecPathMatcherPathRuleService#backendServiceRef
   */
  readonly backendServiceRef?: ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleService(obj: ComputeUrlMapSpecPathMatcherPathRuleService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendBucketRef': toJson_ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef(obj.backendBucketRef),
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When a path pattern is matched, the request is redirected to a URL specified
 * by urlRedirect. If urlRedirect is specified, service or routeAction must not
 * be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect {
  /**
   * The host that will be used in the redirect response instead of the one
   * that was supplied in the request. The value must be between 1 and 255
   * characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#hostRedirect
   */
  readonly hostRedirect?: string;

  /**
   * If set to true, the URL scheme in the redirected request is set to https.
   * If set to false, the URL scheme of the redirected request will remain the
   * same as that of the request. This must only be set for UrlMaps used in
   * TargetHttpProxys. Setting this true for TargetHttpsProxy is not
   * permitted. The default is set to false.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * The path that will be used in the redirect response instead of the one
   * that was supplied in the request. pathRedirect cannot be supplied
   * together with prefixRedirect. Supply one alone or neither. If neither is
   * supplied, the path of the original request will be used for the redirect.
   * The value must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#pathRedirect
   */
  readonly pathRedirect?: string;

  /**
   * The prefix that replaces the prefixMatch specified in the
   * HttpRouteRuleMatch, retaining the remaining portion of the URL before
   * redirecting the request. prefixRedirect cannot be supplied together with
   * pathRedirect. Supply one alone or neither. If neither is supplied, the
   * path of the original request will be used for the redirect. The value
   * must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#prefixRedirect
   */
  readonly prefixRedirect?: string;

  /**
   * The HTTP Status code to use for this RedirectAction. Supported values are:
   *
   * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
   *
   * * FOUND, which corresponds to 302.
   *
   * * SEE_OTHER which corresponds to 303.
   *
   * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
   * will be retained.
   *
   * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
   * the request method will be retained. Possible values: ["FOUND", "MOVED_PERMANENTLY_DEFAULT", "PERMANENT_REDIRECT", "SEE_OTHER", "TEMPORARY_REDIRECT"].
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#redirectResponseCode
   */
  readonly redirectResponseCode?: string;

  /**
   * If set to true, any accompanying query portion of the original URL is removed
   * prior to redirecting the request. If set to false, the query portion of the
   * original URL is retained.
   * This field is required to ensure an empty block is not set. The normal default value is false.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect#stripQuery
   */
  readonly stripQuery: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect(obj: ComputeUrlMapSpecPathMatcherPathRuleUrlRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRedirect': obj.hostRedirect,
    'httpsRedirect': obj.httpsRedirect,
    'pathRedirect': obj.pathRedirect,
    'prefixRedirect': obj.prefixRedirect,
    'redirectResponseCode': obj.redirectResponseCode,
    'stripQuery': obj.stripQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService. The headerAction specified here are applied before
 * the matching pathMatchers[].headerAction and after pathMatchers[].routeRules[].r
 * outeAction.weightedBackendService.backendServiceWeightAction[].headerAction.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the
   * backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request
   * prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response
   * prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction(obj: ComputeUrlMapSpecPathMatcherRouteRulesHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRules {
  /**
   * For satisfying the matchRule condition, the path of the request must exactly
   * match the value specified in fullPathMatch after removing any query parameters
   * and anchor that may be part of the original URL. FullPathMatch must be between 1
   * and 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must
   * be specified.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#fullPathMatch
   */
  readonly fullPathMatch?: string;

  /**
   * Specifies a list of header match criteria, all of which must match corresponding
   * headers in the request.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#headerMatches
   */
  readonly headerMatches?: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches[];

  /**
   * Specifies that prefixMatch and fullPathMatch matches are case sensitive.
   * Defaults to false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#ignoreCase
   */
  readonly ignoreCase?: boolean;

  /**
   * Opaque filter criteria used by Loadbalancer to restrict routing configuration to
   * a limited set xDS compliant clients. In their xDS requests to Loadbalancer, xDS
   * clients present node metadata. If a match takes place, the relevant routing
   * configuration is made available to those proxies. For each metadataFilter in
   * this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the
   * filterLabels must match the corresponding label provided in the metadata. If its
   * filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match
   * with corresponding labels in the provided metadata. metadataFilters specified
   * here can be overrides those specified in ForwardingRule that refers to this
   * UrlMap. metadataFilters only applies to Loadbalancers that have their
   * loadBalancingScheme set to INTERNAL_SELF_MANAGED.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#metadataFilters
   */
  readonly metadataFilters?: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters[];

  /**
   * For satisfying the matchRule condition, the path of the request
   * must match the wildcard pattern specified in pathTemplateMatch
   * after removing any query parameters and anchor that may be part
   * of the original URL.
   *
   * pathTemplateMatch must be between 1 and 255 characters
   * (inclusive).  The pattern specified by pathTemplateMatch may
   * have at most 5 wildcard operators and at most 5 variable
   * captures in total.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#pathTemplateMatch
   */
  readonly pathTemplateMatch?: string;

  /**
   * For satisfying the matchRule condition, the request's path must begin with the
   * specified prefixMatch. prefixMatch must begin with a /. The value must be
   * between 1 and 1024 characters. Only one of prefixMatch, fullPathMatch or
   * regexMatch must be specified.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#prefixMatch
   */
  readonly prefixMatch?: string;

  /**
   * Specifies a list of query parameter match criteria, all of which must match
   * corresponding query parameters in the request.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#queryParameterMatches
   */
  readonly queryParameterMatches?: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches[];

  /**
   * For satisfying the matchRule condition, the path of the request must satisfy the
   * regular expression specified in regexMatch after removing any query parameters
   * and anchor supplied with the original URL. For regular expression grammar please
   * see en.cppreference.com/w/cpp/regex/ecmascript  Only one of prefixMatch,
   * fullPathMatch or regexMatch must be specified.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRules#regexMatch
   */
  readonly regexMatch?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRules(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fullPathMatch': obj.fullPathMatch,
    'headerMatches': obj.headerMatches?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches(y)),
    'ignoreCase': obj.ignoreCase,
    'metadataFilters': obj.metadataFilters?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters(y)),
    'pathTemplateMatch': obj.pathTemplateMatch,
    'prefixMatch': obj.prefixMatch,
    'queryParameterMatches': obj.queryParameterMatches?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches(y)),
    'regexMatch': obj.regexMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * In response to a matching matchRule, the load balancer performs advanced routing
 * actions like URL rewrites, header transformations, etc. prior to forwarding the
 * request to the selected backend. If  routeAction specifies any
 * weightedBackendServices, service must not be set. Conversely if service is set,
 * routeAction cannot contain any  weightedBackendServices. Only one of routeAction
 * or urlRedirect must be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteAction {
  /**
   * The specification for allowing client side cross-origin requests. Please see W3C
   * Recommendation for Cross Origin Resource Sharing.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#corsPolicy
   */
  readonly corsPolicy?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy;

  /**
   * The specification for fault injection introduced into traffic to test the
   * resiliency of clients to backend service failure. As part of fault injection,
   * when clients send requests to a backend service, delays can be introduced by
   * Loadbalancer on a percentage of requests before sending those request to the
   * backend service. Similarly requests from clients can be aborted by the
   * Loadbalancer for a percentage of requests. timeout and retry_policy will be
   * ignored by clients that are configured with a fault_injection_policy.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy;

  /**
   * Specifies the policy on how requests intended for the route's backends are
   * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
   * responses from the shadow service. Prior to sending traffic to the shadow
   * service, the host / authority header is suffixed with -shadow.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#requestMirrorPolicy
   */
  readonly requestMirrorPolicy?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy;

  /**
   * Specifies the retry policy associated with this route.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#retryPolicy
   */
  readonly retryPolicy?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy;

  /**
   * Specifies the timeout for the selected route. Timeout is computed from the time
   * the request is has been fully processed (i.e. end-of-stream) up until the
   * response has been completely processed. Timeout includes all retries. If not
   * specified, the default value is 15 seconds.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#timeout
   */
  readonly timeout?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout;

  /**
   * The spec to modify the URL of the request, prior to forwarding the request to
   * the matched service.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#urlRewrite
   */
  readonly urlRewrite?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite;

  /**
   * A list of weighted backend services to send traffic to when a route match
   * occurs. The weights determine the fraction of traffic that flows to their
   * corresponding backend service. If all traffic needs to go to a single backend
   * service, there must be one  weightedBackendService with weight set to a non 0
   * number. Once a backendService is identified and before forwarding the request to
   * the backend service, advanced routing actions like Url rewrites and header
   * transformations are applied depending on additional settings specified in this
   * HttpRouteAction.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteAction#weightedBackendServices
   */
  readonly weightedBackendServices?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteAction(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy(obj.corsPolicy),
    'faultInjectionPolicy': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'requestMirrorPolicy': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy(obj.requestMirrorPolicy),
    'retryPolicy': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy(obj.retryPolicy),
    'timeout': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout(obj.timeout),
    'urlRewrite': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite(obj.urlRewrite),
    'weightedBackendServices': obj.weightedBackendServices?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When this rule is matched, the request is redirected to a URL specified by
 * urlRedirect. If urlRedirect is specified, service or routeAction must not be
 * set.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect {
  /**
   * The host that will be used in the redirect response instead of the one
   * that was supplied in the request. The value must be between 1 and 255
   * characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#hostRedirect
   */
  readonly hostRedirect?: string;

  /**
   * If set to true, the URL scheme in the redirected request is set to https.
   * If set to false, the URL scheme of the redirected request will remain the
   * same as that of the request. This must only be set for UrlMaps used in
   * TargetHttpProxys. Setting this true for TargetHttpsProxy is not
   * permitted. The default is set to false.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * The path that will be used in the redirect response instead of the one
   * that was supplied in the request. pathRedirect cannot be supplied
   * together with prefixRedirect. Supply one alone or neither. If neither is
   * supplied, the path of the original request will be used for the redirect.
   * The value must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#pathRedirect
   */
  readonly pathRedirect?: string;

  /**
   * The prefix that replaces the prefixMatch specified in the
   * HttpRouteRuleMatch, retaining the remaining portion of the URL before
   * redirecting the request. prefixRedirect cannot be supplied together with
   * pathRedirect. Supply one alone or neither. If neither is supplied, the
   * path of the original request will be used for the redirect. The value
   * must be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#prefixRedirect
   */
  readonly prefixRedirect?: string;

  /**
   * The HTTP Status code to use for this RedirectAction. Supported values are:
   *
   * * MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301.
   *
   * * FOUND, which corresponds to 302.
   *
   * * SEE_OTHER which corresponds to 303.
   *
   * * TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method
   * will be retained.
   *
   * * PERMANENT_REDIRECT, which corresponds to 308. In this case,
   * the request method will be retained. Possible values: ["FOUND", "MOVED_PERMANENTLY_DEFAULT", "PERMANENT_REDIRECT", "SEE_OTHER", "TEMPORARY_REDIRECT"].
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#redirectResponseCode
   */
  readonly redirectResponseCode?: string;

  /**
   * If set to true, any accompanying query portion of the original URL is
   * removed prior to redirecting the request. If set to false, the query
   * portion of the original URL is retained. The default value is false.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect#stripQuery
   */
  readonly stripQuery?: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect(obj: ComputeUrlMapSpecPathMatcherRouteRulesUrlRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRedirect': obj.hostRedirect,
    'httpsRedirect': obj.httpsRedirect,
    'pathRedirect': obj.pathRedirect,
    'prefixRedirect': obj.prefixRedirect,
    'redirectResponseCode': obj.redirectResponseCode,
    'stripQuery': obj.stripQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecTestServiceBackendBucketRef
 */
export interface ComputeUrlMapSpecTestServiceBackendBucketRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendBucket` resource.
   *
   * @schema ComputeUrlMapSpecTestServiceBackendBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecTestServiceBackendBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecTestServiceBackendBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecTestServiceBackendBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecTestServiceBackendBucketRef(obj: ComputeUrlMapSpecTestServiceBackendBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecTestServiceBackendServiceRef
 */
export interface ComputeUrlMapSpecTestServiceBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecTestServiceBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecTestServiceBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecTestServiceBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecTestServiceBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecTestServiceBackendServiceRef(obj: ComputeUrlMapSpecTestServiceBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the value of the fixed delay interval.
 *
 * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
 */
export interface ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
   * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
   * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(obj: ComputeUrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName?: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue?: string;

  /**
   * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
   * The default value is false.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace?: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName?: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue?: string;

  /**
   * If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header.
   * The default value is false.
   *
   * @schema ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace?: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are aborted as part of fault injection.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request.
   * The value must be between 200 and 599 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * The percentage of traffic (connections/operations/requests) which will be aborted as part of fault injection.
   * The value must be between 0.0 and 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are delayed as part of fault injection, before being sent to a backend service.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay {
  /**
   * Specifies the value of the fixed delay interval.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay?: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay;

  /**
   * The percentage of traffic (connections/operations/requests) on which delay will be introduced as part of fault injection.
   * The value must be between 0.0 and 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(obj.fixedDelay),
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The backend service resource being mirrored to.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a non-zero timeout per retry attempt.
 *
 * If not specified, will use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is not set,
 * will use the largest timeout among all backend services associated with the route.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
   * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
   * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The default backend service resource.
 * Before forwarding the request to backendService, the loadbalancer
 * applies any relevant headerActions specified as part of this
 * backendServiceWeight.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService.
 *
 * headerAction specified here take effect before headerAction in the enclosing
 * HttpRouteRule, PathMatcher and UrlMap.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request prior to
   * forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response prior to sending the
   * response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for allowing client side cross-origin requests. Please see W3C
 * Recommendation for Cross Origin Resource Sharing.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that the
   * actual request can include user credentials. This translates to the Access-
   * Control-Allow-Credentials header. Defaults to false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Specifies the content for the Access-Control-Allow-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Specifies the content for the Access-Control-Allow-Methods header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Specifies the regular expression patterns that match allowed origins. For
   * regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
   * An origin is allowed if it matches either allow_origins or allow_origin_regex.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#allowOriginRegexes
   */
  readonly allowOriginRegexes?: string[];

  /**
   * Specifies the list of origins that will be allowed to do CORS requests. An
   * origin is allowed if it matches either allow_origins or allow_origin_regex.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * If true, specifies the CORS policy is disabled.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#disabled
   */
  readonly disabled: boolean;

  /**
   * Specifies the content for the Access-Control-Expose-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached. This
   * translates to the content for the Access-Control-Max-Age header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOriginRegexes': obj.allowOriginRegexes?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'disabled': obj.disabled,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to backend service failure. As part of fault injection,
 * when clients send requests to a backend service, delays can be introduced by
 * Loadbalancer on a percentage of requests before sending those request to the
 * backend service. Similarly requests from clients can be aborted by the
 * Loadbalancer for a percentage of requests. timeout and retry_policy will be
 * ignored by clients that are configured with a fault_injection_policy.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy {
  /**
   * The specification for how client requests are aborted as part of fault
   * injection.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy#abort
   */
  readonly abort?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort;

  /**
   * The specification for how client requests are delayed as part of fault
   * injection, before being sent to a backend service.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy#delay
   */
  readonly delay?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the policy on how requests intended for the route's backends are
 * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
 * responses from the shadow service. Prior to sending traffic to the shadow
 * service, the host / authority header is suffixed with -shadow.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy {
  /**
   * Required. The backend service resource being mirrored to.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy#backendServiceRef
   */
  readonly backendServiceRef: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the retry policy associated with this route.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy {
  /**
   * Specifies the allowed number retries. This number must be > 0.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy#numRetries
   */
  readonly numRetries?: number;

  /**
   * Specifies a non-zero timeout per retry attempt.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout;

  /**
   * Specifies one or more conditions when this retry rule applies. Valid values are:
   *
   * - 5xx: Loadbalancer will attempt a retry if the backend service responds with
   * any 5xx response code, or if the backend service does not respond at all,
   * example: disconnects, reset, read timeout, connection failure, and refused
   * streams.
   * - gateway-error: Similar to 5xx, but only applies to response codes
   * 502, 503 or 504.
   * - connect-failure: Loadbalancer will retry on failures
   * connecting to backend services, for example due to connection timeouts.
   * - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
   * Currently the only retriable error supported is 409.
   * - refused-stream: Loadbalancer will retry if the backend service resets the stream with a
   * REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
   * - cancelled: Loadbalancer will retry if the gRPC status code in the response
   * header is set to cancelled
   * - deadline-exceeded: Loadbalancer will retry if the
   * gRPC status code in the response header is set to deadline-exceeded
   * - resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
   * header is set to resource-exhausted
   * - unavailable: Loadbalancer will retry if
   * the gRPC status code in the response header is set to unavailable.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'perTryTimeout': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(obj.perTryTimeout),
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the timeout for the selected route. Timeout is computed from the time
 * the request is has been fully processed (i.e. end-of-stream) up until the
 * response has been completely processed. Timeout includes all retries. If not
 * specified, the default value is 15 seconds.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The spec to modify the URL of the request, prior to forwarding the request to
 * the matched service.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite {
  /**
   * Prior to forwarding the request to the selected service, the request's host
   * header is replaced with contents of hostRewrite. The value must be between 1 and
   * 255 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite#hostRewrite
   */
  readonly hostRewrite?: string;

  /**
   * Prior to forwarding the request to the selected backend service, the matching
   * portion of the request's path is replaced by pathPrefixRewrite. The value must
   * be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite#pathPrefixRewrite
   */
  readonly pathPrefixRewrite?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRewrite': obj.hostRewrite,
    'pathPrefixRewrite': obj.pathPrefixRewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices {
  /**
   * Required. The default backend service resource. Before forwarding
   * the request to backendService, the loadbalancer applies any relevant
   * headerActions specified as part of this backendServiceWeight.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices#backendServiceRef
   */
  readonly backendServiceRef: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef;

  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService. headerAction specified here take effect before
   * headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction;

  /**
   * Specifies the fraction of traffic sent to backendService, computed as weight /
   * (sum of all weightedBackendService weights in routeAction) . The selection of a
   * backend service is determined only for new traffic. Once a user's request has
   * been directed to a backendService, subsequent requests will be sent to the same
   * backendService as determined by the BackendService's session affinity policy.
   * The value must be between 0 and 1000.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef(obj.backendServiceRef),
    'headerAction': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction(obj.headerAction),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendBucket` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef(obj: ComputeUrlMapSpecPathMatcherPathRuleServiceBackendBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherPathRuleServiceBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherRouteRulesHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches {
  /**
   * The value should exactly match contents of exactMatch. Only one of exactMatch,
   * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#exactMatch
   */
  readonly exactMatch?: string;

  /**
   * The name of the HTTP header to match. For matching against the HTTP request's
   * authority, use a headerMatch with the header name ":authority". For matching a
   * request's method, use the headerName ":method".
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#headerName
   */
  readonly headerName: string;

  /**
   * If set to false, the headerMatch is considered a match if the match criteria
   * above are met. If set to true, the headerMatch is considered a match if the
   * match criteria above are NOT met. Defaults to false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#invertMatch
   */
  readonly invertMatch?: boolean;

  /**
   * The value of the header must start with the contents of prefixMatch. Only one of
   * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
   * must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#prefixMatch
   */
  readonly prefixMatch?: string;

  /**
   * A header with the contents of headerName must exist. The match takes place
   * whether or not the request's header has a value or not. Only one of exactMatch,
   * prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#presentMatch
   */
  readonly presentMatch?: boolean;

  /**
   * The header value must be an integer and its value must be in the range specified
   * in rangeMatch. If the header does not contain an integer, number or is empty,
   * the match fails. For example for a range [-5, 0]
   *
   * * -3 will match
   * * 0 will not match
   * * 0.25 will not match
   * * -3someString will not match.
   *
   * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
   * rangeMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#rangeMatch
   */
  readonly rangeMatch?: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch;

  /**
   * The value of the header must match the regular expression specified in
   * regexMatch. For regular expression grammar, please see:
   * en.cppreference.com/w/cpp/regex/ecmascript  For matching against a port
   * specified in the HTTP request, use a headerMatch with headerName set to PORT and
   * a regular expression that satisfies the RFC2616 Host header's port specifier.
   * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
   * rangeMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#regexMatch
   */
  readonly regexMatch?: string;

  /**
   * The value of the header must end with the contents of suffixMatch. Only one of
   * exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch
   * must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches#suffixMatch
   */
  readonly suffixMatch?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exactMatch': obj.exactMatch,
    'headerName': obj.headerName,
    'invertMatch': obj.invertMatch,
    'prefixMatch': obj.prefixMatch,
    'presentMatch': obj.presentMatch,
    'rangeMatch': toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch(obj.rangeMatch),
    'regexMatch': obj.regexMatch,
    'suffixMatch': obj.suffixMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters {
  /**
   * The list of label value pairs that must match labels in the provided metadata
   * based on filterMatchCriteria  This list must not be empty and can have at the
   * most 64 entries.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters#filterLabels
   */
  readonly filterLabels: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels[];

  /**
   * Specifies how individual filterLabel matches within the list of filterLabels
   * contribute towards the overall metadataFilter match. Supported values are:
   *
   * * MATCH_ANY: At least one of the filterLabels must have a matching label in the
   * provided metadata.
   * * MATCH_ALL: All filterLabels must have matching labels in
   * the provided metadata. Possible values: ["MATCH_ALL", "MATCH_ANY"].
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters#filterMatchCriteria
   */
  readonly filterMatchCriteria: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFilters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterLabels': obj.filterLabels?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels(y)),
    'filterMatchCriteria': obj.filterMatchCriteria,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches {
  /**
   * The queryParameterMatch matches if the value of the parameter exactly matches
   * the contents of exactMatch. Only one of presentMatch, exactMatch and regexMatch
   * must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches#exactMatch
   */
  readonly exactMatch?: string;

  /**
   * The name of the query parameter to match. The query parameter must exist in the
   * request, in the absence of which the request match fails.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches#name
   */
  readonly name: string;

  /**
   * Specifies that the queryParameterMatch matches if the request contains the query
   * parameter, irrespective of whether the parameter has a value or not. Only one of
   * presentMatch, exactMatch and regexMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches#presentMatch
   */
  readonly presentMatch?: boolean;

  /**
   * The queryParameterMatch matches if the value of the parameter matches the
   * regular expression specified by regexMatch. For the regular expression grammar,
   * please see en.cppreference.com/w/cpp/regex/ecmascript  Only one of presentMatch,
   * exactMatch and regexMatch must be set.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches#regexMatch
   */
  readonly regexMatch?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesQueryParameterMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exactMatch': obj.exactMatch,
    'name': obj.name,
    'presentMatch': obj.presentMatch,
    'regexMatch': obj.regexMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for allowing client side cross-origin requests. Please see W3C
 * Recommendation for Cross Origin Resource Sharing.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that the
   * actual request can include user credentials. This translates to the Access-
   * Control-Allow-Credentials header. Defaults to false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Specifies the content for the Access-Control-Allow-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Specifies the content for the Access-Control-Allow-Methods header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Specifies the regular expression patterns that match allowed origins. For
   * regular expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
   * An origin is allowed if it matches either allow_origins or allow_origin_regex.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#allowOriginRegexes
   */
  readonly allowOriginRegexes?: string[];

  /**
   * Specifies the list of origins that will be allowed to do CORS requests. An
   * origin is allowed if it matches either allow_origins or allow_origin_regex.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * If true, specifies the CORS policy is disabled.
   * which indicates that the CORS policy is in effect. Defaults to false.
   *
   * @default false.
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#disabled
   */
  readonly disabled?: boolean;

  /**
   * Specifies the content for the Access-Control-Expose-Headers header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached. This
   * translates to the content for the Access-Control-Max-Age header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy#maxAge
   */
  readonly maxAge?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOriginRegexes': obj.allowOriginRegexes?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'disabled': obj.disabled,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to backend service failure. As part of fault injection,
 * when clients send requests to a backend service, delays can be introduced by
 * Loadbalancer on a percentage of requests before sending those request to the
 * backend service. Similarly requests from clients can be aborted by the
 * Loadbalancer for a percentage of requests. timeout and retry_policy will be
 * ignored by clients that are configured with a fault_injection_policy.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy {
  /**
   * The specification for how client requests are aborted as part of fault
   * injection.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy#abort
   */
  readonly abort?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort;

  /**
   * The specification for how client requests are delayed as part of fault
   * injection, before being sent to a backend service.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy#delay
   */
  readonly delay?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the policy on how requests intended for the route's backends are
 * shadowed to a separate mirrored backend service. Loadbalancer does not wait for
 * responses from the shadow service. Prior to sending traffic to the shadow
 * service, the host / authority header is suffixed with -shadow.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy {
  /**
   * Required. The backend service resource being mirrored to.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy#backendServiceRef
   */
  readonly backendServiceRef: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef(obj.backendServiceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the retry policy associated with this route.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy {
  /**
   * Specifies the allowed number retries. This number must be > 0.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy#numRetries
   */
  readonly numRetries: number;

  /**
   * Specifies a non-zero timeout per retry attempt.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout;

  /**
   * Specifies one or more conditions when this retry rule applies. Valid values are:
   *
   * * 5xx: Loadbalancer will attempt a retry if the backend service responds with
   * any 5xx response code, or if the backend service does not respond at all,
   * example: disconnects, reset, read timeout, connection failure, and refused
   * streams.
   * * gateway-error: Similar to 5xx, but only applies to response codes
   * 502, 503 or 504.
   * * connect-failure: Loadbalancer will retry on failures
   * connecting to backend services, for example due to connection timeouts.
   * * retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
   * Currently the only retriable error supported is 409.
   * * refused-stream: Loadbalancer will retry if the backend service resets the stream with a
   * REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
   * * cancelled: Loadbalancer will retry if the gRPC status code in the response
   * header is set to cancelled
   * * deadline-exceeded: Loadbalancer will retry if the
   * gRPC status code in the response header is set to deadline-exceeded
   * * resource-exhausted: Loadbalancer will retry if the gRPC status code in the response
   * header is set to resource-exhausted
   * * unavailable: Loadbalancer will retry if the gRPC status code in
   * the response header is set to unavailable.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'perTryTimeout': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout(obj.perTryTimeout),
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the timeout for the selected route. Timeout is computed from the time
 * the request is has been fully processed (i.e. end-of-stream) up until the
 * response has been completely processed. Timeout includes all retries. If not
 * specified, the default value is 15 seconds.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The spec to modify the URL of the request, prior to forwarding the request to
 * the matched service.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite {
  /**
   * Prior to forwarding the request to the selected service, the request's host
   * header is replaced with contents of hostRewrite. The value must be between 1 and
   * 255 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite#hostRewrite
   */
  readonly hostRewrite?: string;

  /**
   * Prior to forwarding the request to the selected backend service, the matching
   * portion of the request's path is replaced by pathPrefixRewrite. The value must
   * be between 1 and 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite#pathPrefixRewrite
   */
  readonly pathPrefixRewrite?: string;

  /**
   * Prior to forwarding the request to the selected origin, if the
   * request matched a pathTemplateMatch, the matching portion of the
   * request's path is replaced re-written using the pattern specified
   * by pathTemplateRewrite.
   *
   * pathTemplateRewrite must be between 1 and 255 characters
   * (inclusive), must start with a '/', and must only use variables
   * captured by the route's pathTemplate matchers.
   *
   * pathTemplateRewrite may only be used when all of a route's
   * MatchRules specify pathTemplate.
   *
   * Only one of pathPrefixRewrite and pathTemplateRewrite may be
   * specified.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite#pathTemplateRewrite
   */
  readonly pathTemplateRewrite?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRewrite': obj.hostRewrite,
    'pathPrefixRewrite': obj.pathPrefixRewrite,
    'pathTemplateRewrite': obj.pathTemplateRewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices {
  /**
   * Required. The default backend service resource. Before forwarding
   * the request to backendService, the loadbalancer applies any relevant
   * headerActions specified as part of this backendServiceWeight.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices#backendServiceRef
   */
  readonly backendServiceRef: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef;

  /**
   * Specifies changes to request and response headers that need to take effect for
   * the selected backendService. headerAction specified here take effect before
   * headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices#headerAction
   */
  readonly headerAction?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction;

  /**
   * Specifies the fraction of traffic sent to backendService, computed as weight /
   * (sum of all weightedBackendService weights in routeAction) . The selection of a
   * backend service is determined only for new traffic. Once a user's request has
   * been directed to a backendService, subsequent requests will be sent to the same
   * backendService as determined by the BackendService's session affinity policy.
   * The value must be between 0 and 1000.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backendServiceRef': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef(obj.backendServiceRef),
    'headerAction': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction(obj.headerAction),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the value of the fixed delay interval.
 *
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are
   * represented with a 0 seconds field and a positive nanos field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive.
   * Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay#seconds
   */
  readonly seconds?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName?: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue?: string;

  /**
   * If false, headerValue is appended to any values that already exist for the header.
   * If true, headerValue is set for the header, discarding any values that were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace?: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName?: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue?: string;

  /**
   * If false, headerValue is appended to any values that already exist for the header.
   * If true, headerValue is set for the header, discarding any values that were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace?: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are aborted as part of fault
 * injection.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request. The value must be between 200
   * and 599 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus: number;

  /**
   * The percentage of traffic (connections/operations/requests) which will be
   * aborted as part of fault injection. The value must be between 0.0 and 100.0
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are delayed as part of fault
 * injection, before being sent to a backend service.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay {
  /**
   * Specifies the value of the fixed delay interval.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay;

  /**
   * The percentage of traffic (connections/operations/requests) on which delay will
   * be introduced as part of fault injection. The value must be between 0.0 and
   * 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(obj.fixedDelay),
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The backend service resource being mirrored to.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a non-zero timeout per retry attempt.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The default backend service resource. Before forwarding
 * the request to backendService, the loadbalancer applies any relevant
 * headerActions specified as part of this backendServiceWeight.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService. headerAction specified here take effect before
 * headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the
   * backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request
   * prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response
   * prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The header value must be an integer and its value must be in the range specified
 * in rangeMatch. If the header does not contain an integer, number or is empty,
 * the match fails. For example for a range [-5, 0]
 *
 * * -3 will match
 * * 0 will not match
 * * 0.25 will not match
 * * -3someString will not match.
 *
 * Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
 * rangeMatch must be set.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch {
  /**
   * The end of the range (exclusive).
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch#rangeEnd
   */
  readonly rangeEnd: number;

  /**
   * The start of the range (inclusive).
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch#rangeStart
   */
  readonly rangeStart: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rangeEnd': obj.rangeEnd,
    'rangeStart': obj.rangeStart,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels {
  /**
   * Name of metadata label. The name can have a maximum length of 1024 characters
   * and must be at least 1 character long.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels#name
   */
  readonly name: string;

  /**
   * The value of the label must match the specified value. value can have a maximum
   * length of 1024 characters.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels(obj: ComputeUrlMapSpecPathMatcherRouteRulesMatchRulesMetadataFiltersFilterLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are aborted as part of fault
 * injection.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request. The value must be between 200
   * and 599 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * The percentage of traffic (connections/operations/requests) which will be
   * aborted as part of fault injection. The value must be between 0.0 and 100.0
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for how client requests are delayed as part of fault
 * injection, before being sent to a backend service.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay {
  /**
   * Specifies the value of the fixed delay interval.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay;

  /**
   * The percentage of traffic (connections/operations/requests) on which delay will
   * be introduced as part of fault injection. The value must be between 0.0 and
   * 100.0 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay(obj.fixedDelay),
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The backend service resource being mirrored to.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies a non-zero timeout per retry attempt.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The default backend service resource. Before forwarding
 * the request to backendService, the loadbalancer applies any relevant
 * headerActions specified as part of this backendServiceWeight.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeBackendService` resource.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesBackendServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies changes to request and response headers that need to take effect for
 * the selected backendService. headerAction specified here take effect before
 * headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction {
  /**
   * Headers to add to a matching request prior to forwarding the request to the
   * backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction#requestHeadersToAdd
   */
  readonly requestHeadersToAdd?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the request
   * prior to forwarding the request to the backendService.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction#requestHeadersToRemove
   */
  readonly requestHeadersToRemove?: string[];

  /**
   * Headers to add the response prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd[];

  /**
   * A list of header names for headers that need to be removed from the response
   * prior to sending the response back to the client.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction#responseHeadersToRemove
   */
  readonly responseHeadersToRemove?: string[];

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeadersToAdd': obj.requestHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(y)),
    'requestHeadersToRemove': obj.requestHeadersToRemove?.map(y => y),
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(y)),
    'responseHeadersToRemove': obj.responseHeadersToRemove?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the value of the fixed delay interval.
 *
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the value of the fixed delay interval.
 *
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay {
  /**
   * Span of time that's a fraction of a second at nanosecond resolution. Durations
   * less than one second are represented with a 0 'seconds' field and a positive
   * 'nanos' field. Must be from 0 to 999,999,999 inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay#nanos
   */
  readonly nanos?: number;

  /**
   * Span of time at a resolution of a second. Must be from 0 to 315,576,000,000
   * inclusive.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay#seconds
   */
  readonly seconds: string;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionRequestHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd
 */
export interface ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd {
  /**
   * The name of the header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerName
   */
  readonly headerName: string;

  /**
   * The value of the header to add.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#headerValue
   */
  readonly headerValue: string;

  /**
   * If false, headerValue is appended to any values that already exist for the
   * header. If true, headerValue is set for the header, discarding any values that
   * were set for that header.
   *
   * @schema ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd#replace
   */
  readonly replace: boolean;

}

/**
 * Converts an object of type 'ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd(obj: ComputeUrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
    'headerValue': obj.headerValue,
    'replace': obj.replace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeVPNGateway
 */
export class ComputeVpnGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeVPNGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeVPNGateway',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeVPNGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeVpnGatewayProps): any {
    return {
      ...ComputeVpnGateway.GVK,
      ...toJson_ComputeVpnGatewayProps(props),
    };
  }

  /**
   * Defines a "ComputeVPNGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeVpnGatewayProps) {
    super(scope, id, {
      ...ComputeVpnGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeVpnGateway.GVK,
      ...toJson_ComputeVpnGatewayProps(resolved),
    };
  }
}

/**
 * @schema ComputeVPNGateway
 */
export interface ComputeVpnGatewayProps {
  /**
   * @schema ComputeVPNGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeVPNGateway#spec
   */
  readonly spec: ComputeVpnGatewaySpec;

}

/**
 * Converts an object of type 'ComputeVpnGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnGatewayProps(obj: ComputeVpnGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeVpnGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeVpnGatewaySpec
 */
export interface ComputeVpnGatewaySpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeVpnGatewaySpec#description
   */
  readonly description?: string;

  /**
   * The network this VPN gateway is accepting traffic for.
   *
   * @schema ComputeVpnGatewaySpec#networkRef
   */
  readonly networkRef: ComputeVpnGatewaySpecNetworkRef;

  /**
   * Immutable. The region this gateway should sit in.
   *
   * @schema ComputeVpnGatewaySpec#region
   */
  readonly region: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeVpnGatewaySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. The stack type for this VPN gateway to identify the IP protocols that are enabled.
   * If not specified, IPV4_ONLY will be used. Default value: "IPV4_ONLY" Possible values: ["IPV4_ONLY", "IPV4_IPV6"].
   *
   * @schema ComputeVpnGatewaySpec#stackType
   */
  readonly stackType?: string;

  /**
   * Immutable. A list of interfaces on this VPN gateway.
   *
   * @schema ComputeVpnGatewaySpec#vpnInterfaces
   */
  readonly vpnInterfaces?: ComputeVpnGatewaySpecVpnInterfaces[];

}

/**
 * Converts an object of type 'ComputeVpnGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnGatewaySpec(obj: ComputeVpnGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'networkRef': toJson_ComputeVpnGatewaySpecNetworkRef(obj.networkRef),
    'region': obj.region,
    'resourceID': obj.resourceId,
    'stackType': obj.stackType,
    'vpnInterfaces': obj.vpnInterfaces?.map(y => toJson_ComputeVpnGatewaySpecVpnInterfaces(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network this VPN gateway is accepting traffic for.
 *
 * @schema ComputeVpnGatewaySpecNetworkRef
 */
export interface ComputeVpnGatewaySpecNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema ComputeVpnGatewaySpecNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnGatewaySpecNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnGatewaySpecNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnGatewaySpecNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnGatewaySpecNetworkRef(obj: ComputeVpnGatewaySpecNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeVpnGatewaySpecVpnInterfaces
 */
export interface ComputeVpnGatewaySpecVpnInterfaces {
  /**
   * Immutable. The numeric ID of this VPN gateway interface.
   *
   * @schema ComputeVpnGatewaySpecVpnInterfaces#id
   */
  readonly id?: number;

  /**
   * Immutable. When this value is present, the VPN Gateway will be used
   * for IPsec-encrypted Cloud Interconnect; all Egress or Ingress
   * traffic for this VPN Gateway interface will go through the specified
   * interconnect attachment resource. Not currently available publicly.
   *
   * @schema ComputeVpnGatewaySpecVpnInterfaces#interconnectAttachmentRef
   */
  readonly interconnectAttachmentRef?: ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef;

  /**
   * The external IP address for this VPN gateway interface.
   *
   * @schema ComputeVpnGatewaySpecVpnInterfaces#ipAddress
   */
  readonly ipAddress?: string;

}

/**
 * Converts an object of type 'ComputeVpnGatewaySpecVpnInterfaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnGatewaySpecVpnInterfaces(obj: ComputeVpnGatewaySpecVpnInterfaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'interconnectAttachmentRef': toJson_ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef(obj.interconnectAttachmentRef),
    'ipAddress': obj.ipAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. When this value is present, the VPN Gateway will be used
 * for IPsec-encrypted Cloud Interconnect; all Egress or Ingress
 * traffic for this VPN Gateway interface will go through the specified
 * interconnect attachment resource. Not currently available publicly.
 *
 * @schema ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef
 */
export interface ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeInterconnectAttachment` resource.
   *
   * @schema ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef(obj: ComputeVpnGatewaySpecVpnInterfacesInterconnectAttachmentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema ComputeVPNTunnel
 */
export class ComputeVpnTunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ComputeVPNTunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'compute.cnrm.cloud.google.com/v1beta1',
    kind: 'ComputeVPNTunnel',
  }

  /**
   * Renders a Kubernetes manifest for "ComputeVPNTunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComputeVpnTunnelProps): any {
    return {
      ...ComputeVpnTunnel.GVK,
      ...toJson_ComputeVpnTunnelProps(props),
    };
  }

  /**
   * Defines a "ComputeVPNTunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComputeVpnTunnelProps) {
    super(scope, id, {
      ...ComputeVpnTunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ComputeVpnTunnel.GVK,
      ...toJson_ComputeVpnTunnelProps(resolved),
    };
  }
}

/**
 * @schema ComputeVPNTunnel
 */
export interface ComputeVpnTunnelProps {
  /**
   * @schema ComputeVPNTunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ComputeVPNTunnel#spec
   */
  readonly spec: ComputeVpnTunnelSpec;

}

/**
 * Converts an object of type 'ComputeVpnTunnelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelProps(obj: ComputeVpnTunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ComputeVpnTunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ComputeVpnTunnelSpec
 */
export interface ComputeVpnTunnelSpec {
  /**
   * Immutable. An optional description of this resource.
   *
   * @schema ComputeVpnTunnelSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. IKE protocol version to use when establishing the VPN tunnel with
   * peer VPN gateway.
   * Acceptable IKE versions are 1 or 2. Default version is 2.
   *
   * @schema ComputeVpnTunnelSpec#ikeVersion
   */
  readonly ikeVersion?: number;

  /**
   * Immutable. Local traffic selector to use when establishing the VPN tunnel with
   * peer VPN gateway. The value should be a CIDR formatted string,
   * for example '192.168.0.0/16'. The ranges should be disjoint.
   * Only IPv4 is supported.
   *
   * @schema ComputeVpnTunnelSpec#localTrafficSelector
   */
  readonly localTrafficSelector?: string[];

  /**
   * Immutable. The interface ID of the external VPN gateway to which this VPN tunnel is connected.
   *
   * @schema ComputeVpnTunnelSpec#peerExternalGatewayInterface
   */
  readonly peerExternalGatewayInterface?: number;

  /**
   * The peer side external VPN gateway to which this VPN tunnel
   * is connected.
   *
   * @schema ComputeVpnTunnelSpec#peerExternalGatewayRef
   */
  readonly peerExternalGatewayRef?: ComputeVpnTunnelSpecPeerExternalGatewayRef;

  /**
   * The peer side HA GCP VPN gateway to which this VPN tunnel is
   * connected. If provided, the VPN tunnel will automatically use the
   * same VPN gateway interface ID in the peer GCP VPN gateway.
   *
   * @schema ComputeVpnTunnelSpec#peerGCPGatewayRef
   */
  readonly peerGcpGatewayRef?: ComputeVpnTunnelSpecPeerGcpGatewayRef;

  /**
   * Immutable. IP address of the peer VPN gateway. Only IPv4 is supported.
   *
   * @schema ComputeVpnTunnelSpec#peerIp
   */
  readonly peerIp?: string;

  /**
   * Immutable. The region where the tunnel is located. If unset, is set to the region of 'target_vpn_gateway'.
   *
   * @schema ComputeVpnTunnelSpec#region
   */
  readonly region: string;

  /**
   * Immutable. Remote traffic selector to use when establishing the VPN tunnel with
   * peer VPN gateway. The value should be a CIDR formatted string,
   * for example '192.168.0.0/16'. The ranges should be disjoint.
   * Only IPv4 is supported.
   *
   * @schema ComputeVpnTunnelSpec#remoteTrafficSelector
   */
  readonly remoteTrafficSelector?: string[];

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema ComputeVpnTunnelSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The router to be used for dynamic routing.
   *
   * @schema ComputeVpnTunnelSpec#routerRef
   */
  readonly routerRef?: ComputeVpnTunnelSpecRouterRef;

  /**
   * Immutable. Shared secret used to set the secure session between the Cloud VPN
   * gateway and the peer VPN gateway.
   *
   * @schema ComputeVpnTunnelSpec#sharedSecret
   */
  readonly sharedSecret: ComputeVpnTunnelSpecSharedSecret;

  /**
   * The ComputeTargetVPNGateway with which this VPN tunnel is
   * associated.
   *
   * @schema ComputeVpnTunnelSpec#targetVPNGatewayRef
   */
  readonly targetVpnGatewayRef?: ComputeVpnTunnelSpecTargetVpnGatewayRef;

  /**
   * Immutable. The interface ID of the VPN gateway with which this VPN tunnel is associated.
   *
   * @schema ComputeVpnTunnelSpec#vpnGatewayInterface
   */
  readonly vpnGatewayInterface?: number;

  /**
   * The ComputeVPNGateway with which this VPN tunnel is associated.
   * This must be used if a High Availability VPN gateway resource is
   * created.
   *
   * @schema ComputeVpnTunnelSpec#vpnGatewayRef
   */
  readonly vpnGatewayRef?: ComputeVpnTunnelSpecVpnGatewayRef;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpec(obj: ComputeVpnTunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'ikeVersion': obj.ikeVersion,
    'localTrafficSelector': obj.localTrafficSelector?.map(y => y),
    'peerExternalGatewayInterface': obj.peerExternalGatewayInterface,
    'peerExternalGatewayRef': toJson_ComputeVpnTunnelSpecPeerExternalGatewayRef(obj.peerExternalGatewayRef),
    'peerGCPGatewayRef': toJson_ComputeVpnTunnelSpecPeerGcpGatewayRef(obj.peerGcpGatewayRef),
    'peerIp': obj.peerIp,
    'region': obj.region,
    'remoteTrafficSelector': obj.remoteTrafficSelector?.map(y => y),
    'resourceID': obj.resourceId,
    'routerRef': toJson_ComputeVpnTunnelSpecRouterRef(obj.routerRef),
    'sharedSecret': toJson_ComputeVpnTunnelSpecSharedSecret(obj.sharedSecret),
    'targetVPNGatewayRef': toJson_ComputeVpnTunnelSpecTargetVpnGatewayRef(obj.targetVpnGatewayRef),
    'vpnGatewayInterface': obj.vpnGatewayInterface,
    'vpnGatewayRef': toJson_ComputeVpnTunnelSpecVpnGatewayRef(obj.vpnGatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The peer side external VPN gateway to which this VPN tunnel
 * is connected.
 *
 * @schema ComputeVpnTunnelSpecPeerExternalGatewayRef
 */
export interface ComputeVpnTunnelSpecPeerExternalGatewayRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeExternalVPNGateway` resource.
   *
   * @schema ComputeVpnTunnelSpecPeerExternalGatewayRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnTunnelSpecPeerExternalGatewayRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnTunnelSpecPeerExternalGatewayRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecPeerExternalGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecPeerExternalGatewayRef(obj: ComputeVpnTunnelSpecPeerExternalGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The peer side HA GCP VPN gateway to which this VPN tunnel is
 * connected. If provided, the VPN tunnel will automatically use the
 * same VPN gateway interface ID in the peer GCP VPN gateway.
 *
 * @schema ComputeVpnTunnelSpecPeerGcpGatewayRef
 */
export interface ComputeVpnTunnelSpecPeerGcpGatewayRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeVPNGateway` resource.
   *
   * @schema ComputeVpnTunnelSpecPeerGcpGatewayRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnTunnelSpecPeerGcpGatewayRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnTunnelSpecPeerGcpGatewayRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecPeerGcpGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecPeerGcpGatewayRef(obj: ComputeVpnTunnelSpecPeerGcpGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The router to be used for dynamic routing.
 *
 * @schema ComputeVpnTunnelSpecRouterRef
 */
export interface ComputeVpnTunnelSpecRouterRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeRouter` resource.
   *
   * @schema ComputeVpnTunnelSpecRouterRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnTunnelSpecRouterRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnTunnelSpecRouterRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecRouterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecRouterRef(obj: ComputeVpnTunnelSpecRouterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Shared secret used to set the secure session between the Cloud VPN
 * gateway and the peer VPN gateway.
 *
 * @schema ComputeVpnTunnelSpecSharedSecret
 */
export interface ComputeVpnTunnelSpecSharedSecret {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema ComputeVpnTunnelSpecSharedSecret#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema ComputeVpnTunnelSpecSharedSecret#valueFrom
   */
  readonly valueFrom?: ComputeVpnTunnelSpecSharedSecretValueFrom;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecSharedSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecSharedSecret(obj: ComputeVpnTunnelSpecSharedSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_ComputeVpnTunnelSpecSharedSecretValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ComputeTargetVPNGateway with which this VPN tunnel is
 * associated.
 *
 * @schema ComputeVpnTunnelSpecTargetVpnGatewayRef
 */
export interface ComputeVpnTunnelSpecTargetVpnGatewayRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeTargetVPNGateway` resource.
   *
   * @schema ComputeVpnTunnelSpecTargetVpnGatewayRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnTunnelSpecTargetVpnGatewayRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnTunnelSpecTargetVpnGatewayRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecTargetVpnGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecTargetVpnGatewayRef(obj: ComputeVpnTunnelSpecTargetVpnGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The ComputeVPNGateway with which this VPN tunnel is associated.
 * This must be used if a High Availability VPN gateway resource is
 * created.
 *
 * @schema ComputeVpnTunnelSpecVpnGatewayRef
 */
export interface ComputeVpnTunnelSpecVpnGatewayRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeVPNGateway` resource.
   *
   * @schema ComputeVpnTunnelSpecVpnGatewayRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ComputeVpnTunnelSpecVpnGatewayRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ComputeVpnTunnelSpecVpnGatewayRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecVpnGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecVpnGatewayRef(obj: ComputeVpnTunnelSpecVpnGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema ComputeVpnTunnelSpecSharedSecretValueFrom
 */
export interface ComputeVpnTunnelSpecSharedSecretValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema ComputeVpnTunnelSpecSharedSecretValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecSharedSecretValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecSharedSecretValueFrom(obj: ComputeVpnTunnelSpecSharedSecretValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef
 */
export interface ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef(obj: ComputeVpnTunnelSpecSharedSecretValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

