// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema DLPDeidentifyTemplate
 */
export class DlpDeidentifyTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DLPDeidentifyTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dlp.cnrm.cloud.google.com/v1beta1',
    kind: 'DLPDeidentifyTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "DLPDeidentifyTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlpDeidentifyTemplateProps = {}): any {
    return {
      ...DlpDeidentifyTemplate.GVK,
      ...toJson_DlpDeidentifyTemplateProps(props),
    };
  }

  /**
   * Defines a "DLPDeidentifyTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DlpDeidentifyTemplateProps = {}) {
    super(scope, id, {
      ...DlpDeidentifyTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlpDeidentifyTemplate.GVK,
      ...toJson_DlpDeidentifyTemplateProps(resolved),
    };
  }
}

/**
 * @schema DLPDeidentifyTemplate
 */
export interface DlpDeidentifyTemplateProps {
  /**
   * @schema DLPDeidentifyTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DLPDeidentifyTemplate#spec
   */
  readonly spec?: DlpDeidentifyTemplateSpec;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateProps(obj: DlpDeidentifyTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DlpDeidentifyTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpec
 */
export interface DlpDeidentifyTemplateSpec {
  /**
   * The core content of the template.
   *
   * @schema DlpDeidentifyTemplateSpec#deidentifyConfig
   */
  readonly deidentifyConfig?: DlpDeidentifyTemplateSpecDeidentifyConfig;

  /**
   * Short description (max 256 chars).
   *
   * @schema DlpDeidentifyTemplateSpec#description
   */
  readonly description?: string;

  /**
   * Display name (max 256 chars).
   *
   * @schema DlpDeidentifyTemplateSpec#displayName
   */
  readonly displayName?: string;

  /**
   * Immutable. The location of the resource
   *
   * @schema DlpDeidentifyTemplateSpec#location
   */
  readonly location?: string;

  /**
   * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpDeidentifyTemplateSpec#organizationRef
   */
  readonly organizationRef?: DlpDeidentifyTemplateSpecOrganizationRef;

  /**
   * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpDeidentifyTemplateSpec#projectRef
   */
  readonly projectRef?: DlpDeidentifyTemplateSpecProjectRef;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema DlpDeidentifyTemplateSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpec(obj: DlpDeidentifyTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deidentifyConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfig(obj.deidentifyConfig),
    'description': obj.description,
    'displayName': obj.displayName,
    'location': obj.location,
    'organizationRef': toJson_DlpDeidentifyTemplateSpecOrganizationRef(obj.organizationRef),
    'projectRef': toJson_DlpDeidentifyTemplateSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The core content of the template.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfig {
  /**
   * Treat the dataset as free-form text and apply the same free text transformation everywhere.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfig#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations;

  /**
   * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfig#recordTransformations
   */
  readonly recordTransformations?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations;

  /**
   * Mode for handling transformation errors. If left unspecified, the default mode is `TransformationErrorHandling.ThrowError`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfig#transformationErrorHandling
   */
  readonly transformationErrorHandling?: DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypeTransformations': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations(obj.infoTypeTransformations),
    'recordTransformations': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations(obj.recordTransformations),
    'transformationErrorHandling': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling(obj.transformationErrorHandling),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpDeidentifyTemplateSpecOrganizationRef
 */
export interface DlpDeidentifyTemplateSpecOrganizationRef {
  /**
   * Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).
   *
   * @schema DlpDeidentifyTemplateSpecOrganizationRef#external
   */
  readonly external?: string;

  /**
   * [WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecOrganizationRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecOrganizationRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecOrganizationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecOrganizationRef(obj: DlpDeidentifyTemplateSpecOrganizationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpDeidentifyTemplateSpecProjectRef
 */
export interface DlpDeidentifyTemplateSpecProjectRef {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpDeidentifyTemplateSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecProjectRef(obj: DlpDeidentifyTemplateSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Treat the dataset as free-form text and apply the same free text transformation everywhere.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations {
  /**
   * Required. Transformation for each infoType. Cannot specify more than one for a given infoType.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations#transformations
   */
  readonly transformations: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations {
  /**
   * Transform the record by applying various field transformations.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations#fieldTransformations
   */
  readonly fieldTransformations?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations[];

  /**
   * Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations#recordSuppressions
   */
  readonly recordSuppressions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldTransformations': obj.fieldTransformations?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations(y)),
    'recordSuppressions': obj.recordSuppressions?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode for handling transformation errors. If left unspecified, the default mode is `TransformationErrorHandling.ThrowError`.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling {
  /**
   * Ignore errors
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling#leaveUntransformed
   */
  readonly leaveUntransformed?: any;

  /**
   * Throw an error
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling#throwError
   */
  readonly throwError?: any;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling(obj: DlpDeidentifyTemplateSpecDeidentifyConfigTransformationErrorHandling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'leaveUntransformed': obj.leaveUntransformed,
    'throwError': obj.throwError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Required. Primitive transformation to apply to the infoType.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(obj.primitiveTransformation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations {
  /**
   * Only apply the transformation if the condition evaluates to true for the given `RecordCondition`. The conditions are allowed to reference fields that are not used in the actual transformation. Example Use Cases: - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range. - Redact a field if the date of birth field is greater than 85.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations#condition
   */
  readonly condition?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition;

  /**
   * Required. Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations#fields
   */
  readonly fields: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields[];

  /**
   * Treat the contents of the field as free text, and selectively transform content that matches an `InfoType`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations#infoTypeTransformations
   */
  readonly infoTypeTransformations?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations;

  /**
   * Apply the transformation to the entire field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations#primitiveTransformation
   */
  readonly primitiveTransformation?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition(obj.condition),
    'fields': obj.fields?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields(y)),
    'infoTypeTransformations': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(obj.infoTypeTransformations),
    'primitiveTransformation': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(obj.primitiveTransformation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions {
  /**
   * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions#condition
   */
  readonly condition?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(obj.condition),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Primitive transformation to apply to the infoType.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig;

  /**
   * Mask
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig;

  /**
   * Deterministic Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig;

  /**
   * Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig;

  /**
   * Ffx-Fpe
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig;

  /**
   * Date Shift
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig;

  /**
   * Fixed size bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig;

  /**
   * Redact
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any;

  /**
   * Replace with a specified value.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig;

  /**
   * Replace with infotype
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: any;

  /**
   * Time extraction
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj.bucketingConfig),
    'characterMaskConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj.characterMaskConfig),
    'cryptoDeterministicConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj.cryptoDeterministicConfig),
    'cryptoHashConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj.cryptoHashConfig),
    'cryptoReplaceFfxFpeConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj.cryptoReplaceFfxFpeConfig),
    'dateShiftConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj.dateShiftConfig),
    'fixedSizeBucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj.fixedSizeBucketingConfig),
    'redactConfig': obj.redactConfig,
    'replaceConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj.replaceConfig),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
    'timePartConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj.timePartConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Only apply the transformation if the condition evaluates to true for the given `RecordCondition`. The conditions are allowed to reference fields that are not used in the actual transformation. Example Use Cases: - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range. - Redact a field if the date of birth field is greater than 85.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition {
  /**
   * An expression.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition#expressions
   */
  readonly expressions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(obj.expressions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Treat the contents of the field as free text, and selectively transform content that matches an `InfoType`.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations {
  /**
   * Required. Transformation for each infoType. Cannot specify more than one for a given infoType.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations#transformations
   */
  readonly transformations: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'transformations': obj.transformations?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply the transformation to the entire field.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation {
  /**
   * Bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig;

  /**
   * Mask
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig;

  /**
   * Deterministic Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig;

  /**
   * Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig;

  /**
   * Ffx-Fpe
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig;

  /**
   * Date Shift
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig;

  /**
   * Fixed size bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig;

  /**
   * Redact
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any;

  /**
   * Replace with a specified value.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig;

  /**
   * Replace with infotype
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: any;

  /**
   * Time extraction
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(obj.bucketingConfig),
    'characterMaskConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(obj.characterMaskConfig),
    'cryptoDeterministicConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj.cryptoDeterministicConfig),
    'cryptoHashConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(obj.cryptoHashConfig),
    'cryptoReplaceFfxFpeConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj.cryptoReplaceFfxFpeConfig),
    'dateShiftConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(obj.dateShiftConfig),
    'fixedSizeBucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj.fixedSizeBucketingConfig),
    'redactConfig': obj.redactConfig,
    'replaceConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(obj.replaceConfig),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
    'timePartConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(obj.timePartConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition {
  /**
   * An expression.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition#expressions
   */
  readonly expressions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expressions': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(obj.expressions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mask
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deterministic Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext;

  /**
   * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey;

  /**
   * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj.cryptoKey),
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the hash function.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj.cryptoKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ffx-Fpe
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext;

  /**
   * Required. The key used by the encryption algorithm.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey;

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj.cryptoKey),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Date Shift
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext;

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey;

  /**
   * Required. For example, -5 means shift date to at most 5 days back in the past.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays: number;

  /**
   * Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj.cryptoKey),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fixed size bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize: number;

  /**
   * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound;

  /**
   * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj.lowerBound),
    'upperBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj.upperBound),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replace with a specified value.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Value to replace it with.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj.newValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Time extraction
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values: TIME_PART_UNSPECIFIED, YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An expression.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions {
  /**
   * Conditions to apply to the expression.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#conditions
   */
  readonly conditions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions;

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(obj.conditions),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations {
  /**
   * InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#infoTypes
   */
  readonly infoTypes?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes[];

  /**
   * Required. Primitive transformation to apply to the infoType.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations#primitiveTransformation
   */
  readonly primitiveTransformation: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(y)),
    'primitiveTransformation': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(obj.primitiveTransformation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mask
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deterministic Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext;

  /**
   * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey;

  /**
   * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj.cryptoKey),
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the hash function.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj.cryptoKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ffx-Fpe
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext;

  /**
   * Required. The key used by the encryption algorithm.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey;

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj.cryptoKey),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Date Shift
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext;

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey;

  /**
   * Required. For example, -5 means shift date to at most 5 days back in the past.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays: number;

  /**
   * Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj.cryptoKey),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fixed size bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize: number;

  /**
   * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound;

  /**
   * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj.lowerBound),
    'upperBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj.upperBound),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replace with a specified value.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Value to replace it with.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(obj.newValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Time extraction
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values: TIME_PART_UNSPECIFIED, YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An expression.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions {
  /**
   * Conditions to apply to the expression.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#conditions
   */
  readonly conditions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions;

  /**
   * The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions#logicalOperator
   */
  readonly logicalOperator?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(obj.conditions),
    'logicalOperator': obj.logicalOperator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax;

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin;

  /**
   * Required. Replacement value for this bucket.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj.max),
    'min': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj.min),
    'replacementValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj.replacementValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values: COMMON_CHARS_TO_IGNORE_UNSPECIFIED, NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the hash function.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The key used by the encryption algorithm.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value to replace it with.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Conditions to apply to the expression.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions {
  /**
   * A collection of conditions.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Primitive transformation to apply to the infoType.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation {
  /**
   * Bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#bucketingConfig
   */
  readonly bucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig;

  /**
   * Mask
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#characterMaskConfig
   */
  readonly characterMaskConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig;

  /**
   * Deterministic Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoDeterministicConfig
   */
  readonly cryptoDeterministicConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig;

  /**
   * Crypto
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoHashConfig
   */
  readonly cryptoHashConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig;

  /**
   * Ffx-Fpe
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#cryptoReplaceFfxFpeConfig
   */
  readonly cryptoReplaceFfxFpeConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig;

  /**
   * Date Shift
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#dateShiftConfig
   */
  readonly dateShiftConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig;

  /**
   * Fixed size bucketing
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#fixedSizeBucketingConfig
   */
  readonly fixedSizeBucketingConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig;

  /**
   * Redact
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#redactConfig
   */
  readonly redactConfig?: any;

  /**
   * Replace with a specified value.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceConfig
   */
  readonly replaceConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig;

  /**
   * Replace with infotype
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#replaceWithInfoTypeConfig
   */
  readonly replaceWithInfoTypeConfig?: any;

  /**
   * Time extraction
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation#timePartConfig
   */
  readonly timePartConfig?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj.bucketingConfig),
    'characterMaskConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj.characterMaskConfig),
    'cryptoDeterministicConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj.cryptoDeterministicConfig),
    'cryptoHashConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj.cryptoHashConfig),
    'cryptoReplaceFfxFpeConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj.cryptoReplaceFfxFpeConfig),
    'dateShiftConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj.dateShiftConfig),
    'fixedSizeBucketingConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj.fixedSizeBucketingConfig),
    'redactConfig': obj.redactConfig,
    'replaceConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj.replaceConfig),
    'replaceWithInfoTypeConfig': obj.replaceWithInfoTypeConfig,
    'timePartConfig': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj.timePartConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax;

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin;

  /**
   * Required. Replacement value for this bucket.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj.max),
    'min': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj.min),
    'replacementValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj.replacementValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values: COMMON_CHARS_TO_IGNORE_UNSPECIFIED, NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the hash function.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The key used by the encryption algorithm.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value to replace it with.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Conditions to apply to the expression.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions {
  /**
   * A collection of conditions.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions#conditions
   */
  readonly conditions?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Upper bound of the range, exclusive; type must match min.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lower bound of the range, inclusive. Type should be the same as max if used.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Replacement value for this bucket.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions {
  /**
   * Required. Field within the record this condition is evaluated against.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#field
   */
  readonly field: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField;

  /**
   * Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#operator
   */
  readonly operator: string;

  /**
   * Value to compare against. [Mandatory, except for `EXISTS` tests.]
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(obj.field),
    'operator': obj.operator,
    'value': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(obj.value),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig {
  /**
   * Set of buckets. Ranges must be non-overlapping.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig#buckets
   */
  readonly buckets?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets[];

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mask
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig {
  /**
   * When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#charactersToIgnore
   */
  readonly charactersToIgnore?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore[];

  /**
   * Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#maskingCharacter
   */
  readonly maskingCharacter?: string;

  /**
   * Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#numberToMask
   */
  readonly numberToMask?: number;

  /**
   * Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig#reverseOrder
   */
  readonly reverseOrder?: boolean;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToIgnore': obj.charactersToIgnore?.map(y => toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(y)),
    'maskingCharacter': obj.maskingCharacter,
    'numberToMask': obj.numberToMask,
    'reverseOrder': obj.reverseOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deterministic Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig {
  /**
   * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext;

  /**
   * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey;

  /**
   * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj.cryptoKey),
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Crypto
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig {
  /**
   * The key used by the hash function.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj.cryptoKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ffx-Fpe
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig {
  /**
   * Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#commonAlphabet
   */
  readonly commonAlphabet?: string;

  /**
   * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext;

  /**
   * Required. The key used by the encryption algorithm.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#cryptoKey
   */
  readonly cryptoKey: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey;

  /**
   * This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#customAlphabet
   */
  readonly customAlphabet?: string;

  /**
   * The native way to select the alphabet. Must be in the range [2, 95].
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#radix
   */
  readonly radix?: number;

  /**
   * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig#surrogateInfoType
   */
  readonly surrogateInfoType?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonAlphabet': obj.commonAlphabet,
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj.cryptoKey),
    'customAlphabet': obj.customAlphabet,
    'radix': obj.radix,
    'surrogateInfoType': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj.surrogateInfoType),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Date Shift
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig {
  /**
   * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#context
   */
  readonly context?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext;

  /**
   * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#cryptoKey
   */
  readonly cryptoKey?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey;

  /**
   * Required. For example, -5 means shift date to at most 5 days back in the past.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#lowerBoundDays
   */
  readonly lowerBoundDays: number;

  /**
   * Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig#upperBoundDays
   */
  readonly upperBoundDays: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj.context),
    'cryptoKey': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj.cryptoKey),
    'lowerBoundDays': obj.lowerBoundDays,
    'upperBoundDays': obj.upperBoundDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fixed size bucketing
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig {
  /**
   * Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#bucketSize
   */
  readonly bucketSize: number;

  /**
   * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#lowerBound
   */
  readonly lowerBound: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound;

  /**
   * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig#upperBound
   */
  readonly upperBound: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketSize': obj.bucketSize,
    'lowerBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj.lowerBound),
    'upperBound': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj.upperBound),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Replace with a specified value.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig {
  /**
   * Value to replace it with.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig#newValue
   */
  readonly newValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj.newValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Time extraction
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig {
  /**
   * The part of the time to keep. Possible values: TIME_PART_UNSPECIFIED, YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig#partToExtract
   */
  readonly partToExtract?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationTimePartConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partToExtract': obj.partToExtract,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Upper bound of the range, exclusive; type must match min.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lower bound of the range, inclusive. Type should be the same as max if used.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Replacement value for this bucket.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions {
  /**
   * Required. Field within the record this condition is evaluated against.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#field
   */
  readonly field: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField;

  /**
   * Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#operator
   */
  readonly operator: string;

  /**
   * Value to compare against. [Mandatory, except for `EXISTS` tests.]
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions#value
   */
  readonly value?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(obj.field),
    'operator': obj.operator,
    'value': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(obj.value),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Field within the record this condition is evaluated against.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value to compare against. [Mandatory, except for `EXISTS` tests.]
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets {
  /**
   * Upper bound of the range, exclusive; type must match min.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#max
   */
  readonly max?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax;

  /**
   * Lower bound of the range, inclusive. Type should be the same as max if used.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#min
   */
  readonly min?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin;

  /**
   * Required. Replacement value for this bucket.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets#replacementValue
   */
  readonly replacementValue: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj.max),
    'min': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj.min),
    'replacementValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj.replacementValue),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore {
  /**
   * Characters to not transform when masking.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#charactersToSkip
   */
  readonly charactersToSkip?: string;

  /**
   * Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values: COMMON_CHARS_TO_IGNORE_UNSPECIFIED, NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore#commonCharactersToIgnore
   */
  readonly commonCharactersToIgnore?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCharactersToIgnore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'charactersToSkip': obj.charactersToSkip,
    'commonCharactersToIgnore': obj.commonCharactersToIgnore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The key used by the hash function.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The key used by the encryption algorithm.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey {
  /**
   * Key wrapped using Cloud KMS
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#kmsWrapped
   */
  readonly kmsWrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped;

  /**
   * Transient crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#transient
   */
  readonly transient?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient;

  /**
   * Unwrapped crypto key
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey#unwrapped
   */
  readonly unwrapped?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsWrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj.kmsWrapped),
    'transient': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj.transient),
    'unwrapped': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj.unwrapped),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value to replace it with.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Field within the record this condition is evaluated against.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField {
  /**
   * Name describing the field.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value to compare against. [Mandatory, except for `EXISTS` tests.]
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Upper bound of the range, exclusive; type must match min.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMax | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Lower bound of the range, inclusive. Type should be the same as max if used.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Replacement value for this bucket.
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue {
  /**
   * boolean
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * date
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dateValue
   */
  readonly dateValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue;

  /**
   * day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#dayOfWeekValue
   */
  readonly dayOfWeekValue?: string;

  /**
   * float
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#floatValue
   */
  readonly floatValue?: number;

  /**
   * integer
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#integerValue
   */
  readonly integerValue?: number;

  /**
   * string
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#stringValue
   */
  readonly stringValue?: string;

  /**
   * time of day
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timeValue
   */
  readonly timeValue?: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue;

  /**
   * timestamp
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue#timestampValue
   */
  readonly timestampValue?: Date;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'booleanValue': obj.booleanValue,
    'dateValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj.dateValue),
    'dayOfWeekValue': obj.dayOfWeekValue,
    'floatValue': obj.floatValue,
    'integerValue': obj.integerValue,
    'stringValue': obj.stringValue,
    'timeValue': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj.timeValue),
    'timestampValue': obj.timestampValue?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Key wrapped using Cloud KMS
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped {
  /**
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#cryptoKeyRef
   */
  readonly cryptoKeyRef: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef;

  /**
   * Required. The wrapped data crypto key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped#wrappedKey
   */
  readonly wrappedKey: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cryptoKeyRef': toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj.cryptoKeyRef),
    'wrappedKey': obj.wrappedKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Transient crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient {
  /**
   * Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyTransient | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unwrapped crypto key
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped {
  /**
   * Required. A 128/192/256 bit key.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyUnwrapped | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsRecordSuppressionsConditionExpressionsConditionsConditionsValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMaxTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsMinTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * date
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue {
  /**
   * Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#day
   */
  readonly day?: number;

  /**
   * Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#month
   */
  readonly month?: number;

  /**
   * Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue#year
   */
  readonly year?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueDateValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'month': obj.month,
    'year': obj.year,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * time of day
 *
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationBucketingConfigBucketsReplacementValueTimeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef
 */
export interface DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef {
  /**
   * Required. The resource name of the KMS CryptoKey to use for unwrapping.
   *
   * Allowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef(obj: DlpDeidentifyTemplateSpecDeidentifyConfigRecordTransformationsFieldTransformationsInfoTypeTransformationsTransformationsPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedCryptoKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DLPInspectTemplate
 */
export class DlpInspectTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DLPInspectTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dlp.cnrm.cloud.google.com/v1beta1',
    kind: 'DLPInspectTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "DLPInspectTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlpInspectTemplateProps = {}): any {
    return {
      ...DlpInspectTemplate.GVK,
      ...toJson_DlpInspectTemplateProps(props),
    };
  }

  /**
   * Defines a "DLPInspectTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DlpInspectTemplateProps = {}) {
    super(scope, id, {
      ...DlpInspectTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlpInspectTemplate.GVK,
      ...toJson_DlpInspectTemplateProps(resolved),
    };
  }
}

/**
 * @schema DLPInspectTemplate
 */
export interface DlpInspectTemplateProps {
  /**
   * @schema DLPInspectTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DLPInspectTemplate#spec
   */
  readonly spec?: DlpInspectTemplateSpec;

}

/**
 * Converts an object of type 'DlpInspectTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateProps(obj: DlpInspectTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DlpInspectTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpec
 */
export interface DlpInspectTemplateSpec {
  /**
   * Short description (max 256 chars).
   *
   * @schema DlpInspectTemplateSpec#description
   */
  readonly description?: string;

  /**
   * Display name (max 256 chars).
   *
   * @schema DlpInspectTemplateSpec#displayName
   */
  readonly displayName?: string;

  /**
   * The core content of the template. Configuration of the scanning process.
   *
   * @schema DlpInspectTemplateSpec#inspectConfig
   */
  readonly inspectConfig?: DlpInspectTemplateSpecInspectConfig;

  /**
   * Immutable. The location of the resource
   *
   * @schema DlpInspectTemplateSpec#location
   */
  readonly location?: string;

  /**
   * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpInspectTemplateSpec#organizationRef
   */
  readonly organizationRef?: DlpInspectTemplateSpecOrganizationRef;

  /**
   * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpInspectTemplateSpec#projectRef
   */
  readonly projectRef?: DlpInspectTemplateSpecProjectRef;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema DlpInspectTemplateSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpec(obj: DlpInspectTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectConfig': toJson_DlpInspectTemplateSpecInspectConfig(obj.inspectConfig),
    'location': obj.location,
    'organizationRef': toJson_DlpInspectTemplateSpecOrganizationRef(obj.organizationRef),
    'projectRef': toJson_DlpInspectTemplateSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The core content of the template. Configuration of the scanning process.
 *
 * @schema DlpInspectTemplateSpecInspectConfig
 */
export interface DlpInspectTemplateSpecInspectConfig {
  /**
   * List of options defining data content to scan. If empty, text, images, and other content will be included.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#contentOptions
   */
  readonly contentOptions?: string[];

  /**
   * CustomInfoTypes provided by the user. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: DlpInspectTemplateSpecInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#infoTypes
   */
  readonly infoTypes?: DlpInspectTemplateSpecInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#limits
   */
  readonly limits?: DlpInspectTemplateSpecInspectConfigLimits;

  /**
   * Only returns findings equal or above this threshold. The default is POSSIBLE. See https://cloud.google.com/dlp/docs/likelihood to learn more. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @schema DlpInspectTemplateSpecInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type.
   *
   * @schema DlpInspectTemplateSpecInspectConfig#ruleSet
   */
  readonly ruleSet?: DlpInspectTemplateSpecInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfig(obj: DlpInspectTemplateSpecInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentOptions': obj.contentOptions?.map(y => y),
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpInspectTemplateSpecInspectConfigInfoTypes(y)),
    'limits': toJson_DlpInspectTemplateSpecInspectConfigLimits(obj.limits),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_DlpInspectTemplateSpecInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpInspectTemplateSpecOrganizationRef
 */
export interface DlpInspectTemplateSpecOrganizationRef {
  /**
   * Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).
   *
   * @schema DlpInspectTemplateSpecOrganizationRef#external
   */
  readonly external?: string;

  /**
   * [WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpInspectTemplateSpecOrganizationRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpInspectTemplateSpecOrganizationRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecOrganizationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecOrganizationRef(obj: DlpInspectTemplateSpecOrganizationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpInspectTemplateSpecProjectRef
 */
export interface DlpInspectTemplateSpecProjectRef {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpInspectTemplateSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpInspectTemplateSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpInspectTemplateSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecProjectRef(obj: DlpInspectTemplateSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypes {
  /**
   * A list of phrases to detect as a CustomInfoType.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary;

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values: EXCLUSION_TYPE_UNSPECIFIED, EXCLUSION_TYPE_EXCLUDE
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing infoTypes and that infoType is specified in `InspectContent.info_types` field. Specifying the latter adds findings to the one detected by the system. If built-in info type is not specified in `InspectContent.info_types` list then the name is treated as a custom info type.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType;

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Defaults to `VERY_LIKELY` if not specified. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @default VERY_LIKELY` if not specified. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression based CustomInfoType.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex;

  /**
   * Load an existing `StoredInfoType` resource for use in `InspectDataSource`. Not currently supported in `InspectContent`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType;

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypes(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary(obj.dictionary),
    'exclusionType': obj.exclusionType,
    'infoType': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType(obj.infoType),
    'likelihood': obj.likelihood,
    'regex': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex(obj.regex),
    'storedType': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType(obj.storedType),
    'surrogateType': obj.surrogateType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigInfoTypes
 */
export interface DlpInspectTemplateSpecInspectConfigInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigInfoTypes(obj: DlpInspectTemplateSpecInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration to control the number of findings returned.
 *
 * @schema DlpInspectTemplateSpecInspectConfigLimits
 */
export interface DlpInspectTemplateSpecInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. When set within `InspectJobConfig`, the maximum returned is 2000 regardless if this is set higher. When set within `InspectContentRequest`, this field is ignored.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. When set within `InspectContentRequest`, the maximum returned is 2000 regardless if this is set higher.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigLimits(obj: DlpInspectTemplateSpecInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigRuleSet
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSet#rules
   */
  readonly rules?: DlpInspectTemplateSpecInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSet(obj: DlpInspectTemplateSpecInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_DlpInspectTemplateSpecInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of phrases to detect as a CustomInfoType.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath;

  /**
   * List of words or phrases to search for.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj.cloudStoragePath),
    'wordList': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList(obj.wordList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing infoTypes and that infoType is specified in `InspectContent.info_types` field. Specifying the latter adds findings to the one detected by the system. If built-in info type is not specified in `InspectContent.info_types` list then the name is treated as a custom info type.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression based CustomInfoType.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Load an existing `StoredInfoType` resource for use in `InspectDataSource`. Not currently supported in `InspectContent`.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType {
  /**
   * Timestamp indicating when the version of the `StoredInfoType` used for inspection was created. Output-only field, populated by the system.
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType#createTime
   */
  readonly createTime?: Date;

  /**
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType#nameRef
   */
  readonly nameRef?: DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createTime': obj.createTime?.toISOString(),
    'nameRef': toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef(obj.nameRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per info_type should be provided. If InfoTypeLimit does not have an info_type, the DLP API applies the limit against all info_types that are found but not specified in another InfoTypeLimit.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType;

  /**
   * Max findings limit for the given infoType.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType(obj: DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': toJson_DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj.infoType),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes(obj: DlpInspectTemplateSpecInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRules
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRules {
  /**
   * Exclusion rule.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule;

  /**
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRules(obj: DlpInspectTemplateSpecInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule(obj.exclusionRule),
    'hotwordRule': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule(obj.hotwordRule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of words or phrases to search for.
 *
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef
 */
export interface DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef {
  /**
   * Resource name of the requested `StoredInfoType`, for example `organizations/433245324/storedInfoTypes/432452342` or `projects/project-id/storedInfoTypes/432452342`.
   *
   * Allowed value: The Google Cloud resource name of a `DLPStoredInfoType` resource (format: `{{parent}}/storedInfoTypes/{{name}}`).
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef(obj: DlpInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of information the findings limit applies to. Only one limit per info_type should be provided. If InfoTypeLimit does not have an info_type, the DLP API applies the limit against all info_types that are found but not specified in another InfoTypeLimit.
 *
 * @schema DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: DlpInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exclusion rule.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary;

  /**
   * Set of infoTypes for which findings would affect this rule.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes;

  /**
   * How the rule is applied, see MatchingType documentation for details. Possible values: MATCHING_TYPE_UNSPECIFIED, MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary(obj.dictionary),
    'excludeInfoTypes': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj.excludeInfoTypes),
    'matchingType': obj.matchingType,
    'regex': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex(obj.regex),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex;

  /**
   * Likelihood adjustment to apply to all matching findings.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment;

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj.hotwordRegex),
    'likelihoodAdjustment': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj.likelihoodAdjustment),
    'proximity': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity(obj.proximity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dictionary which defines the rule.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath;

  /**
   * List of words or phrases to search for.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj.cloudStoragePath),
    'wordList': toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj.wordList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of infoTypes for which findings would affect this rule.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * InfoType list in ExclusionRule rule drops a finding when it overlaps or contained within with a finding of an infoType from this list. For example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and `exclusion_rule` containing `exclude_info_types.info_types` with "EMAIL_ADDRESS" the phone number findings are dropped if they overlap with EMAIL_ADDRESS finding. That leads to "555-222-2222@example.org" to generate only a single finding, namely email address.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression which defines the rule.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression pattern defining what qualifies as a hotword.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Likelihood adjustment to apply to all matching findings.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be `POSSIBLE` without the detection rule and `relative_likelihood` is 1, then it is upgraded to `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`. Likelihood may never drop below `VERY_UNLIKELY` or exceed `VERY_LIKELY`, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is `VERY_LIKELY` will result in a final likelihood of `LIKELY`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of words or phrases to search for.
 *
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: DlpInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DLPJobTrigger
 */
export class DlpJobTrigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DLPJobTrigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dlp.cnrm.cloud.google.com/v1beta1',
    kind: 'DLPJobTrigger',
  }

  /**
   * Renders a Kubernetes manifest for "DLPJobTrigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlpJobTriggerProps): any {
    return {
      ...DlpJobTrigger.GVK,
      ...toJson_DlpJobTriggerProps(props),
    };
  }

  /**
   * Defines a "DLPJobTrigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DlpJobTriggerProps) {
    super(scope, id, {
      ...DlpJobTrigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlpJobTrigger.GVK,
      ...toJson_DlpJobTriggerProps(resolved),
    };
  }
}

/**
 * @schema DLPJobTrigger
 */
export interface DlpJobTriggerProps {
  /**
   * @schema DLPJobTrigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DLPJobTrigger#spec
   */
  readonly spec: DlpJobTriggerSpec;

}

/**
 * Converts an object of type 'DlpJobTriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerProps(obj: DlpJobTriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DlpJobTriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpec
 */
export interface DlpJobTriggerSpec {
  /**
   * User provided description (max 256 chars)
   *
   * @schema DlpJobTriggerSpec#description
   */
  readonly description?: string;

  /**
   * Display name (max 100 chars)
   *
   * @schema DlpJobTriggerSpec#displayName
   */
  readonly displayName?: string;

  /**
   * For inspect jobs, a snapshot of the configuration.
   *
   * @schema DlpJobTriggerSpec#inspectJob
   */
  readonly inspectJob: DlpJobTriggerSpecInspectJob;

  /**
   * Immutable. The location of the resource
   *
   * @schema DlpJobTriggerSpec#location
   */
  readonly location?: string;

  /**
   * Immutable. The Project that this resource belongs to. Only one of [projectRef] may be specified.
   *
   * @schema DlpJobTriggerSpec#projectRef
   */
  readonly projectRef: DlpJobTriggerSpecProjectRef;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema DlpJobTriggerSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Required. A status for this trigger. Possible values: STATUS_UNSPECIFIED, HEALTHY, PAUSED, CANCELLED
   *
   * @schema DlpJobTriggerSpec#status
   */
  readonly status: string;

  /**
   * A list of triggers which will be OR'ed together. Only one in the list needs to trigger for a job to be started. The list may contain only a single Schedule trigger and must have at least one object.
   *
   * @schema DlpJobTriggerSpec#triggers
   */
  readonly triggers: DlpJobTriggerSpecTriggers[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpec(obj: DlpJobTriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'inspectJob': toJson_DlpJobTriggerSpecInspectJob(obj.inspectJob),
    'location': obj.location,
    'projectRef': toJson_DlpJobTriggerSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'status': obj.status,
    'triggers': obj.triggers?.map(y => toJson_DlpJobTriggerSpecTriggers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For inspect jobs, a snapshot of the configuration.
 *
 * @schema DlpJobTriggerSpecInspectJob
 */
export interface DlpJobTriggerSpecInspectJob {
  /**
   * Actions to execute at the completion of the job.
   *
   * @schema DlpJobTriggerSpecInspectJob#actions
   */
  readonly actions?: DlpJobTriggerSpecInspectJobActions[];

  /**
   * How and what to scan for.
   *
   * @schema DlpJobTriggerSpecInspectJob#inspectConfig
   */
  readonly inspectConfig?: DlpJobTriggerSpecInspectJobInspectConfig;

  /**
   * @schema DlpJobTriggerSpecInspectJob#inspectTemplateRef
   */
  readonly inspectTemplateRef?: DlpJobTriggerSpecInspectJobInspectTemplateRef;

  /**
   * The data to scan.
   *
   * @schema DlpJobTriggerSpecInspectJob#storageConfig
   */
  readonly storageConfig: DlpJobTriggerSpecInspectJobStorageConfig;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJob' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJob(obj: DlpJobTriggerSpecInspectJob | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_DlpJobTriggerSpecInspectJobActions(y)),
    'inspectConfig': toJson_DlpJobTriggerSpecInspectJobInspectConfig(obj.inspectConfig),
    'inspectTemplateRef': toJson_DlpJobTriggerSpecInspectJobInspectTemplateRef(obj.inspectTemplateRef),
    'storageConfig': toJson_DlpJobTriggerSpecInspectJobStorageConfig(obj.storageConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to. Only one of [projectRef] may be specified.
 *
 * @schema DlpJobTriggerSpecProjectRef
 */
export interface DlpJobTriggerSpecProjectRef {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpJobTriggerSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecProjectRef(obj: DlpJobTriggerSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecTriggers
 */
export interface DlpJobTriggerSpecTriggers {
  /**
   * For use with hybrid jobs. Jobs must be manually created and finished.
   *
   * @schema DlpJobTriggerSpecTriggers#manual
   */
  readonly manual?: any;

  /**
   * Create a job on a repeating basis based on the elapse of time.
   *
   * @schema DlpJobTriggerSpecTriggers#schedule
   */
  readonly schedule?: DlpJobTriggerSpecTriggersSchedule;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecTriggers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecTriggers(obj: DlpJobTriggerSpecTriggers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'manual': obj.manual,
    'schedule': toJson_DlpJobTriggerSpecTriggersSchedule(obj.schedule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobActions
 */
export interface DlpJobTriggerSpecInspectJobActions {
  /**
   * Enable email notification for project owners and editors on job's completion/failure.
   *
   * @schema DlpJobTriggerSpecInspectJobActions#jobNotificationEmails
   */
  readonly jobNotificationEmails?: any;

  /**
   * Publish a notification to a pubsub topic.
   *
   * @schema DlpJobTriggerSpecInspectJobActions#pubSub
   */
  readonly pubSub?: DlpJobTriggerSpecInspectJobActionsPubSub;

  /**
   * Publish findings to Cloud Datahub.
   *
   * @schema DlpJobTriggerSpecInspectJobActions#publishFindingsToCloudDataCatalog
   */
  readonly publishFindingsToCloudDataCatalog?: any;

  /**
   * Publish summary to Cloud Security Command Center (Alpha).
   *
   * @schema DlpJobTriggerSpecInspectJobActions#publishSummaryToCscc
   */
  readonly publishSummaryToCscc?: any;

  /**
   * Enable Stackdriver metric dlp.googleapis.com/finding_count.
   *
   * @schema DlpJobTriggerSpecInspectJobActions#publishToStackdriver
   */
  readonly publishToStackdriver?: any;

  /**
   * Save resulting findings in a provided location.
   *
   * @schema DlpJobTriggerSpecInspectJobActions#saveFindings
   */
  readonly saveFindings?: DlpJobTriggerSpecInspectJobActionsSaveFindings;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActions(obj: DlpJobTriggerSpecInspectJobActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobNotificationEmails': obj.jobNotificationEmails,
    'pubSub': toJson_DlpJobTriggerSpecInspectJobActionsPubSub(obj.pubSub),
    'publishFindingsToCloudDataCatalog': obj.publishFindingsToCloudDataCatalog,
    'publishSummaryToCscc': obj.publishSummaryToCscc,
    'publishToStackdriver': obj.publishToStackdriver,
    'saveFindings': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindings(obj.saveFindings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * How and what to scan for.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfig
 */
export interface DlpJobTriggerSpecInspectJobInspectConfig {
  /**
   * CustomInfoTypes provided by the user. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#customInfoTypes
   */
  readonly customInfoTypes?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes[];

  /**
   * When true, excludes type information of the findings. This is not used for data profiling.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#excludeInfoTypes
   */
  readonly excludeInfoTypes?: boolean;

  /**
   * When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote. This is not used for data profiling.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#includeQuote
   */
  readonly includeQuote?: boolean;

  /**
   * Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#infoTypes
   */
  readonly infoTypes?: DlpJobTriggerSpecInspectJobInspectConfigInfoTypes[];

  /**
   * Configuration to control the number of findings returned. This is not used for data profiling.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#limits
   */
  readonly limits?: DlpJobTriggerSpecInspectJobInspectConfigLimits;

  /**
   * Only returns findings equal or above this threshold. The default is POSSIBLE. See https://cloud.google.com/dlp/docs/likelihood to learn more. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#minLikelihood
   */
  readonly minLikelihood?: string;

  /**
   * Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfig#ruleSet
   */
  readonly ruleSet?: DlpJobTriggerSpecInspectJobInspectConfigRuleSet[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfig(obj: DlpJobTriggerSpecInspectJobInspectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customInfoTypes': obj.customInfoTypes?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes(y)),
    'excludeInfoTypes': obj.excludeInfoTypes,
    'includeQuote': obj.includeQuote,
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigInfoTypes(y)),
    'limits': toJson_DlpJobTriggerSpecInspectJobInspectConfigLimits(obj.limits),
    'minLikelihood': obj.minLikelihood,
    'ruleSet': obj.ruleSet?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectTemplateRef
 */
export interface DlpJobTriggerSpecInspectJobInspectTemplateRef {
  /**
   * If provided, will be used as the default for all values in InspectConfig. `inspect_config` will be merged into the values persisted as part of the template.
   *
   * Allowed value: The Google Cloud resource name of a `DLPInspectTemplate` resource (format: `{{parent}}/inspectTemplates/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobInspectTemplateRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobInspectTemplateRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobInspectTemplateRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectTemplateRef(obj: DlpJobTriggerSpecInspectJobInspectTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The data to scan.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfig
 */
export interface DlpJobTriggerSpecInspectJobStorageConfig {
  /**
   * BigQuery options.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfig#bigQueryOptions
   */
  readonly bigQueryOptions?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions;

  /**
   * Google Cloud Storage options.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfig#cloudStorageOptions
   */
  readonly cloudStorageOptions?: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions;

  /**
   * Google Cloud Datastore options.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfig#datastoreOptions
   */
  readonly datastoreOptions?: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions;

  /**
   * Hybrid inspection options.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfig#hybridOptions
   */
  readonly hybridOptions?: DlpJobTriggerSpecInspectJobStorageConfigHybridOptions;

  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfig#timespanConfig
   */
  readonly timespanConfig?: DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfig(obj: DlpJobTriggerSpecInspectJobStorageConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryOptions': toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions(obj.bigQueryOptions),
    'cloudStorageOptions': toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions(obj.cloudStorageOptions),
    'datastoreOptions': toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions(obj.datastoreOptions),
    'hybridOptions': toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptions(obj.hybridOptions),
    'timespanConfig': toJson_DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig(obj.timespanConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Create a job on a repeating basis based on the elapse of time.
 *
 * @schema DlpJobTriggerSpecTriggersSchedule
 */
export interface DlpJobTriggerSpecTriggersSchedule {
  /**
   * With this option a job is started a regular periodic basis. For example: every day (86400 seconds). A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs. This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
   *
   * @schema DlpJobTriggerSpecTriggersSchedule#recurrencePeriodDuration
   */
  readonly recurrencePeriodDuration?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecTriggersSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecTriggersSchedule(obj: DlpJobTriggerSpecTriggersSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recurrencePeriodDuration': obj.recurrencePeriodDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Publish a notification to a pubsub topic.
 *
 * @schema DlpJobTriggerSpecInspectJobActionsPubSub
 */
export interface DlpJobTriggerSpecInspectJobActionsPubSub {
  /**
   * @schema DlpJobTriggerSpecInspectJobActionsPubSub#topicRef
   */
  readonly topicRef?: DlpJobTriggerSpecInspectJobActionsPubSubTopicRef;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsPubSub' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsPubSub(obj: DlpJobTriggerSpecInspectJobActionsPubSub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topicRef': toJson_DlpJobTriggerSpecInspectJobActionsPubSubTopicRef(obj.topicRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Save resulting findings in a provided location.
 *
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindings
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindings {
  /**
   * Location to store findings outside of DLP.
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindings#outputConfig
   */
  readonly outputConfig?: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindings(obj: DlpJobTriggerSpecInspectJobActionsSaveFindings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'outputConfig': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig(obj.outputConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes {
  /**
   * Set of detection rules to apply to all findings of this CustomInfoType. Rules are applied in order that they are specified. Not supported for the `surrogate_type` CustomInfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#detectionRules
   */
  readonly detectionRules?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules[];

  /**
   * A list of phrases to detect as a CustomInfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#dictionary
   */
  readonly dictionary?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary;

  /**
   * If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching. Possible values: EXCLUSION_TYPE_UNSPECIFIED, EXCLUSION_TYPE_EXCLUDE
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#exclusionType
   */
  readonly exclusionType?: string;

  /**
   * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing infoTypes and that infoType is specified in `InspectContent.info_types` field. Specifying the latter adds findings to the one detected by the system. If built-in info type is not specified in `InspectContent.info_types` list then the name is treated as a custom info type.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#infoType
   */
  readonly infoType?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType;

  /**
   * Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Defaults to `VERY_LIKELY` if not specified. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @default VERY_LIKELY` if not specified. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#likelihood
   */
  readonly likelihood?: string;

  /**
   * Regular expression based CustomInfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#regex
   */
  readonly regex?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex;

  /**
   * Load an existing `StoredInfoType` resource for use in `InspectDataSource`. Not currently supported in `InspectContent`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#storedType
   */
  readonly storedType?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType;

  /**
   * Message for detecting output from deidentification transformations that support reversing.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes#surrogateType
   */
  readonly surrogateType?: any;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'detectionRules': obj.detectionRules?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules(y)),
    'dictionary': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary(obj.dictionary),
    'exclusionType': obj.exclusionType,
    'infoType': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType(obj.infoType),
    'likelihood': obj.likelihood,
    'regex': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex(obj.regex),
    'storedType': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType(obj.storedType),
    'surrogateType': obj.surrogateType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigInfoTypes
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigInfoTypes#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigInfoTypes(obj: DlpJobTriggerSpecInspectJobInspectConfigInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration to control the number of findings returned. This is not used for data profiling.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigLimits
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigLimits {
  /**
   * Configuration of findings limit given for specified infoTypes.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimits#maxFindingsPerInfoType
   */
  readonly maxFindingsPerInfoType?: DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType[];

  /**
   * Max number of findings that will be returned for each item scanned. When set within `InspectJobConfig`, the maximum returned is 2000 regardless if this is set higher. When set within `InspectContentRequest`, this field is ignored.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimits#maxFindingsPerItem
   */
  readonly maxFindingsPerItem?: number;

  /**
   * Max number of findings that will be returned per request/job. When set within `InspectContentRequest`, the maximum returned is 2000 regardless if this is set higher.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimits#maxFindingsPerRequest
   */
  readonly maxFindingsPerRequest?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigLimits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigLimits(obj: DlpJobTriggerSpecInspectJobInspectConfigLimits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxFindingsPerInfoType': obj.maxFindingsPerInfoType?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType(y)),
    'maxFindingsPerItem': obj.maxFindingsPerItem,
    'maxFindingsPerRequest': obj.maxFindingsPerRequest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSet
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSet {
  /**
   * List of infoTypes this rule set is applied to.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSet#infoTypes
   */
  readonly infoTypes?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes[];

  /**
   * Set of rules to be applied to infoTypes. The rules are applied in order.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSet#rules
   */
  readonly rules?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSet(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes(y)),
    'rules': obj.rules?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BigQuery options.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions {
  /**
   * References to fields excluded from scanning. This allows you to skip inspection of entire columns which you know have no findings.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#excludedFields
   */
  readonly excludedFields?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields[];

  /**
   * Table fields that may uniquely identify a row within the table. When `actions.saveFindings.outputConfig.table` is specified, the values of columns specified here are available in the output table under `location.content_locations.record_location.record_key.id_values`. Nested fields such as `person.birthdate.year` are allowed.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#identifyingFields
   */
  readonly identifyingFields?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields[];

  /**
   * Limit scanning only to these fields.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#includedFields
   */
  readonly includedFields?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields[];

  /**
   * Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted. If not set, or if set to 0, all rows will be scanned. Only one of rows_limit and rows_limit_percent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#rowsLimit
   */
  readonly rowsLimit?: number;

  /**
   * Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of rows_limit and rows_limit_percent can be specified. Cannot be used in conjunction with TimespanConfig.
   *
   * @default 0. Only one of rows_limit and rows_limit_percent can be specified. Cannot be used in conjunction with TimespanConfig.
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#rowsLimitPercent
   */
  readonly rowsLimitPercent?: number;

  /**
   * Possible values: SAMPLE_METHOD_UNSPECIFIED, TOP, RANDOM_START
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#sampleMethod
   */
  readonly sampleMethod?: string;

  /**
   * Complete BigQuery table reference.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions#tableReference
   */
  readonly tableReference: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludedFields': obj.excludedFields?.map(y => toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields(y)),
    'identifyingFields': obj.identifyingFields?.map(y => toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields(y)),
    'includedFields': obj.includedFields?.map(y => toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields(y)),
    'rowsLimit': obj.rowsLimit,
    'rowsLimitPercent': obj.rowsLimitPercent,
    'sampleMethod': obj.sampleMethod,
    'tableReference': toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference(obj.tableReference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Google Cloud Storage options.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions {
  /**
   * Max number of bytes to scan from a file. If a scanned file's size is bigger than this value then the rest of the bytes are omitted. Only one of bytes_limit_per_file and bytes_limit_per_file_percent can be specified. Cannot be set if de-identification is requested.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFile
   */
  readonly bytesLimitPerFile?: number;

  /**
   * Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of bytes_limit_per_file and bytes_limit_per_file_percent can be specified. Cannot be set if de-identification is requested.
   *
   * @default 0. Only one of bytes_limit_per_file and bytes_limit_per_file_percent can be specified. Cannot be set if de-identification is requested.
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#bytesLimitPerFilePercent
   */
  readonly bytesLimitPerFilePercent?: number;

  /**
   * The set of one or more files to scan.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#fileSet
   */
  readonly fileSet?: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet;

  /**
   * List of file type groups to include in the scan. If empty, all files are scanned and available data format processors are applied. In addition, the binary content of the selected files is always scanned as well. Images are scanned only as binary if the specified region does not support image inspection and no file_types were specified. Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#fileTypes
   */
  readonly fileTypes?: string[];

  /**
   * Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0.
   *
   * @default 0.
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#filesLimitPercent
   */
  readonly filesLimitPercent?: number;

  /**
   * Possible values: SAMPLE_METHOD_UNSPECIFIED, TOP, RANDOM_START
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions#sampleMethod
   */
  readonly sampleMethod?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions(obj: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytesLimitPerFile': obj.bytesLimitPerFile,
    'bytesLimitPerFilePercent': obj.bytesLimitPerFilePercent,
    'fileSet': toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet(obj.fileSet),
    'fileTypes': obj.fileTypes?.map(y => y),
    'filesLimitPercent': obj.filesLimitPercent,
    'sampleMethod': obj.sampleMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Google Cloud Datastore options.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions {
  /**
   * The kind to process.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions#kind
   */
  readonly kind?: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind;

  /**
   * A partition ID identifies a grouping of entities. The grouping is always by project namespace ID may be empty.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions#partitionId
   */
  readonly partitionId?: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions(obj: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind(obj.kind),
    'partitionId': toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId(obj.partitionId),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hybrid inspection options.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptions
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigHybridOptions {
  /**
   * A short description of where the data is coming from. Will be stored once in the job. 256 max length.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptions#description
   */
  readonly description?: string;

  /**
   * To organize findings, these labels will be added to each finding. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. Label values must be between 0 and 63 characters long and must conform to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`. No more than 10 labels can be associated with a given finding. Examples: * `"environment" : "production"` * `"pipeline" : "etl"`
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptions#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * These are labels that each inspection request must include within their 'finding_labels' map. Request may contain others, but any missing one of these will be rejected. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. No more than 10 keys can be required.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptions#requiredFindingLabelKeys
   */
  readonly requiredFindingLabelKeys?: string[];

  /**
   * If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptions#tableOptions
   */
  readonly tableOptions?: DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigHybridOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptions(obj: DlpJobTriggerSpecInspectJobStorageConfigHybridOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requiredFindingLabelKeys': obj.requiredFindingLabelKeys?.map(y => y),
    'tableOptions': toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions(obj.tableOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig {
  /**
   * When the job is started by a JobTrigger we will automatically figure out a valid start_time to avoid scanning files that have not been modified since the last time the JobTrigger executed. This will be based on the time of the execution of the last run of the JobTrigger.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig#enableAutoPopulationOfTimespanConfig
   */
  readonly enableAutoPopulationOfTimespanConfig?: boolean;

  /**
   * Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig#endTime
   */
  readonly endTime?: Date;

  /**
   * Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig#startTime
   */
  readonly startTime?: Date;

  /**
   * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: If this value is not specified and the table was modified between the given start and end times, the entire table will be scanned. If this value is specified, then rows are filtered based on the given start and end times. Rows with a `NULL` value in the provided BigQuery column are skipped. Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`, `TIMESTAMP`, and `DATETIME`. For Datastore: If this value is specified, then entities are filtered based on the given start and end times. If an entity does not contain the provided timestamp property or contains empty or invalid values, then it is included. Valid data types of the provided timestamp property are: `TIMESTAMP`.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig#timestampField
   */
  readonly timestampField?: DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig(obj: DlpJobTriggerSpecInspectJobStorageConfigTimespanConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAutoPopulationOfTimespanConfig': obj.enableAutoPopulationOfTimespanConfig,
    'endTime': obj.endTime?.toISOString(),
    'startTime': obj.startTime?.toISOString(),
    'timestampField': toJson_DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField(obj.timestampField),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobActionsPubSubTopicRef
 */
export interface DlpJobTriggerSpecInspectJobActionsPubSubTopicRef {
  /**
   * Cloud Pub/Sub topic to send notifications to. The topic must have given publishing access rights to the DLP API service account executing the long running DlpJob sending the notifications. Format is projects/{project}/topics/{topic}.
   *
   * Allowed value: The Google Cloud resource name of a `PubSubTopic` resource (format: `projects/{{project}}/topics/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobActionsPubSubTopicRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobActionsPubSubTopicRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobActionsPubSubTopicRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsPubSubTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsPubSubTopicRef(obj: DlpJobTriggerSpecInspectJobActionsPubSubTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Location to store findings outside of DLP.
 *
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig {
  /**
   * Store findings directly to DLP. If neither this or bigquery is chosen only summary stats of total infotype count will be stored. Quotes will not be stored to dlp findings. If quotes are needed, store to BigQuery. Currently only for inspect jobs.
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig#dlpStorage
   */
  readonly dlpStorage?: any;

  /**
   * Schema used for writing the findings for Inspect jobs. This field is only used for Inspect and must be unspecified for Risk jobs. Columns are derived from the `Finding` object. If appending to an existing table, any columns from the predefined schema that are missing will be added. No columns in the existing table will be deleted. If unspecified, then all available columns will be used for a new table or an (existing) table with no schema, and no changes will be made to an existing table that has a schema. Only for use with external storage. Possible values: OUTPUT_SCHEMA_UNSPECIFIED, BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig#outputSchema
   */
  readonly outputSchema?: string;

  /**
   * Store findings in an existing table or a new table in an existing dataset. If table_id is not set a new one will be generated for you with the following format: dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific timezone will be used for generating the date details. For Inspect, each column in an existing output table must have the same name, type, and mode of a field in the `Finding` object. For Risk, an existing output table should be the output of a previous Risk analysis job run on the same source table, with the same privacy metric and quasi-identifiers. Risk jobs that analyze the same table but compute a different privacy metric, or use different sets of quasi-identifiers, cannot store their results in the same table.
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig#table
   */
  readonly table?: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig(obj: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dlpStorage': obj.dlpStorage,
    'outputSchema': obj.outputSchema,
    'table': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable(obj.table),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules {
  /**
   * Hotword-based detection rule.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules#hotwordRule
   */
  readonly hotwordRule?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRule': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule(obj.hotwordRule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A list of phrases to detect as a CustomInfoType.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath;

  /**
   * List of words or phrases to search for.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary#wordList
   */
  readonly wordList?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj.cloudStoragePath),
    'wordList': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList(obj.wordList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing infoTypes and that infoType is specified in `InspectContent.info_types` field. Specifying the latter adds findings to the one detected by the system. If built-in info type is not specified in `InspectContent.info_types` list then the name is treated as a custom info type.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression based CustomInfoType.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Load an existing `StoredInfoType` resource for use in `InspectDataSource`. Not currently supported in `InspectContent`.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType {
  /**
   * Timestamp indicating when the version of the `StoredInfoType` used for inspection was created. Output-only field, populated by the system.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType#createTime
   */
  readonly createTime?: Date;

  /**
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType#nameRef
   */
  readonly nameRef?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createTime': obj.createTime?.toISOString(),
    'nameRef': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef(obj.nameRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType {
  /**
   * Type of information the findings limit applies to. Only one limit per info_type should be provided. If InfoTypeLimit does not have an info_type, the DLP API applies the limit against all info_types that are found but not specified in another InfoTypeLimit.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType#infoType
   */
  readonly infoType?: DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType;

  /**
   * Max findings limit for the given infoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType#maxFindings
   */
  readonly maxFindings?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType(obj: DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoType': toJson_DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj.infoType),
    'maxFindings': obj.maxFindings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules {
  /**
   * Exclusion rule.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules#exclusionRule
   */
  readonly exclusionRule?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule;

  /**
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules#hotwordRule
   */
  readonly hotwordRule?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclusionRule': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule(obj.exclusionRule),
    'hotwordRule': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule(obj.hotwordRule),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields {
  /**
   * Name describing the field.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsExcludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields {
  /**
   * Name describing the field.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields {
  /**
   * Name describing the field.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsIncludedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Complete BigQuery table reference.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference {
  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference#datasetRef
   */
  readonly datasetRef?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef;

  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference#projectRef
   */
  readonly projectRef?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef;

  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference#tableRef
   */
  readonly tableRef?: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetRef': toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef(obj.datasetRef),
    'projectRef': toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef(obj.projectRef),
    'tableRef': toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef(obj.tableRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The set of one or more files to scan.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet {
  /**
   * The regex-filtered set of files to scan. Exactly one of `url` or `regex_file_set` must be set.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet#regexFileSet
   */
  readonly regexFileSet?: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet;

  /**
   * The Cloud Storage url of the file(s) to scan, in the format `gs:///`. Trailing wildcard in the path is allowed. If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`. Exactly one of `url` or `regex_file_set` must be set.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet(obj: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexFileSet': toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(obj.regexFileSet),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The kind to process.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind {
  /**
   * The name of the kind.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind(obj: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A partition ID identifies a grouping of entities. The grouping is always by project namespace ID may be empty.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId {
  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId#projectRef
   */
  readonly projectRef?: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId(obj: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceId': obj.namespaceId,
    'projectRef': toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef(obj.projectRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions {
  /**
   * The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions#identifyingFields
   */
  readonly identifyingFields?: DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions(obj: DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifyingFields': obj.identifyingFields?.map(y => toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery. For BigQuery: If this value is not specified and the table was modified between the given start and end times, the entire table will be scanned. If this value is specified, then rows are filtered based on the given start and end times. Rows with a `NULL` value in the provided BigQuery column are skipped. Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`, `TIMESTAMP`, and `DATETIME`. For Datastore: If this value is specified, then entities are filtered based on the given start and end times. If an entity does not contain the provided timestamp property or contains empty or invalid values, then it is included. Valid data types of the provided timestamp property are: `TIMESTAMP`.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField {
  /**
   * Name describing the field.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField(obj: DlpJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store findings in an existing table or a new table in an existing dataset. If table_id is not set a new one will be generated for you with the following format: dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific timezone will be used for generating the date details. For Inspect, each column in an existing output table must have the same name, type, and mode of a field in the `Finding` object. For Risk, an existing output table should be the output of a previous Risk analysis job run on the same source table, with the same privacy metric and quasi-identifiers. Risk jobs that analyze the same table but compute a different privacy metric, or use different sets of quasi-identifiers, cannot store their results in the same table.
 *
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable {
  /**
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable#datasetRef
   */
  readonly datasetRef?: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef;

  /**
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable#projectRef
   */
  readonly projectRef?: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef;

  /**
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable#tableRef
   */
  readonly tableRef?: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable(obj: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetRef': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef(obj.datasetRef),
    'projectRef': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef(obj.projectRef),
    'tableRef': toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef(obj.tableRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Hotword-based detection rule.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex;

  /**
   * Likelihood adjustment to apply to all matching findings.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment;

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule#proximity
   */
  readonly proximity?: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex(obj.hotwordRegex),
    'likelihoodAdjustment': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment(obj.likelihoodAdjustment),
    'proximity': toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity(obj.proximity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of words or phrases to search for.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef {
  /**
   * Resource name of the requested `StoredInfoType`, for example `organizations/433245324/storedInfoTypes/432452342` or `projects/project-id/storedInfoTypes/432452342`.
   *
   * Allowed value: The Google Cloud resource name of a `DLPStoredInfoType` resource (format: `{{parent}}/storedInfoTypes/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesStoredTypeNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of information the findings limit applies to. Only one limit per info_type should be provided. If InfoTypeLimit does not have an info_type, the DLP API applies the limit against all info_types that are found but not specified in another InfoTypeLimit.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType(obj: DlpJobTriggerSpecInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exclusion rule.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule {
  /**
   * Dictionary which defines the rule.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule#dictionary
   */
  readonly dictionary?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary;

  /**
   * Set of infoTypes for which findings would affect this rule.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule#excludeInfoTypes
   */
  readonly excludeInfoTypes?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes;

  /**
   * How the rule is applied, see MatchingType documentation for details. Possible values: MATCHING_TYPE_UNSPECIFIED, MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule#matchingType
   */
  readonly matchingType?: string;

  /**
   * Regular expression which defines the rule.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule#regex
   */
  readonly regex?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dictionary': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(obj.dictionary),
    'excludeInfoTypes': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj.excludeInfoTypes),
    'matchingType': obj.matchingType,
    'regex': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(obj.regex),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule {
  /**
   * Regular expression pattern defining what qualifies as a hotword.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule#hotwordRegex
   */
  readonly hotwordRegex?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex;

  /**
   * Likelihood adjustment to apply to all matching findings.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule#likelihoodAdjustment
   */
  readonly likelihoodAdjustment?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment;

  /**
   * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule#proximity
   */
  readonly proximity?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hotwordRegex': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj.hotwordRegex),
    'likelihoodAdjustment': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj.likelihoodAdjustment),
    'proximity': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(obj.proximity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef {
  /**
   * Dataset ID of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryDataset` resource (format: `projects/{{project}}/datasets/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceDatasetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef {
  /**
   * The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef {
  /**
   * Name of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryTable` resource (format: `projects/{{project}}/datasets/{{dataset_id}}/tables/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef(obj: DlpJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceTableRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The regex-filtered set of files to scan. Exactly one of `url` or `regex_file_set` must be set.
 *
 * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet {
  /**
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#bucketRef
   */
  readonly bucketRef: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef;

  /**
   * A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#excludeRegex
   */
  readonly excludeRegex?: string[];

  /**
   * A list of regular expressions matching file paths to include. All files in the bucket that match at least one of these regular expressions will be included in the set of files, except for those that also match an item in `exclude_regex`. Leaving this field empty will match all files by default (this is equivalent to including `.*` in the list). Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet#includeRegex
   */
  readonly includeRegex?: string[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet(obj: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketRef': toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef(obj.bucketRef),
    'excludeRegex': obj.excludeRegex?.map(y => y),
    'includeRegex': obj.includeRegex?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef {
  /**
   * The ID of the project to which the entities belong.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef(obj: DlpJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIdProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields {
  /**
   * Name describing the field.
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields(obj: DlpJobTriggerSpecInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef {
  /**
   * Dataset ID of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryDataset` resource (format: `projects/{{project}}/datasets/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef(obj: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableDatasetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef {
  /**
   * The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef(obj: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef
 */
export interface DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef {
  /**
   * Name of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryTable` resource (format: `projects/{{project}}/datasets/{{dataset_id}}/tables/{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef(obj: DlpJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableTableRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression pattern defining what qualifies as a hotword.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Likelihood adjustment to apply to all matching findings.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be `POSSIBLE` without the detection rule and `relative_likelihood` is 1, then it is upgraded to `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`. Likelihood may never drop below `VERY_UNLIKELY` or exceed `VERY_LIKELY`, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is `VERY_LIKELY` will result in a final likelihood of `LIKELY`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity(obj: DlpJobTriggerSpecInspectJobInspectConfigCustomInfoTypesDetectionRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dictionary which defines the rule.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath;

  /**
   * List of words or phrases to search for.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary#wordList
   */
  readonly wordList?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj.cloudStoragePath),
    'wordList': toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj.wordList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of infoTypes for which findings would affect this rule.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes {
  /**
   * InfoType list in ExclusionRule rule drops a finding when it overlaps or contained within with a finding of an infoType from this list. For example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and `exclusion_rule` containing `exclude_info_types.info_types` with "EMAIL_ADDRESS" the phone number findings are dropped if they overlap with EMAIL_ADDRESS finding. That leads to "555-222-2222@example.org" to generate only a single finding, namely email address.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes#infoTypes
   */
  readonly infoTypes?: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'infoTypes': obj.infoTypes?.map(y => toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression which defines the rule.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Regular expression pattern defining what qualifies as a hotword.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleHotwordRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Likelihood adjustment to apply to all matching findings.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment {
  /**
   * Set the likelihood of a finding to a fixed value. Possible values: LIKELIHOOD_UNSPECIFIED, VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#fixedLikelihood
   */
  readonly fixedLikelihood?: string;

  /**
   * Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be `POSSIBLE` without the detection rule and `relative_likelihood` is 1, then it is upgraded to `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`. Likelihood may never drop below `VERY_UNLIKELY` or exceed `VERY_LIKELY`, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is `VERY_LIKELY` will result in a final likelihood of `LIKELY`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment#relativeLikelihood
   */
  readonly relativeLikelihood?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedLikelihood': obj.fixedLikelihood,
    'relativeLikelihood': obj.relativeLikelihood,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex "(d{3}) d{3}-d{4}" could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex "(xxx)", where "xxx" is the area code in question.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity {
  /**
   * Number of characters after the finding to consider.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowAfter
   */
  readonly windowAfter?: number;

  /**
   * Number of characters before the finding to consider.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity#windowBefore
   */
  readonly windowBefore?: number;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesHotwordRuleProximity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'windowAfter': obj.windowAfter,
    'windowBefore': obj.windowBefore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef
 */
export interface DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef {
  /**
   * The name of a Cloud Storage bucket. Required.
   *
   * Allowed value: The Google Cloud resource name of a `StorageBucket` resource (format: `{{name}}`).
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef(obj: DlpJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of words or phrases to search for.
 *
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList#words
   */
  readonly words?: string[];

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes
 */
export interface DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes {
  /**
   * Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#name
   */
  readonly name?: string;

  /**
   * Optional version name for this InfoType.
   *
   * @schema DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes(obj: DlpJobTriggerSpecInspectJobInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesInfoTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DLPStoredInfoType
 */
export class DlpStoredInfoType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DLPStoredInfoType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dlp.cnrm.cloud.google.com/v1beta1',
    kind: 'DLPStoredInfoType',
  }

  /**
   * Renders a Kubernetes manifest for "DLPStoredInfoType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlpStoredInfoTypeProps = {}): any {
    return {
      ...DlpStoredInfoType.GVK,
      ...toJson_DlpStoredInfoTypeProps(props),
    };
  }

  /**
   * Defines a "DLPStoredInfoType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DlpStoredInfoTypeProps = {}) {
    super(scope, id, {
      ...DlpStoredInfoType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlpStoredInfoType.GVK,
      ...toJson_DlpStoredInfoTypeProps(resolved),
    };
  }
}

/**
 * @schema DLPStoredInfoType
 */
export interface DlpStoredInfoTypeProps {
  /**
   * @schema DLPStoredInfoType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DLPStoredInfoType#spec
   */
  readonly spec?: DlpStoredInfoTypeSpec;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeProps(obj: DlpStoredInfoTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DlpStoredInfoTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpStoredInfoTypeSpec
 */
export interface DlpStoredInfoTypeSpec {
  /**
   * Description of the StoredInfoType (max 256 characters).
   *
   * @schema DlpStoredInfoTypeSpec#description
   */
  readonly description?: string;

  /**
   * Store dictionary-based CustomInfoType.
   *
   * @schema DlpStoredInfoTypeSpec#dictionary
   */
  readonly dictionary?: DlpStoredInfoTypeSpecDictionary;

  /**
   * Display name of the StoredInfoType (max 256 characters).
   *
   * @schema DlpStoredInfoTypeSpec#displayName
   */
  readonly displayName?: string;

  /**
   * StoredInfoType where findings are defined by a dictionary of phrases.
   *
   * @schema DlpStoredInfoTypeSpec#largeCustomDictionary
   */
  readonly largeCustomDictionary?: DlpStoredInfoTypeSpecLargeCustomDictionary;

  /**
   * Immutable. The location of the resource
   *
   * @schema DlpStoredInfoTypeSpec#location
   */
  readonly location?: string;

  /**
   * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpStoredInfoTypeSpec#organizationRef
   */
  readonly organizationRef?: DlpStoredInfoTypeSpecOrganizationRef;

  /**
   * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
   *
   * @schema DlpStoredInfoTypeSpec#projectRef
   */
  readonly projectRef?: DlpStoredInfoTypeSpecProjectRef;

  /**
   * Store regular expression-based StoredInfoType.
   *
   * @schema DlpStoredInfoTypeSpec#regex
   */
  readonly regex?: DlpStoredInfoTypeSpecRegex;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema DlpStoredInfoTypeSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpec(obj: DlpStoredInfoTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dictionary': toJson_DlpStoredInfoTypeSpecDictionary(obj.dictionary),
    'displayName': obj.displayName,
    'largeCustomDictionary': toJson_DlpStoredInfoTypeSpecLargeCustomDictionary(obj.largeCustomDictionary),
    'location': obj.location,
    'organizationRef': toJson_DlpStoredInfoTypeSpecOrganizationRef(obj.organizationRef),
    'projectRef': toJson_DlpStoredInfoTypeSpecProjectRef(obj.projectRef),
    'regex': toJson_DlpStoredInfoTypeSpecRegex(obj.regex),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store dictionary-based CustomInfoType.
 *
 * @schema DlpStoredInfoTypeSpecDictionary
 */
export interface DlpStoredInfoTypeSpecDictionary {
  /**
   * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
   *
   * @schema DlpStoredInfoTypeSpecDictionary#cloudStoragePath
   */
  readonly cloudStoragePath?: DlpStoredInfoTypeSpecDictionaryCloudStoragePath;

  /**
   * List of words or phrases to search for.
   *
   * @schema DlpStoredInfoTypeSpecDictionary#wordList
   */
  readonly wordList?: DlpStoredInfoTypeSpecDictionaryWordList;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecDictionary(obj: DlpStoredInfoTypeSpecDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudStoragePath': toJson_DlpStoredInfoTypeSpecDictionaryCloudStoragePath(obj.cloudStoragePath),
    'wordList': toJson_DlpStoredInfoTypeSpecDictionaryWordList(obj.wordList),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StoredInfoType where findings are defined by a dictionary of phrases.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionary
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionary {
  /**
   * Field in a BigQuery table where each cell represents a dictionary phrase.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionary#bigQueryField
   */
  readonly bigQueryField?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField;

  /**
   * Set of files containing newline-delimited lists of dictionary phrases.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionary#cloudStorageFileSet
   */
  readonly cloudStorageFileSet?: DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet;

  /**
   * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API. If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionary#outputPath
   */
  readonly outputPath?: DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionary(obj: DlpStoredInfoTypeSpecLargeCustomDictionary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigQueryField': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField(obj.bigQueryField),
    'cloudStorageFileSet': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet(obj.cloudStorageFileSet),
    'outputPath': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath(obj.outputPath),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpStoredInfoTypeSpecOrganizationRef
 */
export interface DlpStoredInfoTypeSpecOrganizationRef {
  /**
   * Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).
   *
   * @schema DlpStoredInfoTypeSpecOrganizationRef#external
   */
  readonly external?: string;

  /**
   * [WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpStoredInfoTypeSpecOrganizationRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpStoredInfoTypeSpecOrganizationRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecOrganizationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecOrganizationRef(obj: DlpStoredInfoTypeSpecOrganizationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.
 *
 * @schema DlpStoredInfoTypeSpecProjectRef
 */
export interface DlpStoredInfoTypeSpecProjectRef {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpStoredInfoTypeSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpStoredInfoTypeSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpStoredInfoTypeSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecProjectRef(obj: DlpStoredInfoTypeSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Store regular expression-based StoredInfoType.
 *
 * @schema DlpStoredInfoTypeSpecRegex
 */
export interface DlpStoredInfoTypeSpecRegex {
  /**
   * The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
   *
   * @schema DlpStoredInfoTypeSpecRegex#groupIndexes
   */
  readonly groupIndexes?: number[];

  /**
   * Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
   *
   * @schema DlpStoredInfoTypeSpecRegex#pattern
   */
  readonly pattern: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecRegex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecRegex(obj: DlpStoredInfoTypeSpecRegex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupIndexes': obj.groupIndexes?.map(y => y),
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
 *
 * @schema DlpStoredInfoTypeSpecDictionaryCloudStoragePath
 */
export interface DlpStoredInfoTypeSpecDictionaryCloudStoragePath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpStoredInfoTypeSpecDictionaryCloudStoragePath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecDictionaryCloudStoragePath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecDictionaryCloudStoragePath(obj: DlpStoredInfoTypeSpecDictionaryCloudStoragePath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * List of words or phrases to search for.
 *
 * @schema DlpStoredInfoTypeSpecDictionaryWordList
 */
export interface DlpStoredInfoTypeSpecDictionaryWordList {
  /**
   * Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
   *
   * @schema DlpStoredInfoTypeSpecDictionaryWordList#words
   */
  readonly words: string[];

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecDictionaryWordList' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecDictionaryWordList(obj: DlpStoredInfoTypeSpecDictionaryWordList | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'words': obj.words?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Field in a BigQuery table where each cell represents a dictionary phrase.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField {
  /**
   * Designated field in the BigQuery table.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField#field
   */
  readonly field?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField;

  /**
   * Source table of the field.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField#table
   */
  readonly table?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField(obj.field),
    'table': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable(obj.table),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Set of files containing newline-delimited lists of dictionary phrases.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet {
  /**
   * The url, in the format `gs:///`. Trailing wildcard in the path is allowed.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API. If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath {
  /**
   * A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryOutputPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Designated field in the BigQuery table.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField {
  /**
   * Name describing the field.
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source table of the field.
 *
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable {
  /**
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable#datasetRef
   */
  readonly datasetRef?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef;

  /**
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable#projectRef
   */
  readonly projectRef?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef;

  /**
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable#tableRef
   */
  readonly tableRef?: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetRef': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef(obj.datasetRef),
    'projectRef': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef(obj.projectRef),
    'tableRef': toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef(obj.tableRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef {
  /**
   * Dataset ID of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryDataset` resource (format: `projects/{{project}}/datasets/{{name}}`).
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableDatasetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef {
  /**
   * The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef
 */
export interface DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef {
  /**
   * Name of the table.
   *
   * Allowed value: The Google Cloud resource name of a `BigQueryTable` resource (format: `projects/{{project}}/datasets/{{dataset_id}}/tables/{{name}}`).
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef(obj: DlpStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableTableRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

