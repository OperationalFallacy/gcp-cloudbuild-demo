// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema NetworkServicesEndpointPolicy
 */
export class NetworkServicesEndpointPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesEndpointPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesEndpointPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesEndpointPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesEndpointPolicyProps): any {
    return {
      ...NetworkServicesEndpointPolicy.GVK,
      ...toJson_NetworkServicesEndpointPolicyProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesEndpointPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesEndpointPolicyProps) {
    super(scope, id, {
      ...NetworkServicesEndpointPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesEndpointPolicy.GVK,
      ...toJson_NetworkServicesEndpointPolicyProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesEndpointPolicy
 */
export interface NetworkServicesEndpointPolicyProps {
  /**
   * @schema NetworkServicesEndpointPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesEndpointPolicy#spec
   */
  readonly spec: NetworkServicesEndpointPolicySpec;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicyProps(obj: NetworkServicesEndpointPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesEndpointPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesEndpointPolicySpec
 */
export interface NetworkServicesEndpointPolicySpec {
  /**
   * @schema NetworkServicesEndpointPolicySpec#authorizationPolicyRef
   */
  readonly authorizationPolicyRef?: NetworkServicesEndpointPolicySpecAuthorizationPolicyRef;

  /**
   * @schema NetworkServicesEndpointPolicySpec#clientTlsPolicyRef
   */
  readonly clientTlsPolicyRef?: NetworkServicesEndpointPolicySpecClientTlsPolicyRef;

  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesEndpointPolicySpec#description
   */
  readonly description?: string;

  /**
   * Required. A matcher that selects endpoints to which the policies should be applied.
   *
   * @schema NetworkServicesEndpointPolicySpec#endpointMatcher
   */
  readonly endpointMatcher: NetworkServicesEndpointPolicySpecEndpointMatcher;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesEndpointPolicySpec#location
   */
  readonly location: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesEndpointPolicySpec#projectRef
   */
  readonly projectRef: NetworkServicesEndpointPolicySpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesEndpointPolicySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * @schema NetworkServicesEndpointPolicySpec#serverTlsPolicyRef
   */
  readonly serverTlsPolicyRef?: NetworkServicesEndpointPolicySpecServerTlsPolicyRef;

  /**
   * Optional. Port selector for the (matched) endpoints. If no port selector is provided, the matched config is applied to all ports.
   *
   * @schema NetworkServicesEndpointPolicySpec#trafficPortSelector
   */
  readonly trafficPortSelector?: NetworkServicesEndpointPolicySpecTrafficPortSelector;

  /**
   * Required. The type of endpoint config. This is primarily used to validate the configuration. Possible values: ENDPOINT_CONFIG_SELECTOR_TYPE_UNSPECIFIED, SIDECAR_PROXY, GRPC_SERVER
   *
   * @schema NetworkServicesEndpointPolicySpec#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpec(obj: NetworkServicesEndpointPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationPolicyRef': toJson_NetworkServicesEndpointPolicySpecAuthorizationPolicyRef(obj.authorizationPolicyRef),
    'clientTlsPolicyRef': toJson_NetworkServicesEndpointPolicySpecClientTlsPolicyRef(obj.clientTlsPolicyRef),
    'description': obj.description,
    'endpointMatcher': toJson_NetworkServicesEndpointPolicySpecEndpointMatcher(obj.endpointMatcher),
    'location': obj.location,
    'projectRef': toJson_NetworkServicesEndpointPolicySpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'serverTlsPolicyRef': toJson_NetworkServicesEndpointPolicySpecServerTlsPolicyRef(obj.serverTlsPolicyRef),
    'trafficPortSelector': toJson_NetworkServicesEndpointPolicySpecTrafficPortSelector(obj.trafficPortSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesEndpointPolicySpecAuthorizationPolicyRef
 */
export interface NetworkServicesEndpointPolicySpecAuthorizationPolicyRef {
  /**
   * Optional. This field specifies the URL of AuthorizationPolicy resource that applies authorization policies to the inbound traffic at the matched endpoints. Refer to Authorization. If this field is not specified, authorization is disabled(no authz checks) for this endpoint.
   *
   * Allowed value: The Google Cloud resource name of a `NetworkSecurityAuthorizationPolicy` resource (format: `projects/{{project}}/locations/{{location}}/authorizationPolicies/{{name}}`).
   *
   * @schema NetworkServicesEndpointPolicySpecAuthorizationPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesEndpointPolicySpecAuthorizationPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesEndpointPolicySpecAuthorizationPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecAuthorizationPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecAuthorizationPolicyRef(obj: NetworkServicesEndpointPolicySpecAuthorizationPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesEndpointPolicySpecClientTlsPolicyRef
 */
export interface NetworkServicesEndpointPolicySpecClientTlsPolicyRef {
  /**
   * Optional. A URL referring to a ClientTlsPolicy resource. ClientTlsPolicy can be set to specify the authentication for traffic from the proxy to the actual endpoints. More specifically, it is applied to the outgoing traffic from the proxy to the endpoint. This is typically used for sidecar model where the proxy identifies itself as endpoint to the control plane, with the connection between sidecar and endpoint requiring authentication. If this field is not set, authentication is disabled(open). Applicable only when EndpointPolicyType is SIDECAR_PROXY.
   *
   * Allowed value: The Google Cloud resource name of a `NetworkSecurityClientTLSPolicy` resource (format: `projects/{{project}}/locations/{{location}}/clientTlsPolicies/{{name}}`).
   *
   * @schema NetworkServicesEndpointPolicySpecClientTlsPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesEndpointPolicySpecClientTlsPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesEndpointPolicySpecClientTlsPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecClientTlsPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecClientTlsPolicyRef(obj: NetworkServicesEndpointPolicySpecClientTlsPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A matcher that selects endpoints to which the policies should be applied.
 *
 * @schema NetworkServicesEndpointPolicySpecEndpointMatcher
 */
export interface NetworkServicesEndpointPolicySpecEndpointMatcher {
  /**
   * The matcher is based on node metadata presented by xDS clients.
   *
   * @schema NetworkServicesEndpointPolicySpecEndpointMatcher#metadataLabelMatcher
   */
  readonly metadataLabelMatcher?: NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecEndpointMatcher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecEndpointMatcher(obj: NetworkServicesEndpointPolicySpecEndpointMatcher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadataLabelMatcher': toJson_NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher(obj.metadataLabelMatcher),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesEndpointPolicySpecProjectRef
 */
export interface NetworkServicesEndpointPolicySpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesEndpointPolicySpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesEndpointPolicySpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesEndpointPolicySpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecProjectRef(obj: NetworkServicesEndpointPolicySpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesEndpointPolicySpecServerTlsPolicyRef
 */
export interface NetworkServicesEndpointPolicySpecServerTlsPolicyRef {
  /**
   * Optional. A URL referring to ServerTlsPolicy resource. ServerTlsPolicy is used to determine the authentication policy to be applied to terminate the inbound traffic at the identified backends. If this field is not set, authentication is disabled(open) for this endpoint.
   *
   * Allowed value: The Google Cloud resource name of a `NetworkSecurityServerTLSPolicy` resource (format: `projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}`).
   *
   * @schema NetworkServicesEndpointPolicySpecServerTlsPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesEndpointPolicySpecServerTlsPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesEndpointPolicySpecServerTlsPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecServerTlsPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecServerTlsPolicyRef(obj: NetworkServicesEndpointPolicySpecServerTlsPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Port selector for the (matched) endpoints. If no port selector is provided, the matched config is applied to all ports.
 *
 * @schema NetworkServicesEndpointPolicySpecTrafficPortSelector
 */
export interface NetworkServicesEndpointPolicySpecTrafficPortSelector {
  /**
   * Optional. A list of ports. Can be port numbers or port range (example, specifies all ports from 80 to 90, including 80 and 90) or named ports or * to specify all ports. If the list is empty, all ports are selected.
   *
   * @schema NetworkServicesEndpointPolicySpecTrafficPortSelector#ports
   */
  readonly ports?: string[];

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecTrafficPortSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecTrafficPortSelector(obj: NetworkServicesEndpointPolicySpecTrafficPortSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ports': obj.ports?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The matcher is based on node metadata presented by xDS clients.
 *
 * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher
 */
export interface NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher {
  /**
   * Specifies how matching should be done. Supported values are: MATCH_ANY: At least one of the Labels specified in the matcher should match the metadata presented by xDS client. MATCH_ALL: The metadata presented by the xDS client should contain all of the labels specified here. The selection is determined based on the best match. For example, suppose there are three EndpointPolicy resources P1, P2 and P3 and if P1 has a the matcher as MATCH_ANY , P2 has MATCH_ALL , and P3 has MATCH_ALL . If a client with label connects, the config from P1 will be selected. If a client with label connects, the config from P2 will be selected. If a client with label connects, the config from P3 will be selected. If there is more than one best match, (for example, if a config P4 with selector exists and if a client with label connects), an error will be thrown. Possible values: METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED, MATCH_ANY, MATCH_ALL
   *
   * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher#metadataLabelMatchCriteria
   */
  readonly metadataLabelMatchCriteria?: string;

  /**
   * The list of label value pairs that must match labels in the provided metadata based on filterMatchCriteria This list can have at most 64 entries. The list can be empty if the match criteria is MATCH_ANY, to specify a wildcard match (i.e this matches any client).
   *
   * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher#metadataLabels
   */
  readonly metadataLabels?: NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels[];

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher(obj: NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadataLabelMatchCriteria': obj.metadataLabelMatchCriteria,
    'metadataLabels': obj.metadataLabels?.map(y => toJson_NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels
 */
export interface NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels {
  /**
   * Required. Label name presented as key in xDS Node Metadata.
   *
   * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels#labelName
   */
  readonly labelName: string;

  /**
   * Required. Label value presented as value corresponding to the above key, in xDS Node Metadata.
   *
   * @schema NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels#labelValue
   */
  readonly labelValue: string;

}

/**
 * Converts an object of type 'NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels(obj: NetworkServicesEndpointPolicySpecEndpointMatcherMetadataLabelMatcherMetadataLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelName': obj.labelName,
    'labelValue': obj.labelValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesGateway
 */
export class NetworkServicesGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesGateway',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesGatewayProps): any {
    return {
      ...NetworkServicesGateway.GVK,
      ...toJson_NetworkServicesGatewayProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesGatewayProps) {
    super(scope, id, {
      ...NetworkServicesGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesGateway.GVK,
      ...toJson_NetworkServicesGatewayProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesGateway
 */
export interface NetworkServicesGatewayProps {
  /**
   * @schema NetworkServicesGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesGateway#spec
   */
  readonly spec: NetworkServicesGatewaySpec;

}

/**
 * Converts an object of type 'NetworkServicesGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGatewayProps(obj: NetworkServicesGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGatewaySpec
 */
export interface NetworkServicesGatewaySpec {
  /**
   * One or more addresses with ports in format of ":" that the Gateway must receive traffic on. The proxy binds to the ports specified. IP address can be anything that is allowed by the underlying infrastructure (auto-allocation, static IP, BYOIP).
   *
   * @schema NetworkServicesGatewaySpec#addresses
   */
  readonly addresses?: string[];

  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesGatewaySpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesGatewaySpec#location
   */
  readonly location: string;

  /**
   * Required. One or more ports that the Gateway must receive traffic on. The proxy binds to the ports specified. Gateway listen on 0.0.0.0 on the ports specified below.
   *
   * @schema NetworkServicesGatewaySpec#ports
   */
  readonly ports: number[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesGatewaySpec#projectRef
   */
  readonly projectRef: NetworkServicesGatewaySpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesGatewaySpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Required. Immutable. Scope determines how configuration across multiple Gateway instances are merged. The configuration for multiple Gateway instances with the same scope will be merged as presented as a single coniguration to the proxy/load balancer. Max length 64 characters. Scope should start with a letter and can only have letters, numbers, hyphens.
   *
   * @schema NetworkServicesGatewaySpec#scope
   */
  readonly scope: string;

  /**
   * @schema NetworkServicesGatewaySpec#serverTlsPolicyRef
   */
  readonly serverTlsPolicyRef?: NetworkServicesGatewaySpecServerTlsPolicyRef;

  /**
   * Immutable. Immutable. The type of the customer managed gateway. Possible values: TYPE_UNSPECIFIED, OPEN_MESH, SECURE_WEB_GATEWAY
   *
   * @schema NetworkServicesGatewaySpec#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NetworkServicesGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGatewaySpec(obj: NetworkServicesGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'description': obj.description,
    'location': obj.location,
    'ports': obj.ports?.map(y => y),
    'projectRef': toJson_NetworkServicesGatewaySpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'scope': obj.scope,
    'serverTlsPolicyRef': toJson_NetworkServicesGatewaySpecServerTlsPolicyRef(obj.serverTlsPolicyRef),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesGatewaySpecProjectRef
 */
export interface NetworkServicesGatewaySpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesGatewaySpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGatewaySpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGatewaySpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGatewaySpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGatewaySpecProjectRef(obj: NetworkServicesGatewaySpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGatewaySpecServerTlsPolicyRef
 */
export interface NetworkServicesGatewaySpecServerTlsPolicyRef {
  /**
   * Optional. A fully-qualified ServerTLSPolicy URL reference. Specifies how TLS traffic is terminated. If empty, TLS termination is disabled.
   *
   * Allowed value: The Google Cloud resource name of a `NetworkSecurityServerTLSPolicy` resource (format: `projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}`).
   *
   * @schema NetworkServicesGatewaySpecServerTlsPolicyRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGatewaySpecServerTlsPolicyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGatewaySpecServerTlsPolicyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGatewaySpecServerTlsPolicyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGatewaySpecServerTlsPolicyRef(obj: NetworkServicesGatewaySpecServerTlsPolicyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesGRPCRoute
 */
export class NetworkServicesGrpcRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesGRPCRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesGRPCRoute',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesGRPCRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesGrpcRouteProps): any {
    return {
      ...NetworkServicesGrpcRoute.GVK,
      ...toJson_NetworkServicesGrpcRouteProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesGRPCRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesGrpcRouteProps) {
    super(scope, id, {
      ...NetworkServicesGrpcRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesGrpcRoute.GVK,
      ...toJson_NetworkServicesGrpcRouteProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesGRPCRoute
 */
export interface NetworkServicesGrpcRouteProps {
  /**
   * @schema NetworkServicesGRPCRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesGRPCRoute#spec
   */
  readonly spec: NetworkServicesGrpcRouteSpec;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteProps(obj: NetworkServicesGrpcRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesGrpcRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpec
 */
export interface NetworkServicesGrpcRouteSpec {
  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesGrpcRouteSpec#description
   */
  readonly description?: string;

  /**
   * @schema NetworkServicesGrpcRouteSpec#gateways
   */
  readonly gateways?: NetworkServicesGrpcRouteSpecGateways[];

  /**
   * Required. Service hostnames with an optional port for which this route describes traffic. Format: [:] Hostname is the fully qualified domain name of a network host. This matches the RFC 1123 definition of a hostname with 2 notable exceptions: - IPs are not allowed. - A hostname may be prefixed with a wildcard label (*.). The wildcard label must appear by itself as the first label. Hostname can be “precise” which is a domain name without the terminating dot of a network host (e.g. “foo.example.com”) or “wildcard”, which is a domain name prefixed with a single wildcard label (e.g. *.example.com). Note that as per RFC1035 and RFC1123, a label must consist of lower case alphanumeric characters or ‘-’, and must start and end with an alphanumeric character. No other punctuation is allowed. The routes associated with a Router must have unique hostnames. If you attempt to attach multiple routes with conflicting hostnames, the configuration will be rejected. For example, while it is acceptable for routes for the hostnames "*.foo.bar.com" and "*.bar.com" to be associated with the same route, it is not possible to associate two routes both with "*.bar.com" or both with "bar.com". In the case that multiple routes match the hostname, the most specific match will be selected. For example, "foo.bar.baz.com" will take precedence over "*.bar.baz.com" and "*.bar.baz.com" will take precedence over "*.baz.com". If a port is specified, then gRPC clients must use the channel URI with the port to match this rule (i.e. "xds:///service:123"), otherwise they must supply the URI without a port (i.e. "xds:///service").
   *
   * @schema NetworkServicesGrpcRouteSpec#hostnames
   */
  readonly hostnames: string[];

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesGrpcRouteSpec#location
   */
  readonly location: string;

  /**
   * @schema NetworkServicesGrpcRouteSpec#meshes
   */
  readonly meshes?: NetworkServicesGrpcRouteSpecMeshes[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesGrpcRouteSpec#projectRef
   */
  readonly projectRef: NetworkServicesGrpcRouteSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesGrpcRouteSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Required. A list of detailed rules defining how to route traffic. Within a single GrpcRoute, the GrpcRoute.RouteAction associated with the first matching GrpcRoute.RouteRule will be executed. At least one rule must be supplied.
   *
   * @schema NetworkServicesGrpcRouteSpec#rules
   */
  readonly rules: NetworkServicesGrpcRouteSpecRules[];

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpec(obj: NetworkServicesGrpcRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'gateways': obj.gateways?.map(y => toJson_NetworkServicesGrpcRouteSpecGateways(y)),
    'hostnames': obj.hostnames?.map(y => y),
    'location': obj.location,
    'meshes': obj.meshes?.map(y => toJson_NetworkServicesGrpcRouteSpecMeshes(y)),
    'projectRef': toJson_NetworkServicesGrpcRouteSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rules': obj.rules?.map(y => toJson_NetworkServicesGrpcRouteSpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecGateways
 */
export interface NetworkServicesGrpcRouteSpecGateways {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesGateway` resource.
   *
   * @schema NetworkServicesGrpcRouteSpecGateways#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGrpcRouteSpecGateways#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGrpcRouteSpecGateways#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecGateways' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecGateways(obj: NetworkServicesGrpcRouteSpecGateways | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecMeshes
 */
export interface NetworkServicesGrpcRouteSpecMeshes {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesMesh` resource.
   *
   * @schema NetworkServicesGrpcRouteSpecMeshes#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGrpcRouteSpecMeshes#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGrpcRouteSpecMeshes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecMeshes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecMeshes(obj: NetworkServicesGrpcRouteSpecMeshes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesGrpcRouteSpecProjectRef
 */
export interface NetworkServicesGrpcRouteSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesGrpcRouteSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGrpcRouteSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGrpcRouteSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecProjectRef(obj: NetworkServicesGrpcRouteSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecRules
 */
export interface NetworkServicesGrpcRouteSpecRules {
  /**
   * Required. A detailed rule defining how to route traffic. This field is required.
   *
   * @schema NetworkServicesGrpcRouteSpecRules#action
   */
  readonly action: NetworkServicesGrpcRouteSpecRulesAction;

  /**
   * Optional. Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied. If no matches field is specified, this rule will unconditionally match traffic.
   *
   * @schema NetworkServicesGrpcRouteSpecRules#matches
   */
  readonly matches?: NetworkServicesGrpcRouteSpecRulesMatches[];

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRules(obj: NetworkServicesGrpcRouteSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_NetworkServicesGrpcRouteSpecRulesAction(obj.action),
    'matches': obj.matches?.map(y => toJson_NetworkServicesGrpcRouteSpecRulesMatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A detailed rule defining how to route traffic. This field is required.
 *
 * @schema NetworkServicesGrpcRouteSpecRulesAction
 */
export interface NetworkServicesGrpcRouteSpecRulesAction {
  /**
   * Optional. The destination services to which traffic should be forwarded. If multiple destinations are specified, traffic will be split between Backend Service(s) according to the weight field of these destinations.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesAction#destinations
   */
  readonly destinations?: NetworkServicesGrpcRouteSpecRulesActionDestinations[];

  /**
   * Optional. The specification for fault injection introduced into traffic to test the resiliency of clients to destination service failure. As part of fault injection, when clients send requests to a destination, delays can be introduced on a percentage of requests before sending those requests to the destination service. Similarly requests from clients can be aborted by for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy
   *
   * @schema NetworkServicesGrpcRouteSpecRulesAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy;

  /**
   * Optional. Specifies the retry policy associated with this route.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesAction#retryPolicy
   */
  readonly retryPolicy?: NetworkServicesGrpcRouteSpecRulesActionRetryPolicy;

  /**
   * Optional. Specifies the timeout for selected route. Timeout is computed from the time the request has been fully processed (i.e. end of stream) up until the response has been completely processed. Timeout includes all retries.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesAction#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesAction(obj: NetworkServicesGrpcRouteSpecRulesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinations': obj.destinations?.map(y => toJson_NetworkServicesGrpcRouteSpecRulesActionDestinations(y)),
    'faultInjectionPolicy': toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'retryPolicy': toJson_NetworkServicesGrpcRouteSpecRulesActionRetryPolicy(obj.retryPolicy),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecRulesMatches
 */
export interface NetworkServicesGrpcRouteSpecRulesMatches {
  /**
   * Optional. Specifies a collection of headers to match.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatches#headers
   */
  readonly headers?: NetworkServicesGrpcRouteSpecRulesMatchesHeaders[];

  /**
   * Optional. A gRPC method to match against. If this field is empty or omitted, will match all methods.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatches#method
   */
  readonly method?: NetworkServicesGrpcRouteSpecRulesMatchesMethod;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesMatches(obj: NetworkServicesGrpcRouteSpecRulesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers?.map(y => toJson_NetworkServicesGrpcRouteSpecRulesMatchesHeaders(y)),
    'method': toJson_NetworkServicesGrpcRouteSpecRulesMatchesMethod(obj.method),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecRulesActionDestinations
 */
export interface NetworkServicesGrpcRouteSpecRulesActionDestinations {
  /**
   * @schema NetworkServicesGrpcRouteSpecRulesActionDestinations#serviceRef
   */
  readonly serviceRef: NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef;

  /**
   * Optional. Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionDestinations#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionDestinations(obj: NetworkServicesGrpcRouteSpecRulesActionDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef(obj.serviceRef),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. The specification for fault injection introduced into traffic to test the resiliency of clients to destination service failure. As part of fault injection, when clients send requests to a destination, delays can be introduced on a percentage of requests before sending those requests to the destination service. Similarly requests from clients can be aborted by for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy
 *
 * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy
 */
export interface NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy {
  /**
   * The specification for aborting to client requests.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy#abort
   */
  readonly abort?: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort;

  /**
   * The specification for injecting delay to client requests.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy#delay
   */
  readonly delay?: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy(obj: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. Specifies the retry policy associated with this route.
 *
 * @schema NetworkServicesGrpcRouteSpecRulesActionRetryPolicy
 */
export interface NetworkServicesGrpcRouteSpecRulesActionRetryPolicy {
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not specpfied, default to 1.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionRetryPolicy#numRetries
   */
  readonly numRetries?: number;

  /**
   * - connect-failure: Router will retry on failures connecting to Backend Services, for example due to connection timeouts. - refused-stream: Router will retry if the backend service resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry. - cancelled: Router will retry if the gRPC status code in the response header is set to cancelled - deadline-exceeded: Router will retry if the gRPC status code in the response header is set to deadline-exceeded - resource-exhausted: Router will retry if the gRPC status code in the response header is set to resource-exhausted - unavailable: Router will retry if the gRPC status code in the response header is set to unavailable
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionRetryPolicy(obj: NetworkServicesGrpcRouteSpecRulesActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecRulesMatchesHeaders
 */
export interface NetworkServicesGrpcRouteSpecRulesMatchesHeaders {
  /**
   * Required. The key of the header.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesHeaders#key
   */
  readonly key: string;

  /**
   * Optional. Specifies how to match against the value of the header. If not specified, a default value of EXACT is used. Possible values: MATCH_TYPE_UNSPECIFIED, MATCH_ANY, MATCH_ALL
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesHeaders#type
   */
  readonly type?: string;

  /**
   * Required. The value of the header.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesMatchesHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesMatchesHeaders(obj: NetworkServicesGrpcRouteSpecRulesMatchesHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional. A gRPC method to match against. If this field is empty or omitted, will match all methods.
 *
 * @schema NetworkServicesGrpcRouteSpecRulesMatchesMethod
 */
export interface NetworkServicesGrpcRouteSpecRulesMatchesMethod {
  /**
   * Optional. Specifies that matches are case sensitive. The default value is true. case_sensitive must not be used with a type of REGULAR_EXPRESSION.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesMethod#caseSensitive
   */
  readonly caseSensitive?: boolean;

  /**
   * Required. Name of the method to match against. If unspecified, will match all methods.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesMethod#grpcMethod
   */
  readonly grpcMethod: string;

  /**
   * Required. Name of the service to match against. If unspecified, will match all services.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesMethod#grpcService
   */
  readonly grpcService: string;

  /**
   * Optional. Specifies how to match against the name. If not specified, a default value of "EXACT" is used. Possible values: TYPE_UNSPECIFIED, EXACT, REGULAR_EXPRESSION
   *
   * @schema NetworkServicesGrpcRouteSpecRulesMatchesMethod#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesMatchesMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesMatchesMethod(obj: NetworkServicesGrpcRouteSpecRulesMatchesMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caseSensitive': obj.caseSensitive,
    'grpcMethod': obj.grpcMethod,
    'grpcService': obj.grpcService,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef
 */
export interface NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef {
  /**
   * Required. The URL of a destination service to which to route traffic. Must refer to either a BackendService or ServiceDirectoryService.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeBackendService` resource (format: `projects/{{project}}/global/backendServices/{{name}}`).
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef(obj: NetworkServicesGrpcRouteSpecRulesActionDestinationsServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for aborting to client requests.
 *
 * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort
 */
export interface NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request. The value must be between 200 and 599 inclusive.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * The percentage of traffic which will be aborted. The value must be between [0, 100]
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort(obj: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for injecting delay to client requests.
 *
 * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay
 */
export interface NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay {
  /**
   * Specify a fixed delay before forwarding the request.
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * The percentage of traffic on which delay will be injected. The value must be between [0, 100]
   *
   * @schema NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay(obj: NetworkServicesGrpcRouteSpecRulesActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': obj.fixedDelay,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesHTTPRoute
 */
export class NetworkServicesHttpRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesHTTPRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesHTTPRoute',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesHTTPRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesHttpRouteProps): any {
    return {
      ...NetworkServicesHttpRoute.GVK,
      ...toJson_NetworkServicesHttpRouteProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesHTTPRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesHttpRouteProps) {
    super(scope, id, {
      ...NetworkServicesHttpRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesHttpRoute.GVK,
      ...toJson_NetworkServicesHttpRouteProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesHTTPRoute
 */
export interface NetworkServicesHttpRouteProps {
  /**
   * @schema NetworkServicesHTTPRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesHTTPRoute#spec
   */
  readonly spec: NetworkServicesHttpRouteSpec;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteProps(obj: NetworkServicesHttpRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesHttpRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpec
 */
export interface NetworkServicesHttpRouteSpec {
  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesHttpRouteSpec#description
   */
  readonly description?: string;

  /**
   * @schema NetworkServicesHttpRouteSpec#gateways
   */
  readonly gateways?: NetworkServicesHttpRouteSpecGateways[];

  /**
   * Required. Hostnames define a set of hosts that should match against the HTTP host header to select a HttpRoute to process the request. Hostname is the fully qualified domain name of a network host, as defined by RFC 1123 with the exception that ip addresses are not allowed. Wildcard hosts are supported as "*" (no prefix or suffix allowed).
   *
   * @schema NetworkServicesHttpRouteSpec#hostnames
   */
  readonly hostnames: string[];

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesHttpRouteSpec#location
   */
  readonly location: string;

  /**
   * @schema NetworkServicesHttpRouteSpec#meshes
   */
  readonly meshes?: NetworkServicesHttpRouteSpecMeshes[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesHttpRouteSpec#projectRef
   */
  readonly projectRef: NetworkServicesHttpRouteSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesHttpRouteSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Required. Rules that define how traffic is routed and handled.
   *
   * @schema NetworkServicesHttpRouteSpec#rules
   */
  readonly rules: NetworkServicesHttpRouteSpecRules[];

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpec(obj: NetworkServicesHttpRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'gateways': obj.gateways?.map(y => toJson_NetworkServicesHttpRouteSpecGateways(y)),
    'hostnames': obj.hostnames?.map(y => y),
    'location': obj.location,
    'meshes': obj.meshes?.map(y => toJson_NetworkServicesHttpRouteSpecMeshes(y)),
    'projectRef': toJson_NetworkServicesHttpRouteSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rules': obj.rules?.map(y => toJson_NetworkServicesHttpRouteSpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecGateways
 */
export interface NetworkServicesHttpRouteSpecGateways {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesGateway` resource.
   *
   * @schema NetworkServicesHttpRouteSpecGateways#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesHttpRouteSpecGateways#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesHttpRouteSpecGateways#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecGateways' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecGateways(obj: NetworkServicesHttpRouteSpecGateways | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecMeshes
 */
export interface NetworkServicesHttpRouteSpecMeshes {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesMesh` resource.
   *
   * @schema NetworkServicesHttpRouteSpecMeshes#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesHttpRouteSpecMeshes#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesHttpRouteSpecMeshes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecMeshes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecMeshes(obj: NetworkServicesHttpRouteSpecMeshes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesHttpRouteSpecProjectRef
 */
export interface NetworkServicesHttpRouteSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesHttpRouteSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesHttpRouteSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesHttpRouteSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecProjectRef(obj: NetworkServicesHttpRouteSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRules
 */
export interface NetworkServicesHttpRouteSpecRules {
  /**
   * The detailed rule defining how to route matched traffic.
   *
   * @schema NetworkServicesHttpRouteSpecRules#action
   */
  readonly action?: NetworkServicesHttpRouteSpecRulesAction;

  /**
   * A list of matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied.
   *
   * @schema NetworkServicesHttpRouteSpecRules#matches
   */
  readonly matches?: NetworkServicesHttpRouteSpecRulesMatches[];

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRules(obj: NetworkServicesHttpRouteSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_NetworkServicesHttpRouteSpecRulesAction(obj.action),
    'matches': obj.matches?.map(y => toJson_NetworkServicesHttpRouteSpecRulesMatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The detailed rule defining how to route matched traffic.
 *
 * @schema NetworkServicesHttpRouteSpecRulesAction
 */
export interface NetworkServicesHttpRouteSpecRulesAction {
  /**
   * The specification for allowing client side cross-origin requests.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#corsPolicy
   */
  readonly corsPolicy?: NetworkServicesHttpRouteSpecRulesActionCorsPolicy;

  /**
   * The destination to which traffic should be forwarded.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#destinations
   */
  readonly destinations?: NetworkServicesHttpRouteSpecRulesActionDestinations[];

  /**
   * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure. As part of fault injection, when clients send requests to a backend service, delays can be introduced on a percentage of requests before sending those requests to the backend service. Similarly requests from clients can be aborted for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#faultInjectionPolicy
   */
  readonly faultInjectionPolicy?: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy;

  /**
   * If set, the request is directed as configured by this field.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#redirect
   */
  readonly redirect?: NetworkServicesHttpRouteSpecRulesActionRedirect;

  /**
   * The specification for modifying the headers of a matching request prior to delivery of the request to the destination.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#requestHeaderModifier
   */
  readonly requestHeaderModifier?: NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier;

  /**
   * Specifies the policy on how requests intended for the routes destination are shadowed to a separate mirrored destination. Proxy will not wait for the shadow destination to respond before returning the response. Prior to sending traffic to the shadow service, the host/authority header is suffixed with -shadow.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#requestMirrorPolicy
   */
  readonly requestMirrorPolicy?: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy;

  /**
   * The specification for modifying the headers of a response prior to sending the response back to the client.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#responseHeaderModifier
   */
  readonly responseHeaderModifier?: NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier;

  /**
   * Specifies the retry policy associated with this route.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#retryPolicy
   */
  readonly retryPolicy?: NetworkServicesHttpRouteSpecRulesActionRetryPolicy;

  /**
   * Specifies the timeout for selected route. Timeout is computed from the time the request has been fully processed (i.e. end of stream) up until the response has been completely processed. Timeout includes all retries.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#timeout
   */
  readonly timeout?: string;

  /**
   * The specification for rewrite URL before forwarding requests to the destination.
   *
   * @schema NetworkServicesHttpRouteSpecRulesAction#urlRewrite
   */
  readonly urlRewrite?: NetworkServicesHttpRouteSpecRulesActionUrlRewrite;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesAction(obj: NetworkServicesHttpRouteSpecRulesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_NetworkServicesHttpRouteSpecRulesActionCorsPolicy(obj.corsPolicy),
    'destinations': obj.destinations?.map(y => toJson_NetworkServicesHttpRouteSpecRulesActionDestinations(y)),
    'faultInjectionPolicy': toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy(obj.faultInjectionPolicy),
    'redirect': toJson_NetworkServicesHttpRouteSpecRulesActionRedirect(obj.redirect),
    'requestHeaderModifier': toJson_NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier(obj.requestHeaderModifier),
    'requestMirrorPolicy': toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy(obj.requestMirrorPolicy),
    'responseHeaderModifier': toJson_NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier(obj.responseHeaderModifier),
    'retryPolicy': toJson_NetworkServicesHttpRouteSpecRulesActionRetryPolicy(obj.retryPolicy),
    'timeout': obj.timeout,
    'urlRewrite': toJson_NetworkServicesHttpRouteSpecRulesActionUrlRewrite(obj.urlRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesMatches
 */
export interface NetworkServicesHttpRouteSpecRulesMatches {
  /**
   * The HTTP request path value should exactly match this value. Only one of full_path_match, prefix_match, or regex_match should be used.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#fullPathMatch
   */
  readonly fullPathMatch?: string;

  /**
   * Specifies a list of HTTP request headers to match against. ALL of the supplied headers must be matched.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#headers
   */
  readonly headers?: NetworkServicesHttpRouteSpecRulesMatchesHeaders[];

  /**
   * Specifies if prefix_match and full_path_match matches are case sensitive. The default value is false.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#ignoreCase
   */
  readonly ignoreCase?: boolean;

  /**
   * The HTTP request path value must begin with specified prefix_match. prefix_match must begin with a /. Only one of full_path_match, prefix_match, or regex_match should be used.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#prefixMatch
   */
  readonly prefixMatch?: string;

  /**
   * Specifies a list of query parameters to match against. ALL of the query parameters must be matched.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#queryParameters
   */
  readonly queryParameters?: NetworkServicesHttpRouteSpecRulesMatchesQueryParameters[];

  /**
   * The HTTP request path value must satisfy the regular expression specified by regex_match after removing any query parameters and anchor supplied with the original URL. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax Only one of full_path_match, prefix_match, or regex_match should be used.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatches#regexMatch
   */
  readonly regexMatch?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesMatches(obj: NetworkServicesHttpRouteSpecRulesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fullPathMatch': obj.fullPathMatch,
    'headers': obj.headers?.map(y => toJson_NetworkServicesHttpRouteSpecRulesMatchesHeaders(y)),
    'ignoreCase': obj.ignoreCase,
    'prefixMatch': obj.prefixMatch,
    'queryParameters': obj.queryParameters?.map(y => toJson_NetworkServicesHttpRouteSpecRulesMatchesQueryParameters(y)),
    'regexMatch': obj.regexMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for allowing client side cross-origin requests.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy
 */
export interface NetworkServicesHttpRouteSpecRulesActionCorsPolicy {
  /**
   * In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This translates to the Access-Control-Allow-Credentials header. Default value is false.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * Specifies the content for Access-Control-Allow-Headers header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * Specifies the content for Access-Control-Allow-Methods header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * Specifies the regular expression patterns that match allowed origins. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#allowOriginRegexes
   */
  readonly allowOriginRegexes?: string[];

  /**
   * Specifies the list of origins that will be allowed to do CORS requests. An origin is allowed if it matches either an item in allow_origins or an item in allow_origin_regexes.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: string[];

  /**
   * If true, the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#disabled
   */
  readonly disabled?: boolean;

  /**
   * Specifies the content for Access-Control-Expose-Headers header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long result of a preflight request can be cached in seconds. This translates to the Access-Control-Max-Age header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionCorsPolicy#maxAge
   */
  readonly maxAge?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionCorsPolicy(obj: NetworkServicesHttpRouteSpecRulesActionCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOriginRegexes': obj.allowOriginRegexes?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => y),
    'disabled': obj.disabled,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesActionDestinations
 */
export interface NetworkServicesHttpRouteSpecRulesActionDestinations {
  /**
   * @schema NetworkServicesHttpRouteSpecRulesActionDestinations#serviceRef
   */
  readonly serviceRef?: NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef;

  /**
   * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionDestinations#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionDestinations(obj: NetworkServicesHttpRouteSpecRulesActionDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef(obj.serviceRef),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure. As part of fault injection, when clients send requests to a backend service, delays can be introduced on a percentage of requests before sending those requests to the backend service. Similarly requests from clients can be aborted for a percentage of requests. timeout and retry_policy will be ignored by clients that are configured with a fault_injection_policy
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy
 */
export interface NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy {
  /**
   * The specification for aborting to client requests.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy#abort
   */
  readonly abort?: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort;

  /**
   * The specification for injecting delay to client requests.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy#delay
   */
  readonly delay?: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy(obj: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort(obj.abort),
    'delay': toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If set, the request is directed as configured by this field.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionRedirect
 */
export interface NetworkServicesHttpRouteSpecRulesActionRedirect {
  /**
   * The host that will be used in the redirect response instead of the one that was supplied in the request.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#hostRedirect
   */
  readonly hostRedirect?: string;

  /**
   * If set to true, the URL scheme in the redirected request is set to https. If set to false, the URL scheme of the redirected request will remain the same as that of the request. The default is set to false.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * The path that will be used in the redirect response instead of the one that was supplied in the request. path_redirect can not be supplied together with prefix_redirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#pathRedirect
   */
  readonly pathRedirect?: string;

  /**
   * The port that will be used in the redirected request instead of the one that was supplied in the request.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#portRedirect
   */
  readonly portRedirect?: number;

  /**
   * Indicates that during redirection, the matched prefix (or path) should be swapped with this value. This option allows URLs be dynamically created based on the request.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#prefixRewrite
   */
  readonly prefixRewrite?: string;

  /**
   * The HTTP Status code to use for the redirect. Possible values: MOVED_PERMANENTLY_DEFAULT, FOUND, SEE_OTHER, TEMPORARY_REDIRECT, PERMANENT_REDIRECT
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#responseCode
   */
  readonly responseCode?: string;

  /**
   * if set to true, any accompanying query portion of the original URL is removed prior to redirecting the request. If set to false, the query portion of the original URL is retained. The default is set to false.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRedirect#stripQuery
   */
  readonly stripQuery?: boolean;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRedirect(obj: NetworkServicesHttpRouteSpecRulesActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRedirect': obj.hostRedirect,
    'httpsRedirect': obj.httpsRedirect,
    'pathRedirect': obj.pathRedirect,
    'portRedirect': obj.portRedirect,
    'prefixRewrite': obj.prefixRewrite,
    'responseCode': obj.responseCode,
    'stripQuery': obj.stripQuery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for modifying the headers of a matching request prior to delivery of the request to the destination.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier
 */
export interface NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier {
  /**
   * Add the headers with given map where key is the name of the header, value is the value of the header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier#add
   */
  readonly add?: { [key: string]: string };

  /**
   * Remove headers (matching by header names) specified in the list.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier#remove
   */
  readonly remove?: string[];

  /**
   * Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier(obj: NetworkServicesHttpRouteSpecRulesActionRequestHeaderModifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the policy on how requests intended for the routes destination are shadowed to a separate mirrored destination. Proxy will not wait for the shadow destination to respond before returning the response. Prior to sending traffic to the shadow service, the host/authority header is suffixed with -shadow.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy
 */
export interface NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy {
  /**
   * The destination the requests will be mirrored to. The weight of the destination will be ignored.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy#destination
   */
  readonly destination?: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy(obj: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination(obj.destination),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for modifying the headers of a response prior to sending the response back to the client.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier
 */
export interface NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier {
  /**
   * Add the headers with given map where key is the name of the header, value is the value of the header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier#add
   */
  readonly add?: { [key: string]: string };

  /**
   * Remove headers (matching by header names) specified in the list.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier#remove
   */
  readonly remove?: string[];

  /**
   * Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier(obj: NetworkServicesHttpRouteSpecRulesActionResponseHeaderModifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the retry policy associated with this route.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionRetryPolicy
 */
export interface NetworkServicesHttpRouteSpecRulesActionRetryPolicy {
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not specified, default to 1.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRetryPolicy#numRetries
   */
  readonly numRetries?: number;

  /**
   * Specifies a non-zero timeout per retry attempt.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Specifies one or more conditions when this retry policy applies. Valid values are: 5xx: Proxy will attempt a retry if the destination service responds with any 5xx response code, of if the destination service does not respond at all, example: disconnect, reset, read timeout, connection failure and refused streams. gateway-error: Similar to 5xx, but only applies to response codes 502, 503, 504. reset: Proxy will attempt a retry if the destination service does not respond at all (disconnect/reset/read timeout) connect-failure: Proxy will retry on failures connecting to destination for example due to connection timeouts. retriable-4xx: Proxy will retry fro retriable 4xx response codes. Currently the only retriable error supported is 409. refused-stream: Proxy will retry if the destination resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRetryPolicy#retryConditions
   */
  readonly retryConditions?: string[];

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRetryPolicy(obj: NetworkServicesHttpRouteSpecRulesActionRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numRetries': obj.numRetries,
    'perTryTimeout': obj.perTryTimeout,
    'retryConditions': obj.retryConditions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for rewrite URL before forwarding requests to the destination.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionUrlRewrite
 */
export interface NetworkServicesHttpRouteSpecRulesActionUrlRewrite {
  /**
   * Prior to forwarding the request to the selected destination, the requests host header is replaced by this value.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionUrlRewrite#hostRewrite
   */
  readonly hostRewrite?: string;

  /**
   * Prior to forwarding the request to the selected destination, the matching portion of the requests path is replaced by this value.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionUrlRewrite#pathPrefixRewrite
   */
  readonly pathPrefixRewrite?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionUrlRewrite(obj: NetworkServicesHttpRouteSpecRulesActionUrlRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostRewrite': obj.hostRewrite,
    'pathPrefixRewrite': obj.pathPrefixRewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders
 */
export interface NetworkServicesHttpRouteSpecRulesMatchesHeaders {
  /**
   * The value of the header should match exactly the content of exact_match.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#exactMatch
   */
  readonly exactMatch?: string;

  /**
   * The name of the HTTP header to match against.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#header
   */
  readonly header?: string;

  /**
   * If specified, the match result will be inverted before checking. Default value is set to false.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#invertMatch
   */
  readonly invertMatch?: boolean;

  /**
   * The value of the header must start with the contents of prefix_match.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#prefixMatch
   */
  readonly prefixMatch?: string;

  /**
   * A header with header_name must exist. The match takes place whether or not the header has a value.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#presentMatch
   */
  readonly presentMatch?: boolean;

  /**
   * If specified, the rule will match if the request header value is within the range.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#rangeMatch
   */
  readonly rangeMatch?: NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch;

  /**
   * The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#regexMatch
   */
  readonly regexMatch?: string;

  /**
   * The value of the header must end with the contents of suffix_match.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeaders#suffixMatch
   */
  readonly suffixMatch?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesMatchesHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesMatchesHeaders(obj: NetworkServicesHttpRouteSpecRulesMatchesHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exactMatch': obj.exactMatch,
    'header': obj.header,
    'invertMatch': obj.invertMatch,
    'prefixMatch': obj.prefixMatch,
    'presentMatch': obj.presentMatch,
    'rangeMatch': toJson_NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch(obj.rangeMatch),
    'regexMatch': obj.regexMatch,
    'suffixMatch': obj.suffixMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesMatchesQueryParameters
 */
export interface NetworkServicesHttpRouteSpecRulesMatchesQueryParameters {
  /**
   * The value of the query parameter must exactly match the contents of exact_match. Only one of exact_match, regex_match, or present_match must be set.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesQueryParameters#exactMatch
   */
  readonly exactMatch?: string;

  /**
   * Specifies that the QueryParameterMatcher matches if request contains query parameter, irrespective of whether the parameter has a value or not. Only one of exact_match, regex_match, or present_match must be set.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesQueryParameters#presentMatch
   */
  readonly presentMatch?: boolean;

  /**
   * The name of the query parameter to match.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesQueryParameters#queryParameter
   */
  readonly queryParameter?: string;

  /**
   * The value of the query parameter must match the regular expression specified by regex_match. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax Only one of exact_match, regex_match, or present_match must be set.
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesQueryParameters#regexMatch
   */
  readonly regexMatch?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesMatchesQueryParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesMatchesQueryParameters(obj: NetworkServicesHttpRouteSpecRulesMatchesQueryParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exactMatch': obj.exactMatch,
    'presentMatch': obj.presentMatch,
    'queryParameter': obj.queryParameter,
    'regexMatch': obj.regexMatch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef
 */
export interface NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef {
  /**
   * The URL of a BackendService to route traffic to.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeBackendService` resource (format: `projects/{{project}}/global/backendServices/{{name}}`).
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef(obj: NetworkServicesHttpRouteSpecRulesActionDestinationsServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for aborting to client requests.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort
 */
export interface NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort {
  /**
   * The HTTP status code used to abort the request. The value must be between 200 and 599 inclusive.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * The percentage of traffic which will be aborted. The value must be between [0, 100]
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort(obj: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpStatus': obj.httpStatus,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for injecting delay to client requests.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay
 */
export interface NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay {
  /**
   * Specify a fixed delay before forwarding the request.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * The percentage of traffic on which delay will be injected. The value must be between [0, 100]
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay(obj: NetworkServicesHttpRouteSpecRulesActionFaultInjectionPolicyDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fixedDelay': obj.fixedDelay,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The destination the requests will be mirrored to. The weight of the destination will be ignored.
 *
 * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination
 */
export interface NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination {
  /**
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination#serviceRef
   */
  readonly serviceRef?: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef;

  /**
   * Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination(obj: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef(obj.serviceRef),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the rule will match if the request header value is within the range.
 *
 * @schema NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch
 */
export interface NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch {
  /**
   * End of the range (exclusive)
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch#end
   */
  readonly end?: number;

  /**
   * Start of the range (inclusive)
   *
   * @schema NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch#start
   */
  readonly start?: number;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch(obj: NetworkServicesHttpRouteSpecRulesMatchesHeadersRangeMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'end': obj.end,
    'start': obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef
 */
export interface NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef {
  /**
   * The URL of a BackendService to route traffic to.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeBackendService` resource (format: `projects/{{project}}/global/backendServices/{{name}}`).
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef(obj: NetworkServicesHttpRouteSpecRulesActionRequestMirrorPolicyDestinationServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesMesh
 */
export class NetworkServicesMesh extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesMesh"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesMesh',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesMesh".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesMeshProps): any {
    return {
      ...NetworkServicesMesh.GVK,
      ...toJson_NetworkServicesMeshProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesMesh" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesMeshProps) {
    super(scope, id, {
      ...NetworkServicesMesh.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesMesh.GVK,
      ...toJson_NetworkServicesMeshProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesMesh
 */
export interface NetworkServicesMeshProps {
  /**
   * @schema NetworkServicesMesh#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesMesh#spec
   */
  readonly spec: NetworkServicesMeshSpec;

}

/**
 * Converts an object of type 'NetworkServicesMeshProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesMeshProps(obj: NetworkServicesMeshProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesMeshSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesMeshSpec
 */
export interface NetworkServicesMeshSpec {
  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesMeshSpec#description
   */
  readonly description?: string;

  /**
   * Optional. If set to a valid TCP port (1-65535), instructs the SIDECAR proxy to listen on the specified port of localhost (127.0.0.1) address. The SIDECAR proxy will expect all traffic to be redirected to this port regardless of its actual ip:port destination. If unset, a port '15001' is used as the interception port. This field is only valid if the type of Mesh is SIDECAR.
   *
   * @schema NetworkServicesMeshSpec#interceptionPort
   */
  readonly interceptionPort?: number;

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesMeshSpec#location
   */
  readonly location: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesMeshSpec#projectRef
   */
  readonly projectRef: NetworkServicesMeshSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesMeshSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'NetworkServicesMeshSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesMeshSpec(obj: NetworkServicesMeshSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'interceptionPort': obj.interceptionPort,
    'location': obj.location,
    'projectRef': toJson_NetworkServicesMeshSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesMeshSpecProjectRef
 */
export interface NetworkServicesMeshSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesMeshSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesMeshSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesMeshSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesMeshSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesMeshSpecProjectRef(obj: NetworkServicesMeshSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesTCPRoute
 */
export class NetworkServicesTcpRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesTCPRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesTCPRoute',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesTCPRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesTcpRouteProps): any {
    return {
      ...NetworkServicesTcpRoute.GVK,
      ...toJson_NetworkServicesTcpRouteProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesTCPRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesTcpRouteProps) {
    super(scope, id, {
      ...NetworkServicesTcpRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesTcpRoute.GVK,
      ...toJson_NetworkServicesTcpRouteProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesTCPRoute
 */
export interface NetworkServicesTcpRouteProps {
  /**
   * @schema NetworkServicesTCPRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesTCPRoute#spec
   */
  readonly spec: NetworkServicesTcpRouteSpec;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteProps(obj: NetworkServicesTcpRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesTcpRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpec
 */
export interface NetworkServicesTcpRouteSpec {
  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesTcpRouteSpec#description
   */
  readonly description?: string;

  /**
   * @schema NetworkServicesTcpRouteSpec#gateways
   */
  readonly gateways?: NetworkServicesTcpRouteSpecGateways[];

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesTcpRouteSpec#location
   */
  readonly location: string;

  /**
   * @schema NetworkServicesTcpRouteSpec#meshes
   */
  readonly meshes?: NetworkServicesTcpRouteSpecMeshes[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesTcpRouteSpec#projectRef
   */
  readonly projectRef: NetworkServicesTcpRouteSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesTcpRouteSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Required. Rules that define how traffic is routed and handled. At least one RouteRule must be supplied. If there are multiple rules then the action taken will be the first rule to match.
   *
   * @schema NetworkServicesTcpRouteSpec#rules
   */
  readonly rules: NetworkServicesTcpRouteSpecRules[];

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpec(obj: NetworkServicesTcpRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'gateways': obj.gateways?.map(y => toJson_NetworkServicesTcpRouteSpecGateways(y)),
    'location': obj.location,
    'meshes': obj.meshes?.map(y => toJson_NetworkServicesTcpRouteSpecMeshes(y)),
    'projectRef': toJson_NetworkServicesTcpRouteSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rules': obj.rules?.map(y => toJson_NetworkServicesTcpRouteSpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecGateways
 */
export interface NetworkServicesTcpRouteSpecGateways {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesGateway` resource.
   *
   * @schema NetworkServicesTcpRouteSpecGateways#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTcpRouteSpecGateways#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTcpRouteSpecGateways#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecGateways' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecGateways(obj: NetworkServicesTcpRouteSpecGateways | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecMeshes
 */
export interface NetworkServicesTcpRouteSpecMeshes {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesMesh` resource.
   *
   * @schema NetworkServicesTcpRouteSpecMeshes#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTcpRouteSpecMeshes#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTcpRouteSpecMeshes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecMeshes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecMeshes(obj: NetworkServicesTcpRouteSpecMeshes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesTcpRouteSpecProjectRef
 */
export interface NetworkServicesTcpRouteSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesTcpRouteSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTcpRouteSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTcpRouteSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecProjectRef(obj: NetworkServicesTcpRouteSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecRules
 */
export interface NetworkServicesTcpRouteSpecRules {
  /**
   * Required. The detailed rule defining how to route matched traffic.
   *
   * @schema NetworkServicesTcpRouteSpecRules#action
   */
  readonly action: NetworkServicesTcpRouteSpecRulesAction;

  /**
   * Optional. RouteMatch defines the predicate used to match requests to a given action. Multiple match types are “OR”ed for evaluation. If no routeMatch field is specified, this rule will unconditionally match traffic.
   *
   * @schema NetworkServicesTcpRouteSpecRules#matches
   */
  readonly matches?: NetworkServicesTcpRouteSpecRulesMatches[];

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecRules(obj: NetworkServicesTcpRouteSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_NetworkServicesTcpRouteSpecRulesAction(obj.action),
    'matches': obj.matches?.map(y => toJson_NetworkServicesTcpRouteSpecRulesMatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The detailed rule defining how to route matched traffic.
 *
 * @schema NetworkServicesTcpRouteSpecRulesAction
 */
export interface NetworkServicesTcpRouteSpecRulesAction {
  /**
   * Optional. The destination services to which traffic should be forwarded. At least one destination service is required.
   *
   * @schema NetworkServicesTcpRouteSpecRulesAction#destinations
   */
  readonly destinations?: NetworkServicesTcpRouteSpecRulesActionDestinations[];

  /**
   * Optional. If true, Router will use the destination IP and port of the original connection as the destination of the request. Default is false.
   *
   * @default false.
   * @schema NetworkServicesTcpRouteSpecRulesAction#originalDestination
   */
  readonly originalDestination?: boolean;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecRulesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecRulesAction(obj: NetworkServicesTcpRouteSpecRulesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinations': obj.destinations?.map(y => toJson_NetworkServicesTcpRouteSpecRulesActionDestinations(y)),
    'originalDestination': obj.originalDestination,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecRulesMatches
 */
export interface NetworkServicesTcpRouteSpecRulesMatches {
  /**
   * Required. Must be specified in the CIDR range format. A CIDR range consists of an IP Address and a prefix length to construct the subnet mask. By default, the prefix length is 32 (i.e. matches a single IP address). Only IPV4 addresses are supported. Examples: “10.0.0.1” - matches against this exact IP address. “10.0.0.0/8" - matches against any IP address within the 10.0.0.0 subnet and 255.255.255.0 mask. "0.0.0.0/0" - matches against any IP address'.
   *
   * @schema NetworkServicesTcpRouteSpecRulesMatches#address
   */
  readonly address: string;

  /**
   * Required. Specifies the destination port to match against.
   *
   * @schema NetworkServicesTcpRouteSpecRulesMatches#port
   */
  readonly port: string;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecRulesMatches(obj: NetworkServicesTcpRouteSpecRulesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecRulesActionDestinations
 */
export interface NetworkServicesTcpRouteSpecRulesActionDestinations {
  /**
   * @schema NetworkServicesTcpRouteSpecRulesActionDestinations#serviceRef
   */
  readonly serviceRef: NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef;

  /**
   * Optional. Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
   *
   * @schema NetworkServicesTcpRouteSpecRulesActionDestinations#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecRulesActionDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecRulesActionDestinations(obj: NetworkServicesTcpRouteSpecRulesActionDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef(obj.serviceRef),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef
 */
export interface NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef {
  /**
   * Required. The URL of a BackendService to route traffic to.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeBackendService` resource (format: `projects/{{project}}/global/backendServices/{{name}}`).
   *
   * @schema NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef(obj: NetworkServicesTcpRouteSpecRulesActionDestinationsServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema NetworkServicesTLSRoute
 */
export class NetworkServicesTlsRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkServicesTLSRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkservices.cnrm.cloud.google.com/v1beta1',
    kind: 'NetworkServicesTLSRoute',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkServicesTLSRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkServicesTlsRouteProps): any {
    return {
      ...NetworkServicesTlsRoute.GVK,
      ...toJson_NetworkServicesTlsRouteProps(props),
    };
  }

  /**
   * Defines a "NetworkServicesTLSRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkServicesTlsRouteProps) {
    super(scope, id, {
      ...NetworkServicesTlsRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkServicesTlsRoute.GVK,
      ...toJson_NetworkServicesTlsRouteProps(resolved),
    };
  }
}

/**
 * @schema NetworkServicesTLSRoute
 */
export interface NetworkServicesTlsRouteProps {
  /**
   * @schema NetworkServicesTLSRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema NetworkServicesTLSRoute#spec
   */
  readonly spec: NetworkServicesTlsRouteSpec;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteProps(obj: NetworkServicesTlsRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkServicesTlsRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpec
 */
export interface NetworkServicesTlsRouteSpec {
  /**
   * Optional. A free-text description of the resource. Max length 1024 characters.
   *
   * @schema NetworkServicesTlsRouteSpec#description
   */
  readonly description?: string;

  /**
   * @schema NetworkServicesTlsRouteSpec#gateways
   */
  readonly gateways?: NetworkServicesTlsRouteSpecGateways[];

  /**
   * Immutable. The location for the resource
   *
   * @schema NetworkServicesTlsRouteSpec#location
   */
  readonly location: string;

  /**
   * @schema NetworkServicesTlsRouteSpec#meshes
   */
  readonly meshes?: NetworkServicesTlsRouteSpecMeshes[];

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema NetworkServicesTlsRouteSpec#projectRef
   */
  readonly projectRef: NetworkServicesTlsRouteSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema NetworkServicesTlsRouteSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Required. Rules that define how traffic is routed and handled. At least one RouteRule must be supplied. If there are multiple rules then the action taken will be the first rule to match.
   *
   * @schema NetworkServicesTlsRouteSpec#rules
   */
  readonly rules: NetworkServicesTlsRouteSpecRules[];

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpec(obj: NetworkServicesTlsRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'gateways': obj.gateways?.map(y => toJson_NetworkServicesTlsRouteSpecGateways(y)),
    'location': obj.location,
    'meshes': obj.meshes?.map(y => toJson_NetworkServicesTlsRouteSpecMeshes(y)),
    'projectRef': toJson_NetworkServicesTlsRouteSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rules': obj.rules?.map(y => toJson_NetworkServicesTlsRouteSpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecGateways
 */
export interface NetworkServicesTlsRouteSpecGateways {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesGateway` resource.
   *
   * @schema NetworkServicesTlsRouteSpecGateways#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTlsRouteSpecGateways#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTlsRouteSpecGateways#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecGateways' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecGateways(obj: NetworkServicesTlsRouteSpecGateways | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecMeshes
 */
export interface NetworkServicesTlsRouteSpecMeshes {
  /**
   * Allowed value: The `selfLink` field of a `NetworkServicesMesh` resource.
   *
   * @schema NetworkServicesTlsRouteSpecMeshes#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTlsRouteSpecMeshes#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTlsRouteSpecMeshes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecMeshes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecMeshes(obj: NetworkServicesTlsRouteSpecMeshes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema NetworkServicesTlsRouteSpecProjectRef
 */
export interface NetworkServicesTlsRouteSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema NetworkServicesTlsRouteSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTlsRouteSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTlsRouteSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecProjectRef(obj: NetworkServicesTlsRouteSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecRules
 */
export interface NetworkServicesTlsRouteSpecRules {
  /**
   * Required. The detailed rule defining how to route matched traffic.
   *
   * @schema NetworkServicesTlsRouteSpecRules#action
   */
  readonly action: NetworkServicesTlsRouteSpecRulesAction;

  /**
   * Required. RouteMatch defines the predicate used to match requests to a given action. Multiple match types are "OR"ed for evaluation.
   *
   * @schema NetworkServicesTlsRouteSpecRules#matches
   */
  readonly matches: NetworkServicesTlsRouteSpecRulesMatches[];

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecRules(obj: NetworkServicesTlsRouteSpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_NetworkServicesTlsRouteSpecRulesAction(obj.action),
    'matches': obj.matches?.map(y => toJson_NetworkServicesTlsRouteSpecRulesMatches(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. The detailed rule defining how to route matched traffic.
 *
 * @schema NetworkServicesTlsRouteSpecRulesAction
 */
export interface NetworkServicesTlsRouteSpecRulesAction {
  /**
   * Required. The destination services to which traffic should be forwarded. At least one destination service is required.
   *
   * @schema NetworkServicesTlsRouteSpecRulesAction#destinations
   */
  readonly destinations: NetworkServicesTlsRouteSpecRulesActionDestinations[];

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecRulesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecRulesAction(obj: NetworkServicesTlsRouteSpecRulesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinations': obj.destinations?.map(y => toJson_NetworkServicesTlsRouteSpecRulesActionDestinations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecRulesMatches
 */
export interface NetworkServicesTlsRouteSpecRulesMatches {
  /**
   * Optional. ALPN (Application-Layer Protocol Negotiation) to match against. Examples: "http/1.1", "h2". At least one of sni_host and alpn is required. Up to 5 alpns across all matches can be set.
   *
   * @schema NetworkServicesTlsRouteSpecRulesMatches#alpn
   */
  readonly alpn?: string[];

  /**
   * Optional. SNI (server name indicator) to match against. SNI will be matched against all wildcard domains, i.e. www.example.com will be first matched against www.example.com, then *.example.com, then *.com. Partial wildcards are not supported, and values like *w.example.com are invalid. At least one of sni_host and alpn is required. Up to 5 sni hosts across all matches can be set.
   *
   * @schema NetworkServicesTlsRouteSpecRulesMatches#sniHost
   */
  readonly sniHost?: string[];

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecRulesMatches(obj: NetworkServicesTlsRouteSpecRulesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpn': obj.alpn?.map(y => y),
    'sniHost': obj.sniHost?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecRulesActionDestinations
 */
export interface NetworkServicesTlsRouteSpecRulesActionDestinations {
  /**
   * @schema NetworkServicesTlsRouteSpecRulesActionDestinations#serviceRef
   */
  readonly serviceRef: NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef;

  /**
   * Optional. Specifies the proportion of requests forwareded to the backend referenced by the service_name field. This is computed as: weight/Sum(weights in destinations) Weights in all destinations does not need to sum up to 100.
   *
   * @schema NetworkServicesTlsRouteSpecRulesActionDestinations#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecRulesActionDestinations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecRulesActionDestinations(obj: NetworkServicesTlsRouteSpecRulesActionDestinations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceRef': toJson_NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef(obj.serviceRef),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef
 */
export interface NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef {
  /**
   * Required. The URL of a BackendService to route traffic to.
   *
   * Allowed value: The Google Cloud resource name of a `ComputeBackendService` resource (format: `projects/{{project}}/global/backendServices/{{name}}`).
   *
   * @schema NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef(obj: NetworkServicesTlsRouteSpecRulesActionDestinationsServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

