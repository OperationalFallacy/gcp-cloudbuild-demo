// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema MonitoringAlertPolicy
 */
export class MonitoringAlertPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringAlertPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringAlertPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringAlertPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringAlertPolicyProps): any {
    return {
      ...MonitoringAlertPolicy.GVK,
      ...toJson_MonitoringAlertPolicyProps(props),
    };
  }

  /**
   * Defines a "MonitoringAlertPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringAlertPolicyProps) {
    super(scope, id, {
      ...MonitoringAlertPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringAlertPolicy.GVK,
      ...toJson_MonitoringAlertPolicyProps(resolved),
    };
  }
}

/**
 * @schema MonitoringAlertPolicy
 */
export interface MonitoringAlertPolicyProps {
  /**
   * @schema MonitoringAlertPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringAlertPolicy#spec
   */
  readonly spec: MonitoringAlertPolicySpec;

}

/**
 * Converts an object of type 'MonitoringAlertPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicyProps(obj: MonitoringAlertPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringAlertPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpec
 */
export interface MonitoringAlertPolicySpec {
  /**
   * Control over how this alert policy's notification channels are notified.
   *
   * @schema MonitoringAlertPolicySpec#alertStrategy
   */
  readonly alertStrategy?: MonitoringAlertPolicySpecAlertStrategy;

  /**
   * How to combine the results of multiple conditions to
   * determine if an incident should be opened. Possible values: ["AND", "OR", "AND_WITH_MATCHING_RESOURCE"].
   *
   * @schema MonitoringAlertPolicySpec#combiner
   */
  readonly combiner: string;

  /**
   * A list of conditions for the policy. The conditions are combined by
   * AND or OR according to the combiner field. If the combined conditions
   * evaluate to true, then an incident is created. A policy can have from
   * one to six conditions.
   *
   * @schema MonitoringAlertPolicySpec#conditions
   */
  readonly conditions: MonitoringAlertPolicySpecConditions[];

  /**
   * A short name or phrase used to identify the policy in
   * dashboards, notifications, and incidents. To avoid confusion, don't use
   * the same display name for multiple policies in the same project. The
   * name is limited to 512 Unicode characters.
   *
   * @schema MonitoringAlertPolicySpec#displayName
   */
  readonly displayName: string;

  /**
   * Documentation that is included with notifications and incidents related
   * to this policy. Best practice is for the documentation to include information
   * to help responders understand, mitigate, escalate, and correct the underlying
   * problems detected by the alerting policy. Notification channels that have
   * limited capacity might not show this documentation.
   *
   * @schema MonitoringAlertPolicySpec#documentation
   */
  readonly documentation?: MonitoringAlertPolicySpecDocumentation;

  /**
   * Whether or not the policy is enabled. The default is true.
   *
   * @schema MonitoringAlertPolicySpec#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema MonitoringAlertPolicySpec#notificationChannels
   */
  readonly notificationChannels?: MonitoringAlertPolicySpecNotificationChannels[];

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema MonitoringAlertPolicySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpec(obj: MonitoringAlertPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alertStrategy': toJson_MonitoringAlertPolicySpecAlertStrategy(obj.alertStrategy),
    'combiner': obj.combiner,
    'conditions': obj.conditions?.map(y => toJson_MonitoringAlertPolicySpecConditions(y)),
    'displayName': obj.displayName,
    'documentation': toJson_MonitoringAlertPolicySpecDocumentation(obj.documentation),
    'enabled': obj.enabled,
    'notificationChannels': obj.notificationChannels?.map(y => toJson_MonitoringAlertPolicySpecNotificationChannels(y)),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Control over how this alert policy's notification channels are notified.
 *
 * @schema MonitoringAlertPolicySpecAlertStrategy
 */
export interface MonitoringAlertPolicySpecAlertStrategy {
  /**
   * If an alert policy that was active has no data for this long, any open incidents will close.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategy#autoClose
   */
  readonly autoClose?: string;

  /**
   * Control over how the notification channels in 'notification_channels'
   * are notified when this alert fires, on a per-channel basis.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategy#notificationChannelStrategy
   */
  readonly notificationChannelStrategy?: MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy[];

  /**
   * Required for alert policies with a LogMatch condition.
   * This limit is not implemented for alert policies that are not log-based.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategy#notificationRateLimit
   */
  readonly notificationRateLimit?: MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecAlertStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecAlertStrategy(obj: MonitoringAlertPolicySpecAlertStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoClose': obj.autoClose,
    'notificationChannelStrategy': obj.notificationChannelStrategy?.map(y => toJson_MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy(y)),
    'notificationRateLimit': toJson_MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit(obj.notificationRateLimit),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpecConditions
 */
export interface MonitoringAlertPolicySpecConditions {
  /**
   * A condition that checks that a time series
   * continues to receive new data points.
   *
   * @schema MonitoringAlertPolicySpecConditions#conditionAbsent
   */
  readonly conditionAbsent?: MonitoringAlertPolicySpecConditionsConditionAbsent;

  /**
   * A condition that checks for log messages matching given constraints.
   * If set, no other conditions can be present.
   *
   * @schema MonitoringAlertPolicySpecConditions#conditionMatchedLog
   */
  readonly conditionMatchedLog?: MonitoringAlertPolicySpecConditionsConditionMatchedLog;

  /**
   * A Monitoring Query Language query that outputs a boolean stream.
   *
   * @schema MonitoringAlertPolicySpecConditions#conditionMonitoringQueryLanguage
   */
  readonly conditionMonitoringQueryLanguage?: MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage;

  /**
   * A condition that compares a time series against a
   * threshold.
   *
   * @schema MonitoringAlertPolicySpecConditions#conditionThreshold
   */
  readonly conditionThreshold?: MonitoringAlertPolicySpecConditionsConditionThreshold;

  /**
   * A short name or phrase used to identify the
   * condition in dashboards, notifications, and
   * incidents. To avoid confusion, don't use the same
   * display name for multiple conditions in the same
   * policy.
   *
   * @schema MonitoringAlertPolicySpecConditions#displayName
   */
  readonly displayName: string;

  /**
   * The unique resource name for this condition.
   * Its syntax is:
   * projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
   * [CONDITION_ID] is assigned by Stackdriver Monitoring when
   * the condition is created as part of a new or updated alerting
   * policy.
   *
   * @schema MonitoringAlertPolicySpecConditions#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditions(obj: MonitoringAlertPolicySpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionAbsent': toJson_MonitoringAlertPolicySpecConditionsConditionAbsent(obj.conditionAbsent),
    'conditionMatchedLog': toJson_MonitoringAlertPolicySpecConditionsConditionMatchedLog(obj.conditionMatchedLog),
    'conditionMonitoringQueryLanguage': toJson_MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage(obj.conditionMonitoringQueryLanguage),
    'conditionThreshold': toJson_MonitoringAlertPolicySpecConditionsConditionThreshold(obj.conditionThreshold),
    'displayName': obj.displayName,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Documentation that is included with notifications and incidents related
 * to this policy. Best practice is for the documentation to include information
 * to help responders understand, mitigate, escalate, and correct the underlying
 * problems detected by the alerting policy. Notification channels that have
 * limited capacity might not show this documentation.
 *
 * @schema MonitoringAlertPolicySpecDocumentation
 */
export interface MonitoringAlertPolicySpecDocumentation {
  /**
   * The text of the documentation, interpreted according to mimeType.
   * The content may not exceed 8,192 Unicode characters and may not
   * exceed more than 10,240 bytes when encoded in UTF-8 format,
   * whichever is smaller.
   *
   * @schema MonitoringAlertPolicySpecDocumentation#content
   */
  readonly content?: string;

  /**
   * The format of the content field. Presently, only the value
   * "text/markdown" is supported.
   *
   * @schema MonitoringAlertPolicySpecDocumentation#mimeType
   */
  readonly mimeType?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecDocumentation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecDocumentation(obj: MonitoringAlertPolicySpecDocumentation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'mimeType': obj.mimeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Identifies the notification channels to which notifications should be sent when incidents are opened or closed or when new violations occur on an already opened incident.
 *
 * @schema MonitoringAlertPolicySpecNotificationChannels
 */
export interface MonitoringAlertPolicySpecNotificationChannels {
  /**
   * Allowed value: The `name` field of a `MonitoringNotificationChannel` resource.
   *
   * @schema MonitoringAlertPolicySpecNotificationChannels#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringAlertPolicySpecNotificationChannels#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringAlertPolicySpecNotificationChannels#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecNotificationChannels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecNotificationChannels(obj: MonitoringAlertPolicySpecNotificationChannels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy
 */
export interface MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy {
  /**
   * The notification channels that these settings apply to. Each of these
   * correspond to the name field in one of the NotificationChannel objects
   * referenced in the notification_channels field of this AlertPolicy. The format is
   * 'projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]'.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy#notificationChannelNames
   */
  readonly notificationChannelNames?: string[];

  /**
   * The frequency at which to send reminder notifications for open incidents.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy#renotifyInterval
   */
  readonly renotifyInterval?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy(obj: MonitoringAlertPolicySpecAlertStrategyNotificationChannelStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notificationChannelNames': obj.notificationChannelNames?.map(y => y),
    'renotifyInterval': obj.renotifyInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required for alert policies with a LogMatch condition.
 * This limit is not implemented for alert policies that are not log-based.
 *
 * @schema MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit
 */
export interface MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit {
  /**
   * Not more than one notification per period.
   *
   * @schema MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit(obj: MonitoringAlertPolicySpecAlertStrategyNotificationRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A condition that checks that a time series
 * continues to receive new data points.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionAbsent
 */
export interface MonitoringAlertPolicySpecConditionsConditionAbsent {
  /**
   * Specifies the alignment of data points in
   * individual time series as well as how to
   * combine the retrieved time series together
   * (such as when aggregating multiple streams
   * on each resource to a single stream for each
   * resource or when aggregating streams across
   * all members of a group of resources).
   * Multiple aggregations are applied in the
   * order specified.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsent#aggregations
   */
  readonly aggregations?: MonitoringAlertPolicySpecConditionsConditionAbsentAggregations[];

  /**
   * The amount of time that a time series must
   * fail to report new data to be considered
   * failing. Currently, only values that are a
   * multiple of a minute--e.g. 60s, 120s, or 300s
   * --are supported.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsent#duration
   */
  readonly duration: string;

  /**
   * A filter that identifies which time series
   * should be compared with the threshold.The
   * filter is similar to the one that is
   * specified in the
   * MetricService.ListTimeSeries request (that
   * call is useful to verify the time series
   * that will be retrieved / processed) and must
   * specify the metric type and optionally may
   * contain restrictions on resource type,
   * resource labels, and metric labels. This
   * field may not exceed 2048 Unicode characters
   * in length.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsent#filter
   */
  readonly filter?: string;

  /**
   * The number/percent of time series for which
   * the comparison must hold in order for the
   * condition to trigger. If unspecified, then
   * the condition will trigger if the comparison
   * is true for any of the time series that have
   * been identified by filter and aggregations.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsent#trigger
   */
  readonly trigger?: MonitoringAlertPolicySpecConditionsConditionAbsentTrigger;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionAbsent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionAbsent(obj: MonitoringAlertPolicySpecConditionsConditionAbsent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregations': obj.aggregations?.map(y => toJson_MonitoringAlertPolicySpecConditionsConditionAbsentAggregations(y)),
    'duration': obj.duration,
    'filter': obj.filter,
    'trigger': toJson_MonitoringAlertPolicySpecConditionsConditionAbsentTrigger(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A condition that checks for log messages matching given constraints.
 * If set, no other conditions can be present.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionMatchedLog
 */
export interface MonitoringAlertPolicySpecConditionsConditionMatchedLog {
  /**
   * A logs-based filter.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMatchedLog#filter
   */
  readonly filter: string;

  /**
   * A map from a label key to an extractor expression, which is used to
   * extract the value for this label key. Each entry in this map is
   * a specification for how data should be extracted from log entries that
   * match filter. Each combination of extracted values is treated as
   * a separate rule for the purposes of triggering notifications.
   * Label keys and corresponding values can be used in notifications
   * generated by this condition.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMatchedLog#labelExtractors
   */
  readonly labelExtractors?: { [key: string]: string };

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionMatchedLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionMatchedLog(obj: MonitoringAlertPolicySpecConditionsConditionMatchedLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'labelExtractors': ((obj.labelExtractors) === undefined) ? undefined : (Object.entries(obj.labelExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Monitoring Query Language query that outputs a boolean stream.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage
 */
export interface MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage {
  /**
   * The amount of time that a time series must
   * violate the threshold to be considered
   * failing. Currently, only values that are a
   * multiple of a minute--e.g., 0, 60, 120, or
   * 300 seconds--are supported. If an invalid
   * value is given, an error will be returned.
   * When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying
   * time series data (which may also be affected
   * by any alignments specified in the
   * aggregations field); a good duration is long
   * enough so that a single outlier does not
   * generate spurious alerts, but short enough
   * that unhealthy states are detected and
   * alerted on quickly.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage#duration
   */
  readonly duration: string;

  /**
   * A condition control that determines how
   * metric-threshold conditions are evaluated when
   * data stops arriving. Possible values: ["EVALUATION_MISSING_DATA_INACTIVE", "EVALUATION_MISSING_DATA_ACTIVE", "EVALUATION_MISSING_DATA_NO_OP"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage#evaluationMissingData
   */
  readonly evaluationMissingData?: string;

  /**
   * Monitoring Query Language query that outputs a boolean stream.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage#query
   */
  readonly query: string;

  /**
   * The number/percent of time series for which
   * the comparison must hold in order for the
   * condition to trigger. If unspecified, then
   * the condition will trigger if the comparison
   * is true for any of the time series that have
   * been identified by filter and aggregations,
   * or by the ratio, if denominator_filter and
   * denominator_aggregations are specified.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage#trigger
   */
  readonly trigger?: MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage(obj: MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'evaluationMissingData': obj.evaluationMissingData,
    'query': obj.query,
    'trigger': toJson_MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A condition that compares a time series against a
 * threshold.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionThreshold
 */
export interface MonitoringAlertPolicySpecConditionsConditionThreshold {
  /**
   * Specifies the alignment of data points in
   * individual time series as well as how to
   * combine the retrieved time series together
   * (such as when aggregating multiple streams
   * on each resource to a single stream for each
   * resource or when aggregating streams across
   * all members of a group of resources).
   * Multiple aggregations are applied in the
   * order specified.This field is similar to the
   * one in the MetricService.ListTimeSeries
   * request. It is advisable to use the
   * ListTimeSeries method when debugging this
   * field.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#aggregations
   */
  readonly aggregations?: MonitoringAlertPolicySpecConditionsConditionThresholdAggregations[];

  /**
   * The comparison to apply between the time
   * series (indicated by filter and aggregation)
   * and the threshold (indicated by
   * threshold_value). The comparison is applied
   * on each time series, with the time series on
   * the left-hand side and the threshold on the
   * right-hand side. Only COMPARISON_LT and
   * COMPARISON_GT are supported currently. Possible values: ["COMPARISON_GT", "COMPARISON_GE", "COMPARISON_LT", "COMPARISON_LE", "COMPARISON_EQ", "COMPARISON_NE"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#comparison
   */
  readonly comparison: string;

  /**
   * Specifies the alignment of data points in
   * individual time series selected by
   * denominatorFilter as well as how to combine
   * the retrieved time series together (such as
   * when aggregating multiple streams on each
   * resource to a single stream for each
   * resource or when aggregating streams across
   * all members of a group of resources).When
   * computing ratios, the aggregations and
   * denominator_aggregations fields must use the
   * same alignment period and produce time
   * series that have the same periodicity and
   * labels.This field is similar to the one in
   * the MetricService.ListTimeSeries request. It
   * is advisable to use the ListTimeSeries
   * method when debugging this field.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#denominatorAggregations
   */
  readonly denominatorAggregations?: MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations[];

  /**
   * A filter that identifies a time series that
   * should be used as the denominator of a ratio
   * that will be compared with the threshold. If
   * a denominator_filter is specified, the time
   * series specified by the filter field will be
   * used as the numerator.The filter is similar
   * to the one that is specified in the
   * MetricService.ListTimeSeries request (that
   * call is useful to verify the time series
   * that will be retrieved / processed) and must
   * specify the metric type and optionally may
   * contain restrictions on resource type,
   * resource labels, and metric labels. This
   * field may not exceed 2048 Unicode characters
   * in length.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#denominatorFilter
   */
  readonly denominatorFilter?: string;

  /**
   * The amount of time that a time series must
   * violate the threshold to be considered
   * failing. Currently, only values that are a
   * multiple of a minute--e.g., 0, 60, 120, or
   * 300 seconds--are supported. If an invalid
   * value is given, an error will be returned.
   * When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying
   * time series data (which may also be affected
   * by any alignments specified in the
   * aggregations field); a good duration is long
   * enough so that a single outlier does not
   * generate spurious alerts, but short enough
   * that unhealthy states are detected and
   * alerted on quickly.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#duration
   */
  readonly duration: string;

  /**
   * A condition control that determines how
   * metric-threshold conditions are evaluated when
   * data stops arriving. Possible values: ["EVALUATION_MISSING_DATA_INACTIVE", "EVALUATION_MISSING_DATA_ACTIVE", "EVALUATION_MISSING_DATA_NO_OP"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#evaluationMissingData
   */
  readonly evaluationMissingData?: string;

  /**
   * A filter that identifies which time series
   * should be compared with the threshold.The
   * filter is similar to the one that is
   * specified in the
   * MetricService.ListTimeSeries request (that
   * call is useful to verify the time series
   * that will be retrieved / processed) and must
   * specify the metric type and optionally may
   * contain restrictions on resource type,
   * resource labels, and metric labels. This
   * field may not exceed 2048 Unicode characters
   * in length.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#filter
   */
  readonly filter?: string;

  /**
   * When this field is present, the 'MetricThreshold'
   * condition forecasts whether the time series is
   * predicted to violate the threshold within the
   * 'forecastHorizon'. When this field is not set, the
   * 'MetricThreshold' tests the current value of the
   * timeseries against the threshold.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#forecastOptions
   */
  readonly forecastOptions?: MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions;

  /**
   * A value against which to compare the time
   * series.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#thresholdValue
   */
  readonly thresholdValue?: number;

  /**
   * The number/percent of time series for which
   * the comparison must hold in order for the
   * condition to trigger. If unspecified, then
   * the condition will trigger if the comparison
   * is true for any of the time series that have
   * been identified by filter and aggregations,
   * or by the ratio, if denominator_filter and
   * denominator_aggregations are specified.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThreshold#trigger
   */
  readonly trigger?: MonitoringAlertPolicySpecConditionsConditionThresholdTrigger;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionThreshold(obj: MonitoringAlertPolicySpecConditionsConditionThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregations': obj.aggregations?.map(y => toJson_MonitoringAlertPolicySpecConditionsConditionThresholdAggregations(y)),
    'comparison': obj.comparison,
    'denominatorAggregations': obj.denominatorAggregations?.map(y => toJson_MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations(y)),
    'denominatorFilter': obj.denominatorFilter,
    'duration': obj.duration,
    'evaluationMissingData': obj.evaluationMissingData,
    'filter': obj.filter,
    'forecastOptions': toJson_MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions(obj.forecastOptions),
    'thresholdValue': obj.thresholdValue,
    'trigger': toJson_MonitoringAlertPolicySpecConditionsConditionThresholdTrigger(obj.trigger),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpecConditionsConditionAbsentAggregations
 */
export interface MonitoringAlertPolicySpecConditionsConditionAbsentAggregations {
  /**
   * The alignment period for per-time
   * series alignment. If present,
   * alignmentPeriod must be at least
   * 60 seconds. After per-time series
   * alignment, each time series will
   * contain data points only on the
   * period boundaries. If
   * perSeriesAligner is not specified
   * or equals ALIGN_NONE, then this
   * field is ignored. If
   * perSeriesAligner is specified and
   * does not equal ALIGN_NONE, then
   * this field must be defined;
   * otherwise an error is returned.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine
   * time series. Not all reducer
   * functions may be applied to all
   * time series, depending on the
   * metric type and the value type of
   * the original time series.
   * Reduction may change the metric
   * type of value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["REDUCE_NONE", "REDUCE_MEAN", "REDUCE_MIN", "REDUCE_MAX", "REDUCE_SUM", "REDUCE_STDDEV", "REDUCE_COUNT", "REDUCE_COUNT_TRUE", "REDUCE_COUNT_FALSE", "REDUCE_FRACTION_TRUE", "REDUCE_PERCENTILE_99", "REDUCE_PERCENTILE_95", "REDUCE_PERCENTILE_50", "REDUCE_PERCENTILE_05"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when
   * crossSeriesReducer is specified.
   * The groupByFields determine how
   * the time series are partitioned
   * into subsets prior to applying the
   * aggregation function. Each subset
   * contains time series that have the
   * same value for each of the
   * grouping fields. Each individual
   * time series is a member of exactly
   * one subset. The crossSeriesReducer
   * is applied to each subset of time
   * series. It is not possible to
   * reduce across different resource
   * types, so this field implicitly
   * contains resource.type. Fields not
   * specified in groupByFields are
   * aggregated away. If groupByFields
   * is not specified and all the time
   * series have the same resource
   * type, then the time series are
   * aggregated into a single output
   * time series. If crossSeriesReducer
   * is not defined, this field is
   * ignored.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align
   * individual time series. Not all
   * alignment functions may be applied
   * to all time series, depending on
   * the metric type and value type of
   * the original time series.
   * Alignment may change the metric
   * type or the value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["ALIGN_NONE", "ALIGN_DELTA", "ALIGN_RATE", "ALIGN_INTERPOLATE", "ALIGN_NEXT_OLDER", "ALIGN_MIN", "ALIGN_MAX", "ALIGN_MEAN", "ALIGN_COUNT", "ALIGN_SUM", "ALIGN_STDDEV", "ALIGN_COUNT_TRUE", "ALIGN_COUNT_FALSE", "ALIGN_FRACTION_TRUE", "ALIGN_PERCENTILE_99", "ALIGN_PERCENTILE_95", "ALIGN_PERCENTILE_50", "ALIGN_PERCENTILE_05", "ALIGN_PERCENT_CHANGE"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionAbsentAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionAbsentAggregations(obj: MonitoringAlertPolicySpecConditionsConditionAbsentAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The number/percent of time series for which
 * the comparison must hold in order for the
 * condition to trigger. If unspecified, then
 * the condition will trigger if the comparison
 * is true for any of the time series that have
 * been identified by filter and aggregations.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionAbsentTrigger
 */
export interface MonitoringAlertPolicySpecConditionsConditionAbsentTrigger {
  /**
   * The absolute number of time series
   * that must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that
   * must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionAbsentTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionAbsentTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionAbsentTrigger(obj: MonitoringAlertPolicySpecConditionsConditionAbsentTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The number/percent of time series for which
 * the comparison must hold in order for the
 * condition to trigger. If unspecified, then
 * the condition will trigger if the comparison
 * is true for any of the time series that have
 * been identified by filter and aggregations,
 * or by the ratio, if denominator_filter and
 * denominator_aggregations are specified.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger
 */
export interface MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger {
  /**
   * The absolute number of time series
   * that must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that
   * must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger(obj: MonitoringAlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpecConditionsConditionThresholdAggregations
 */
export interface MonitoringAlertPolicySpecConditionsConditionThresholdAggregations {
  /**
   * The alignment period for per-time
   * series alignment. If present,
   * alignmentPeriod must be at least
   * 60 seconds. After per-time series
   * alignment, each time series will
   * contain data points only on the
   * period boundaries. If
   * perSeriesAligner is not specified
   * or equals ALIGN_NONE, then this
   * field is ignored. If
   * perSeriesAligner is specified and
   * does not equal ALIGN_NONE, then
   * this field must be defined;
   * otherwise an error is returned.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine
   * time series. Not all reducer
   * functions may be applied to all
   * time series, depending on the
   * metric type and the value type of
   * the original time series.
   * Reduction may change the metric
   * type of value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["REDUCE_NONE", "REDUCE_MEAN", "REDUCE_MIN", "REDUCE_MAX", "REDUCE_SUM", "REDUCE_STDDEV", "REDUCE_COUNT", "REDUCE_COUNT_TRUE", "REDUCE_COUNT_FALSE", "REDUCE_FRACTION_TRUE", "REDUCE_PERCENTILE_99", "REDUCE_PERCENTILE_95", "REDUCE_PERCENTILE_50", "REDUCE_PERCENTILE_05"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when
   * crossSeriesReducer is specified.
   * The groupByFields determine how
   * the time series are partitioned
   * into subsets prior to applying the
   * aggregation function. Each subset
   * contains time series that have the
   * same value for each of the
   * grouping fields. Each individual
   * time series is a member of exactly
   * one subset. The crossSeriesReducer
   * is applied to each subset of time
   * series. It is not possible to
   * reduce across different resource
   * types, so this field implicitly
   * contains resource.type. Fields not
   * specified in groupByFields are
   * aggregated away. If groupByFields
   * is not specified and all the time
   * series have the same resource
   * type, then the time series are
   * aggregated into a single output
   * time series. If crossSeriesReducer
   * is not defined, this field is
   * ignored.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align
   * individual time series. Not all
   * alignment functions may be applied
   * to all time series, depending on
   * the metric type and value type of
   * the original time series.
   * Alignment may change the metric
   * type or the value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["ALIGN_NONE", "ALIGN_DELTA", "ALIGN_RATE", "ALIGN_INTERPOLATE", "ALIGN_NEXT_OLDER", "ALIGN_MIN", "ALIGN_MAX", "ALIGN_MEAN", "ALIGN_COUNT", "ALIGN_SUM", "ALIGN_STDDEV", "ALIGN_COUNT_TRUE", "ALIGN_COUNT_FALSE", "ALIGN_FRACTION_TRUE", "ALIGN_PERCENTILE_99", "ALIGN_PERCENTILE_95", "ALIGN_PERCENTILE_50", "ALIGN_PERCENTILE_05", "ALIGN_PERCENT_CHANGE"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionThresholdAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionThresholdAggregations(obj: MonitoringAlertPolicySpecConditionsConditionThresholdAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations
 */
export interface MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations {
  /**
   * The alignment period for per-time
   * series alignment. If present,
   * alignmentPeriod must be at least
   * 60 seconds. After per-time series
   * alignment, each time series will
   * contain data points only on the
   * period boundaries. If
   * perSeriesAligner is not specified
   * or equals ALIGN_NONE, then this
   * field is ignored. If
   * perSeriesAligner is specified and
   * does not equal ALIGN_NONE, then
   * this field must be defined;
   * otherwise an error is returned.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine
   * time series. Not all reducer
   * functions may be applied to all
   * time series, depending on the
   * metric type and the value type of
   * the original time series.
   * Reduction may change the metric
   * type of value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["REDUCE_NONE", "REDUCE_MEAN", "REDUCE_MIN", "REDUCE_MAX", "REDUCE_SUM", "REDUCE_STDDEV", "REDUCE_COUNT", "REDUCE_COUNT_TRUE", "REDUCE_COUNT_FALSE", "REDUCE_FRACTION_TRUE", "REDUCE_PERCENTILE_99", "REDUCE_PERCENTILE_95", "REDUCE_PERCENTILE_50", "REDUCE_PERCENTILE_05"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when
   * crossSeriesReducer is specified.
   * The groupByFields determine how
   * the time series are partitioned
   * into subsets prior to applying the
   * aggregation function. Each subset
   * contains time series that have the
   * same value for each of the
   * grouping fields. Each individual
   * time series is a member of exactly
   * one subset. The crossSeriesReducer
   * is applied to each subset of time
   * series. It is not possible to
   * reduce across different resource
   * types, so this field implicitly
   * contains resource.type. Fields not
   * specified in groupByFields are
   * aggregated away. If groupByFields
   * is not specified and all the time
   * series have the same resource
   * type, then the time series are
   * aggregated into a single output
   * time series. If crossSeriesReducer
   * is not defined, this field is
   * ignored.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align
   * individual time series. Not all
   * alignment functions may be applied
   * to all time series, depending on
   * the metric type and value type of
   * the original time series.
   * Alignment may change the metric
   * type or the value type of the time
   * series.Time series data must be
   * aligned in order to perform cross-
   * time series reduction. If
   * crossSeriesReducer is specified,
   * then perSeriesAligner must be
   * specified and not equal ALIGN_NONE
   * and alignmentPeriod must be
   * specified; otherwise, an error is
   * returned. Possible values: ["ALIGN_NONE", "ALIGN_DELTA", "ALIGN_RATE", "ALIGN_INTERPOLATE", "ALIGN_NEXT_OLDER", "ALIGN_MIN", "ALIGN_MAX", "ALIGN_MEAN", "ALIGN_COUNT", "ALIGN_SUM", "ALIGN_STDDEV", "ALIGN_COUNT_TRUE", "ALIGN_COUNT_FALSE", "ALIGN_FRACTION_TRUE", "ALIGN_PERCENTILE_99", "ALIGN_PERCENTILE_95", "ALIGN_PERCENTILE_50", "ALIGN_PERCENTILE_05", "ALIGN_PERCENT_CHANGE"].
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations(obj: MonitoringAlertPolicySpecConditionsConditionThresholdDenominatorAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * When this field is present, the 'MetricThreshold'
 * condition forecasts whether the time series is
 * predicted to violate the threshold within the
 * 'forecastHorizon'. When this field is not set, the
 * 'MetricThreshold' tests the current value of the
 * timeseries against the threshold.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions
 */
export interface MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions {
  /**
   * The length of time into the future to forecast
   * whether a timeseries will violate the threshold.
   * If the predicted value is found to violate the
   * threshold, and the violation is observed in all
   * forecasts made for the Configured 'duration',
   * then the timeseries is considered to be failing.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions#forecastHorizon
   */
  readonly forecastHorizon: string;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions(obj: MonitoringAlertPolicySpecConditionsConditionThresholdForecastOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forecastHorizon': obj.forecastHorizon,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The number/percent of time series for which
 * the comparison must hold in order for the
 * condition to trigger. If unspecified, then
 * the condition will trigger if the comparison
 * is true for any of the time series that have
 * been identified by filter and aggregations,
 * or by the ratio, if denominator_filter and
 * denominator_aggregations are specified.
 *
 * @schema MonitoringAlertPolicySpecConditionsConditionThresholdTrigger
 */
export interface MonitoringAlertPolicySpecConditionsConditionThresholdTrigger {
  /**
   * The absolute number of time series
   * that must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that
   * must fail the predicate for the
   * condition to be triggered.
   *
   * @schema MonitoringAlertPolicySpecConditionsConditionThresholdTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'MonitoringAlertPolicySpecConditionsConditionThresholdTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringAlertPolicySpecConditionsConditionThresholdTrigger(obj: MonitoringAlertPolicySpecConditionsConditionThresholdTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringDashboard
 */
export class MonitoringDashboard extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringDashboard"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringDashboard',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringDashboard".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringDashboardProps): any {
    return {
      ...MonitoringDashboard.GVK,
      ...toJson_MonitoringDashboardProps(props),
    };
  }

  /**
   * Defines a "MonitoringDashboard" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringDashboardProps) {
    super(scope, id, {
      ...MonitoringDashboard.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringDashboard.GVK,
      ...toJson_MonitoringDashboardProps(resolved),
    };
  }
}

/**
 * @schema MonitoringDashboard
 */
export interface MonitoringDashboardProps {
  /**
   * @schema MonitoringDashboard#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringDashboard#spec
   */
  readonly spec: MonitoringDashboardSpec;

}

/**
 * Converts an object of type 'MonitoringDashboardProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardProps(obj: MonitoringDashboardProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringDashboardSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpec
 */
export interface MonitoringDashboardSpec {
  /**
   * The content is divided into equally spaced columns and the widgets are arranged vertically.
   *
   * @schema MonitoringDashboardSpec#columnLayout
   */
  readonly columnLayout?: MonitoringDashboardSpecColumnLayout;

  /**
   * Required. The mutable, human-readable name.
   *
   * @schema MonitoringDashboardSpec#displayName
   */
  readonly displayName: string;

  /**
   * Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
   *
   * @schema MonitoringDashboardSpec#gridLayout
   */
  readonly gridLayout?: MonitoringDashboardSpecGridLayout;

  /**
   * The content is arranged as a grid of tiles, with each content widget occupying one or more tiles.
   *
   * @schema MonitoringDashboardSpec#mosaicLayout
   */
  readonly mosaicLayout?: MonitoringDashboardSpecMosaicLayout;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringDashboardSpec#projectRef
   */
  readonly projectRef: MonitoringDashboardSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema MonitoringDashboardSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The content is divided into equally spaced rows and the widgets are arranged horizontally.
   *
   * @schema MonitoringDashboardSpec#rowLayout
   */
  readonly rowLayout?: MonitoringDashboardSpecRowLayout;

}

/**
 * Converts an object of type 'MonitoringDashboardSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpec(obj: MonitoringDashboardSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columnLayout': toJson_MonitoringDashboardSpecColumnLayout(obj.columnLayout),
    'displayName': obj.displayName,
    'gridLayout': toJson_MonitoringDashboardSpecGridLayout(obj.gridLayout),
    'mosaicLayout': toJson_MonitoringDashboardSpecMosaicLayout(obj.mosaicLayout),
    'projectRef': toJson_MonitoringDashboardSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rowLayout': toJson_MonitoringDashboardSpecRowLayout(obj.rowLayout),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The content is divided into equally spaced columns and the widgets are arranged vertically.
 *
 * @schema MonitoringDashboardSpecColumnLayout
 */
export interface MonitoringDashboardSpecColumnLayout {
  /**
   * The columns of content to display.
   *
   * @schema MonitoringDashboardSpecColumnLayout#columns
   */
  readonly columns?: MonitoringDashboardSpecColumnLayoutColumns[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayout(obj: MonitoringDashboardSpecColumnLayout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumns(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
 *
 * @schema MonitoringDashboardSpecGridLayout
 */
export interface MonitoringDashboardSpecGridLayout {
  /**
   * The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
   *
   * @schema MonitoringDashboardSpecGridLayout#columns
   */
  readonly columns?: number;

  /**
   * The informational elements that are arranged into the columns row-first.
   *
   * @schema MonitoringDashboardSpecGridLayout#widgets
   */
  readonly widgets?: MonitoringDashboardSpecGridLayoutWidgets[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayout(obj: MonitoringDashboardSpecGridLayout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns,
    'widgets': obj.widgets?.map(y => toJson_MonitoringDashboardSpecGridLayoutWidgets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The content is arranged as a grid of tiles, with each content widget occupying one or more tiles.
 *
 * @schema MonitoringDashboardSpecMosaicLayout
 */
export interface MonitoringDashboardSpecMosaicLayout {
  /**
   * The number of columns in the mosaic grid.
   *
   * @schema MonitoringDashboardSpecMosaicLayout#columns
   */
  readonly columns?: number;

  /**
   * The tiles to display.
   *
   * @schema MonitoringDashboardSpecMosaicLayout#tiles
   */
  readonly tiles?: MonitoringDashboardSpecMosaicLayoutTiles[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayout(obj: MonitoringDashboardSpecMosaicLayout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'columns': obj.columns,
    'tiles': obj.tiles?.map(y => toJson_MonitoringDashboardSpecMosaicLayoutTiles(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringDashboardSpecProjectRef
 */
export interface MonitoringDashboardSpecProjectRef {
  /**
   * The project id of the resource.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringDashboardSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringDashboardSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringDashboardSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecProjectRef(obj: MonitoringDashboardSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The content is divided into equally spaced rows and the widgets are arranged horizontally.
 *
 * @schema MonitoringDashboardSpecRowLayout
 */
export interface MonitoringDashboardSpecRowLayout {
  /**
   * The rows of content to display.
   *
   * @schema MonitoringDashboardSpecRowLayout#rows
   */
  readonly rows?: MonitoringDashboardSpecRowLayoutRows[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayout(obj: MonitoringDashboardSpecRowLayout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rows': obj.rows?.map(y => toJson_MonitoringDashboardSpecRowLayoutRows(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumns
 */
export interface MonitoringDashboardSpecColumnLayoutColumns {
  /**
   * The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumns#weight
   */
  readonly weight?: number;

  /**
   * The display widgets arranged vertically in this column.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumns#widgets
   */
  readonly widgets?: MonitoringDashboardSpecColumnLayoutColumnsWidgets[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumns(obj: MonitoringDashboardSpecColumnLayoutColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
    'widgets': obj.widgets?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgets
 */
export interface MonitoringDashboardSpecGridLayoutWidgets {
  /**
   * A blank space.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgets#blank
   */
  readonly blank?: any;

  /**
   * @schema MonitoringDashboardSpecGridLayoutWidgets#logsPanel
   */
  readonly logsPanel?: MonitoringDashboardSpecGridLayoutWidgetsLogsPanel;

  /**
   * A scorecard summarizing time series data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgets#scorecard
   */
  readonly scorecard?: MonitoringDashboardSpecGridLayoutWidgetsScorecard;

  /**
   * A raw string or markdown displaying textual content.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgets#text
   */
  readonly text?: MonitoringDashboardSpecGridLayoutWidgetsText;

  /**
   * Optional. The title of the widget.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgets#title
   */
  readonly title?: string;

  /**
   * A chart of time series data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgets#xyChart
   */
  readonly xyChart?: MonitoringDashboardSpecGridLayoutWidgetsXyChart;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgets(obj: MonitoringDashboardSpecGridLayoutWidgets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blank': obj.blank,
    'logsPanel': toJson_MonitoringDashboardSpecGridLayoutWidgetsLogsPanel(obj.logsPanel),
    'scorecard': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecard(obj.scorecard),
    'text': toJson_MonitoringDashboardSpecGridLayoutWidgetsText(obj.text),
    'title': obj.title,
    'xyChart': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChart(obj.xyChart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTiles
 */
export interface MonitoringDashboardSpecMosaicLayoutTiles {
  /**
   * The height of the tile, measured in grid squares.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTiles#height
   */
  readonly height?: number;

  /**
   * The informational widget contained in the tile.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTiles#widget
   */
  readonly widget?: MonitoringDashboardSpecMosaicLayoutTilesWidget;

  /**
   * The width of the tile, measured in grid squares.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTiles#width
   */
  readonly width?: number;

  /**
   * The zero-indexed position of the tile in grid squares relative to the left edge of the grid.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTiles#xPos
   */
  readonly xPos?: number;

  /**
   * The zero-indexed position of the tile in grid squares relative to the top edge of the grid.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTiles#yPos
   */
  readonly yPos?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTiles(obj: MonitoringDashboardSpecMosaicLayoutTiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'height': obj.height,
    'widget': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidget(obj.widget),
    'width': obj.width,
    'xPos': obj.xPos,
    'yPos': obj.yPos,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRows
 */
export interface MonitoringDashboardSpecRowLayoutRows {
  /**
   * The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
   *
   * @schema MonitoringDashboardSpecRowLayoutRows#weight
   */
  readonly weight?: number;

  /**
   * The display widgets arranged horizontally in this row.
   *
   * @schema MonitoringDashboardSpecRowLayoutRows#widgets
   */
  readonly widgets?: MonitoringDashboardSpecRowLayoutRowsWidgets[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRows' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRows(obj: MonitoringDashboardSpecRowLayoutRows | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
    'widgets': obj.widgets?.map(y => toJson_MonitoringDashboardSpecRowLayoutRowsWidgets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgets {
  /**
   * A blank space.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#blank
   */
  readonly blank?: any;

  /**
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#logsPanel
   */
  readonly logsPanel?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel;

  /**
   * A scorecard summarizing time series data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#scorecard
   */
  readonly scorecard?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard;

  /**
   * A raw string or markdown displaying textual content.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#text
   */
  readonly text?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsText;

  /**
   * Optional. The title of the widget.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#title
   */
  readonly title?: string;

  /**
   * A chart of time series data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgets#xyChart
   */
  readonly xyChart?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgets(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blank': obj.blank,
    'logsPanel': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel(obj.logsPanel),
    'scorecard': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard(obj.scorecard),
    'text': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsText(obj.text),
    'title': obj.title,
    'xyChart': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart(obj.xyChart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanel
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsLogsPanel {
  /**
   * A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanel#filter
   */
  readonly filter?: string;

  /**
   * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanel#resourceNames
   */
  readonly resourceNames?: MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsLogsPanel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsLogsPanel(obj: MonitoringDashboardSpecGridLayoutWidgetsLogsPanel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'resourceNames': obj.resourceNames?.map(y => toJson_MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A scorecard summarizing time series data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecard
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecard {
  /**
   * Will cause the scorecard to show a gauge chart.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecard#gaugeView
   */
  readonly gaugeView?: MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView;

  /**
   * Will cause the scorecard to show a spark chart.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecard#sparkChartView
   */
  readonly sparkChartView?: MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView;

  /**
   * The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecard#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds[];

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecard#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecard' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecard(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecard | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gaugeView': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView(obj.gaugeView),
    'sparkChartView': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView(obj.sparkChartView),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds(y)),
    'timeSeriesQuery': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A raw string or markdown displaying textual content.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsText
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsText {
  /**
   * The text content to be displayed.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsText#content
   */
  readonly content?: string;

  /**
   * How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsText#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsText(obj: MonitoringDashboardSpecGridLayoutWidgetsText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A chart of time series data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChart {
  /**
   * Display options for the chart.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#chartOptions
   */
  readonly chartOptions?: MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions;

  /**
   * Required. The data displayed in this chart.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#dataSets
   */
  readonly dataSets: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets[];

  /**
   * Threshold lines drawn horizontally across the chart.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds[];

  /**
   * The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#timeshiftDuration
   */
  readonly timeshiftDuration?: string;

  /**
   * The properties applied to the X axis.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#xAxis
   */
  readonly xAxis?: MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis;

  /**
   * The properties applied to the Y axis.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChart#yAxis
   */
  readonly yAxis?: MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChart(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chartOptions': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions(obj.chartOptions),
    'dataSets': obj.dataSets?.map(y => toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets(y)),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds(y)),
    'timeshiftDuration': obj.timeshiftDuration,
    'xAxis': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis(obj.xAxis),
    'yAxis': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis(obj.yAxis),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The informational widget contained in the tile.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidget {
  /**
   * A blank space.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#blank
   */
  readonly blank?: any;

  /**
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#logsPanel
   */
  readonly logsPanel?: MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel;

  /**
   * A scorecard summarizing time series data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#scorecard
   */
  readonly scorecard?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard;

  /**
   * A raw string or markdown displaying textual content.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#text
   */
  readonly text?: MonitoringDashboardSpecMosaicLayoutTilesWidgetText;

  /**
   * Optional. The title of the widget.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#title
   */
  readonly title?: string;

  /**
   * A chart of time series data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidget#xyChart
   */
  readonly xyChart?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidget(obj: MonitoringDashboardSpecMosaicLayoutTilesWidget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blank': obj.blank,
    'logsPanel': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel(obj.logsPanel),
    'scorecard': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard(obj.scorecard),
    'text': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetText(obj.text),
    'title': obj.title,
    'xyChart': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart(obj.xyChart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgets
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgets {
  /**
   * A blank space.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#blank
   */
  readonly blank?: any;

  /**
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#logsPanel
   */
  readonly logsPanel?: MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel;

  /**
   * A scorecard summarizing time series data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#scorecard
   */
  readonly scorecard?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard;

  /**
   * A raw string or markdown displaying textual content.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#text
   */
  readonly text?: MonitoringDashboardSpecRowLayoutRowsWidgetsText;

  /**
   * Optional. The title of the widget.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#title
   */
  readonly title?: string;

  /**
   * A chart of time series data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgets#xyChart
   */
  readonly xyChart?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgets(obj: MonitoringDashboardSpecRowLayoutRowsWidgets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blank': obj.blank,
    'logsPanel': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel(obj.logsPanel),
    'scorecard': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard(obj.scorecard),
    'text': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsText(obj.text),
    'title': obj.title,
    'xyChart': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart(obj.xyChart),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel {
  /**
   * A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel#filter
   */
  readonly filter?: string;

  /**
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel#resourceNames
   */
  readonly resourceNames?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'resourceNames': obj.resourceNames?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A scorecard summarizing time series data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard {
  /**
   * Will cause the scorecard to show a gauge chart.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard#gaugeView
   */
  readonly gaugeView?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView;

  /**
   * Will cause the scorecard to show a spark chart.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard#sparkChartView
   */
  readonly sparkChartView?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView;

  /**
   * The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds[];

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecard | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gaugeView': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView(obj.gaugeView),
    'sparkChartView': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView(obj.sparkChartView),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds(y)),
    'timeSeriesQuery': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A raw string or markdown displaying textual content.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsText
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsText {
  /**
   * The text content to be displayed.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsText#content
   */
  readonly content?: string;

  /**
   * How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsText#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsText(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A chart of time series data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart {
  /**
   * Display options for the chart.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#chartOptions
   */
  readonly chartOptions?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions;

  /**
   * Required. The data displayed in this chart.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#dataSets
   */
  readonly dataSets: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets[];

  /**
   * Threshold lines drawn horizontally across the chart.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds[];

  /**
   * The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#timeshiftDuration
   */
  readonly timeshiftDuration?: string;

  /**
   * The properties applied to the X axis.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#xAxis
   */
  readonly xAxis?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis;

  /**
   * The properties applied to the Y axis.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart#yAxis
   */
  readonly yAxis?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chartOptions': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions(obj.chartOptions),
    'dataSets': obj.dataSets?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets(y)),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds(y)),
    'timeshiftDuration': obj.timeshiftDuration,
    'xAxis': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis(obj.xAxis),
    'yAxis': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis(obj.yAxis),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames(obj: MonitoringDashboardSpecGridLayoutWidgetsLogsPanelResourceNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a gauge chart.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView {
  /**
   * The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView#lowerBound
   */
  readonly lowerBound?: number;

  /**
   * The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView#upperBound
   */
  readonly upperBound?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardGaugeView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lowerBound': obj.lowerBound,
    'upperBound': obj.upperBound,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a spark chart.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView {
  /**
   * The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView#sparkChartType
   */
  readonly sparkChartType: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardSparkChartView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'sparkChartType': obj.sparkChartType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Display options for the chart.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions {
  /**
   * The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartChartOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets {
  /**
   * A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets#legendTemplate
   */
  readonly legendTemplate?: string;

  /**
   * Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets#plotType
   */
  readonly plotType?: string;

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'legendTemplate': obj.legendTemplate,
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'plotType': obj.plotType,
    'timeSeriesQuery': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the X axis.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartXAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the Y axis.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartYAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel {
  /**
   * A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel#filter
   */
  readonly filter?: string;

  /**
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel#resourceNames
   */
  readonly resourceNames?: MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'resourceNames': obj.resourceNames?.map(y => toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A scorecard summarizing time series data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard {
  /**
   * Will cause the scorecard to show a gauge chart.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard#gaugeView
   */
  readonly gaugeView?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView;

  /**
   * Will cause the scorecard to show a spark chart.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard#sparkChartView
   */
  readonly sparkChartView?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView;

  /**
   * The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds[];

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecard | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gaugeView': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView(obj.gaugeView),
    'sparkChartView': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView(obj.sparkChartView),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds(y)),
    'timeSeriesQuery': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A raw string or markdown displaying textual content.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetText
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetText {
  /**
   * The text content to be displayed.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetText#content
   */
  readonly content?: string;

  /**
   * How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetText#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetText(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A chart of time series data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart {
  /**
   * Display options for the chart.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#chartOptions
   */
  readonly chartOptions?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions;

  /**
   * Required. The data displayed in this chart.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#dataSets
   */
  readonly dataSets: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets[];

  /**
   * Threshold lines drawn horizontally across the chart.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds[];

  /**
   * The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#timeshiftDuration
   */
  readonly timeshiftDuration?: string;

  /**
   * The properties applied to the X axis.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#xAxis
   */
  readonly xAxis?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis;

  /**
   * The properties applied to the Y axis.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart#yAxis
   */
  readonly yAxis?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chartOptions': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions(obj.chartOptions),
    'dataSets': obj.dataSets?.map(y => toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets(y)),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds(y)),
    'timeshiftDuration': obj.timeshiftDuration,
    'xAxis': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis(obj.xAxis),
    'yAxis': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis(obj.yAxis),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel {
  /**
   * A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel#filter
   */
  readonly filter?: string;

  /**
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel#resourceNames
   */
  readonly resourceNames?: MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames[];

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'resourceNames': obj.resourceNames?.map(y => toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A scorecard summarizing time series data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard {
  /**
   * Will cause the scorecard to show a gauge chart.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard#gaugeView
   */
  readonly gaugeView?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView;

  /**
   * Will cause the scorecard to show a spark chart.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard#sparkChartView
   */
  readonly sparkChartView?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView;

  /**
   * The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds[];

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecard | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gaugeView': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView(obj.gaugeView),
    'sparkChartView': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView(obj.sparkChartView),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds(y)),
    'timeSeriesQuery': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A raw string or markdown displaying textual content.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsText
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsText {
  /**
   * The text content to be displayed.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsText#content
   */
  readonly content?: string;

  /**
   * How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsText#format
   */
  readonly format?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsText' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsText(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsText | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A chart of time series data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart {
  /**
   * Display options for the chart.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#chartOptions
   */
  readonly chartOptions?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions;

  /**
   * Required. The data displayed in this chart.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#dataSets
   */
  readonly dataSets: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets[];

  /**
   * Threshold lines drawn horizontally across the chart.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#thresholds
   */
  readonly thresholds?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds[];

  /**
   * The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#timeshiftDuration
   */
  readonly timeshiftDuration?: string;

  /**
   * The properties applied to the X axis.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#xAxis
   */
  readonly xAxis?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis;

  /**
   * The properties applied to the Y axis.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart#yAxis
   */
  readonly yAxis?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chartOptions': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions(obj.chartOptions),
    'dataSets': obj.dataSets?.map(y => toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets(y)),
    'thresholds': obj.thresholds?.map(y => toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds(y)),
    'timeshiftDuration': obj.timeshiftDuration,
    'xAxis': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis(obj.xAxis),
    'yAxis': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis(obj.yAxis),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsLogsPanelResourceNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a gauge chart.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView {
  /**
   * The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView#lowerBound
   */
  readonly lowerBound?: number;

  /**
   * The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView#upperBound
   */
  readonly upperBound?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardGaugeView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lowerBound': obj.lowerBound,
    'upperBound': obj.upperBound,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a spark chart.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView {
  /**
   * The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView#sparkChartType
   */
  readonly sparkChartType: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardSparkChartView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'sparkChartType': obj.sparkChartType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Display options for the chart.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions {
  /**
   * The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartChartOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets {
  /**
   * A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets#legendTemplate
   */
  readonly legendTemplate?: string;

  /**
   * Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets#plotType
   */
  readonly plotType?: string;

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'legendTemplate': obj.legendTemplate,
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'plotType': obj.plotType,
    'timeSeriesQuery': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the X axis.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartXAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the Y axis.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartYAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetLogsPanelResourceNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a gauge chart.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView {
  /**
   * The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView#lowerBound
   */
  readonly lowerBound?: number;

  /**
   * The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView#upperBound
   */
  readonly upperBound?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardGaugeView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lowerBound': obj.lowerBound,
    'upperBound': obj.upperBound,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a spark chart.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView {
  /**
   * The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView#sparkChartType
   */
  readonly sparkChartType: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardSparkChartView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'sparkChartType': obj.sparkChartType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Display options for the chart.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions {
  /**
   * The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartChartOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets {
  /**
   * A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets#legendTemplate
   */
  readonly legendTemplate?: string;

  /**
   * Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets#plotType
   */
  readonly plotType?: string;

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'legendTemplate': obj.legendTemplate,
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'plotType': obj.plotType,
    'timeSeriesQuery': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the X axis.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartXAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the Y axis.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartYAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames {
  /**
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsLogsPanelResourceNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a gauge chart.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView {
  /**
   * The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView#lowerBound
   */
  readonly lowerBound?: number;

  /**
   * The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView#upperBound
   */
  readonly upperBound?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardGaugeView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lowerBound': obj.lowerBound,
    'upperBound': obj.upperBound,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Will cause the scorecard to show a spark chart.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView {
  /**
   * The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView#sparkChartType
   */
  readonly sparkChartType: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardSparkChartView | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'sparkChartType': obj.sparkChartType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Display options for the chart.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions {
  /**
   * The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartChartOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets {
  /**
   * A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets#legendTemplate
   */
  readonly legendTemplate?: string;

  /**
   * Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets#minAlignmentPeriod
   */
  readonly minAlignmentPeriod?: string;

  /**
   * How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets#plotType
   */
  readonly plotType?: string;

  /**
   * Required. Fields for querying time series data from the Stackdriver metrics API.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets#timeSeriesQuery
   */
  readonly timeSeriesQuery: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'legendTemplate': obj.legendTemplate,
    'minAlignmentPeriod': obj.minAlignmentPeriod,
    'plotType': obj.plotType,
    'timeSeriesQuery': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(obj.timeSeriesQuery),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds {
  /**
   * The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds#color
   */
  readonly color?: string;

  /**
   * The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds#direction
   */
  readonly direction?: string;

  /**
   * A label for the threshold.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds#label
   */
  readonly label?: string;

  /**
   * The value of the threshold. The value should be defined in the native scale of the metric.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'color': obj.color,
    'direction': obj.direction,
    'label': obj.label,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the X axis.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartXAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The properties applied to the Y axis.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis {
  /**
   * The label of the axis.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis#label
   */
  readonly label?: string;

  /**
   * The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis#scale
   */
  readonly scale?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartYAxis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'label': obj.label,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. Fields for querying time series data from the Stackdriver metrics API.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery {
  /**
   * Filter parameters to fetch time series.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilter
   */
  readonly timeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter;

  /**
   * Parameters to fetch a ratio between two time series filters.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesFilterRatio
   */
  readonly timeSeriesFilterRatio?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio;

  /**
   * A query used to fetch time series.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery#timeSeriesQueryLanguage
   */
  readonly timeSeriesQueryLanguage?: string;

  /**
   * The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery#unitOverride
   */
  readonly unitOverride?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQuery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj.timeSeriesFilter),
    'timeSeriesFilterRatio': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj.timeSeriesFilterRatio),
    'timeSeriesQueryLanguage': obj.timeSeriesQueryLanguage,
    'unitOverride': obj.unitOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter parameters to fetch time series.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#filter
   */
  readonly filter: string;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after `aggregation` is applied.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj.aggregation),
    'filter': obj.filter,
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Parameters to fetch a ratio between two time series filters.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio {
  /**
   * The denominator of the ratio.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#denominator
   */
  readonly denominator?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator;

  /**
   * The numerator of the ratio.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#numerator
   */
  readonly numerator?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator;

  /**
   * Ranking based time series filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#pickTimeSeriesFilter
   */
  readonly pickTimeSeriesFilter?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter;

  /**
   * Apply a second aggregation after the ratio is computed.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio#secondaryAggregation
   */
  readonly secondaryAggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'denominator': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj.denominator),
    'numerator': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj.numerator),
    'pickTimeSeriesFilter': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj.pickTimeSeriesFilter),
    'secondaryAggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj.secondaryAggregation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecGridLayoutWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsScorecardTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after `aggregation` is applied.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The denominator of the ratio.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The numerator of the ratio.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator {
  /**
   * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#aggregation
   */
  readonly aggregation?: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation;

  /**
   * Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator#filter
   */
  readonly filter: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregation': toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj.aggregation),
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ranking based time series filter.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter {
  /**
   * How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#direction
   */
  readonly direction?: string;

  /**
   * How many time series to allow to pass through the filter.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#numTimeSeries
   */
  readonly numTimeSeries?: number;

  /**
   * `ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter#rankingMethod
   */
  readonly rankingMethod?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioPickTimeSeriesFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'direction': obj.direction,
    'numTimeSeries': obj.numTimeSeries,
    'rankingMethod': obj.rankingMethod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Apply a second aggregation after the ratio is computed.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioSecondaryAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecColumnLayoutColumnsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecMosaicLayoutTilesWidgetXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioDenominatorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
 *
 * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation
 */
export interface MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation {
  /**
   * The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.
   *
   * @schema MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation(obj: MonitoringDashboardSpecRowLayoutRowsWidgetsXyChartDataSetsTimeSeriesQueryTimeSeriesFilterRatioNumeratorAggregation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringGroup
 */
export class MonitoringGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringGroup',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringGroupProps): any {
    return {
      ...MonitoringGroup.GVK,
      ...toJson_MonitoringGroupProps(props),
    };
  }

  /**
   * Defines a "MonitoringGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringGroupProps) {
    super(scope, id, {
      ...MonitoringGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringGroup.GVK,
      ...toJson_MonitoringGroupProps(resolved),
    };
  }
}

/**
 * @schema MonitoringGroup
 */
export interface MonitoringGroupProps {
  /**
   * @schema MonitoringGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringGroup#spec
   */
  readonly spec: MonitoringGroupSpec;

}

/**
 * Converts an object of type 'MonitoringGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringGroupProps(obj: MonitoringGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringGroupSpec
 */
export interface MonitoringGroupSpec {
  /**
   * A user-assigned name for this group, used only for display purposes.
   *
   * @schema MonitoringGroupSpec#displayName
   */
  readonly displayName: string;

  /**
   * The filter used to determine which monitored resources belong to this group.
   *
   * @schema MonitoringGroupSpec#filter
   */
  readonly filter: string;

  /**
   * If true, the members of this group are considered to be a cluster. The system can perform additional analysis on groups that are clusters.
   *
   * @schema MonitoringGroupSpec#isCluster
   */
  readonly isCluster?: boolean;

  /**
   * @schema MonitoringGroupSpec#parentRef
   */
  readonly parentRef?: MonitoringGroupSpecParentRef;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringGroupSpec#projectRef
   */
  readonly projectRef?: MonitoringGroupSpecProjectRef;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema MonitoringGroupSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'MonitoringGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringGroupSpec(obj: MonitoringGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'filter': obj.filter,
    'isCluster': obj.isCluster,
    'parentRef': toJson_MonitoringGroupSpecParentRef(obj.parentRef),
    'projectRef': toJson_MonitoringGroupSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringGroupSpecParentRef
 */
export interface MonitoringGroupSpecParentRef {
  /**
   * The name of the group's parent, if it has one. The format is: projects/ For groups with no parent, `parent_name` is the empty string, ``.
   *
   * Allowed value: The Google Cloud resource name of a `MonitoringGroup` resource (format: `projects/{{project}}/groups/{{name}}`).
   *
   * @schema MonitoringGroupSpecParentRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringGroupSpecParentRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringGroupSpecParentRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringGroupSpecParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringGroupSpecParentRef(obj: MonitoringGroupSpecParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringGroupSpecProjectRef
 */
export interface MonitoringGroupSpecProjectRef {
  /**
   * The project of the group
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringGroupSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringGroupSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringGroupSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringGroupSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringGroupSpecProjectRef(obj: MonitoringGroupSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringMetricDescriptor
 */
export class MonitoringMetricDescriptor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringMetricDescriptor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringMetricDescriptor',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringMetricDescriptor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringMetricDescriptorProps): any {
    return {
      ...MonitoringMetricDescriptor.GVK,
      ...toJson_MonitoringMetricDescriptorProps(props),
    };
  }

  /**
   * Defines a "MonitoringMetricDescriptor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringMetricDescriptorProps) {
    super(scope, id, {
      ...MonitoringMetricDescriptor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringMetricDescriptor.GVK,
      ...toJson_MonitoringMetricDescriptorProps(resolved),
    };
  }
}

/**
 * @schema MonitoringMetricDescriptor
 */
export interface MonitoringMetricDescriptorProps {
  /**
   * @schema MonitoringMetricDescriptor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringMetricDescriptor#spec
   */
  readonly spec: MonitoringMetricDescriptorSpec;

}

/**
 * Converts an object of type 'MonitoringMetricDescriptorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMetricDescriptorProps(obj: MonitoringMetricDescriptorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringMetricDescriptorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringMetricDescriptorSpec
 */
export interface MonitoringMetricDescriptorSpec {
  /**
   * Immutable. A detailed description of the metric, which can be used in documentation.
   *
   * @schema MonitoringMetricDescriptorSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count". This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.
   *
   * @schema MonitoringMetricDescriptorSpec#displayName
   */
  readonly displayName?: string;

  /**
   * Immutable. The set of labels that can be used to describe a specific instance of this metric type. For example, the `appengine.googleapis.com/http/server/response_latencies` metric type has a label for the HTTP response code, `response_code`, so you can look at latencies for successful responses or just for responses that failed.
   *
   * @schema MonitoringMetricDescriptorSpec#labels
   */
  readonly labels?: MonitoringMetricDescriptorSpecLabels[];

  /**
   * Immutable. Optional. The launch stage of the metric definition. Possible values: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED
   *
   * @schema MonitoringMetricDescriptorSpec#launchStage
   */
  readonly launchStage?: string;

  /**
   * Immutable. Optional. Metadata which can be used to guide usage of the metric.
   *
   * @schema MonitoringMetricDescriptorSpec#metadata
   */
  readonly metadata?: MonitoringMetricDescriptorSpecMetadata;

  /**
   * Immutable. Whether the metric records instantaneous values, changes to a value, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: METRIC_KIND_UNSPECIFIED, GAUGE, DELTA, CUMULATIVE
   *
   * @schema MonitoringMetricDescriptorSpec#metricKind
   */
  readonly metricKind: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringMetricDescriptorSpec#projectRef
   */
  readonly projectRef: MonitoringMetricDescriptorSpecProjectRef;

  /**
   * Immutable. The metric type, including its DNS name prefix. The type is not URL-encoded. All user-defined metric types have the DNS name `custom.googleapis.com` or `external.googleapis.com`. Metric types should use a natural hierarchical grouping. For example: "custom.googleapis.com/invoice/paid/amount" "external.googleapis.com/prometheus/up" "appengine.googleapis.com/http/server/response_latencies"
   *
   * @schema MonitoringMetricDescriptorSpec#type
   */
  readonly type: string;

  /**
   * Immutable. The units in which the metric value is reported. It is only applicable if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit` defines the representation of the stored metric values. Different systems might scale the values to be more easily displayed (so a value of `0.02kBy` _might_ be displayed as `20By`, and a value of `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is `kBy`, then the value of the metric is always in thousands of bytes, no matter how it might be displayed. If you want a custom metric to record the exact number of CPU-seconds used by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005 CPU-seconds, then the value is written as `12005`. Alternatively, if you want a custom metric to record data in a more granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`), or use `Kis{CPU}` and write `11.723` (which is `12005/1024`). The supported units are a subset of [The Unified Code for Units of Measure](https://unitsofmeasure.org/ucum.html) standard: **Basic units (UNIT)** * `bit` bit * `By` byte * `s` second * `min` minute * `h` hour * `d` day * `1` dimensionless **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `E` exa (10^18) * `Z` zetta (10^21) * `Y` yotta (10^24) * `m` milli (10^-3) * `u` micro (10^-6) * `n` nano (10^-9) * `p` pico (10^-12) * `f` femto (10^-15) * `a` atto (10^-18) * `z` zepto (10^-21) * `y` yocto (10^-24) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For examples, `kBy/{email}` or `MiBy/10ms` (although you should almost never have `/s` in a metric `unit`; rates should always be computed at query time from the underlying cumulative or delta value). * `.` multiplication or composition (as an infix operator). For examples, `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: Expression = Component: { "." Component } { "/" Component } ; Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ] | Annotation | "1" ; Annotation = "{" NAME "}" ; Notes: * `Annotation` is just a comment if it follows a `UNIT`. If the annotation is used alone, then the unit is equivalent to `1`. For examples, `{request}/s == 1/s`, `By{transmitted}/s == By/s`. * `NAME` is a sequence of non-blank printable ASCII characters not containing `{` or `}`. * `1` represents a unitary [dimensionless unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such as in `1/s`. It is typically used when none of the basic units are appropriate. For example, "new users per day" can be represented as `1/d` or `{new-users}/d` (and a metric value `5` would mean "5 new users). Alternatively, "thousands of page views per day" would be represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric value of `5.3` would mean "5300 page views per day"). * `%` represents dimensionless value of 1/100, and annotates values giving a percentage (so the metric values are typically in the range of 0..100, and a metric value `3` means "3 percent"). * `10^2.%` indicates a metric contains a ratio, typically in the range 0..1, that will be multiplied by 100 and displayed as a percentage (so a metric value `0.03` means "3 percent").
   *
   * @schema MonitoringMetricDescriptorSpec#unit
   */
  readonly unit?: string;

  /**
   * Immutable. Whether the measurement is an integer, a floating-point number, etc. Some combinations of `metric_kind` and `value_type` might not be supported. Possible values: STRING, BOOL, INT64
   *
   * @schema MonitoringMetricDescriptorSpec#valueType
   */
  readonly valueType: string;

}

/**
 * Converts an object of type 'MonitoringMetricDescriptorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMetricDescriptorSpec(obj: MonitoringMetricDescriptorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'labels': obj.labels?.map(y => toJson_MonitoringMetricDescriptorSpecLabels(y)),
    'launchStage': obj.launchStage,
    'metadata': toJson_MonitoringMetricDescriptorSpecMetadata(obj.metadata),
    'metricKind': obj.metricKind,
    'projectRef': toJson_MonitoringMetricDescriptorSpecProjectRef(obj.projectRef),
    'type': obj.type,
    'unit': obj.unit,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringMetricDescriptorSpecLabels
 */
export interface MonitoringMetricDescriptorSpecLabels {
  /**
   * Immutable. A human-readable description for the label.
   *
   * @schema MonitoringMetricDescriptorSpecLabels#description
   */
  readonly description?: string;

  /**
   * Immutable. The key for this label. The key must meet the following criteria: * Does not exceed 100 characters. * Matches the following regular expression: `a-zA-Z*` * The first character must be an upper- or lower-case letter. * The remaining characters must be letters, digits, or underscores.
   *
   * @schema MonitoringMetricDescriptorSpecLabels#key
   */
  readonly key?: string;

  /**
   * Immutable. The type of data that can be assigned to the label. Possible values: STRING, BOOL, INT64
   *
   * @schema MonitoringMetricDescriptorSpecLabels#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MonitoringMetricDescriptorSpecLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMetricDescriptorSpecLabels(obj: MonitoringMetricDescriptorSpecLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. Optional. Metadata which can be used to guide usage of the metric.
 *
 * @schema MonitoringMetricDescriptorSpecMetadata
 */
export interface MonitoringMetricDescriptorSpecMetadata {
  /**
   * Immutable. The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
   *
   * @schema MonitoringMetricDescriptorSpecMetadata#ingestDelay
   */
  readonly ingestDelay?: string;

  /**
   * Immutable. Deprecated. Must use the MetricDescriptor.launch_stage instead. Possible values: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED
   *
   * @schema MonitoringMetricDescriptorSpecMetadata#launchStage
   */
  readonly launchStage?: string;

  /**
   * Immutable. The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
   *
   * @schema MonitoringMetricDescriptorSpecMetadata#samplePeriod
   */
  readonly samplePeriod?: string;

}

/**
 * Converts an object of type 'MonitoringMetricDescriptorSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMetricDescriptorSpecMetadata(obj: MonitoringMetricDescriptorSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestDelay': obj.ingestDelay,
    'launchStage': obj.launchStage,
    'samplePeriod': obj.samplePeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringMetricDescriptorSpecProjectRef
 */
export interface MonitoringMetricDescriptorSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringMetricDescriptorSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringMetricDescriptorSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringMetricDescriptorSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringMetricDescriptorSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMetricDescriptorSpecProjectRef(obj: MonitoringMetricDescriptorSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringMonitoredProject
 */
export class MonitoringMonitoredProject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringMonitoredProject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringMonitoredProject',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringMonitoredProject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringMonitoredProjectProps): any {
    return {
      ...MonitoringMonitoredProject.GVK,
      ...toJson_MonitoringMonitoredProjectProps(props),
    };
  }

  /**
   * Defines a "MonitoringMonitoredProject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringMonitoredProjectProps) {
    super(scope, id, {
      ...MonitoringMonitoredProject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringMonitoredProject.GVK,
      ...toJson_MonitoringMonitoredProjectProps(resolved),
    };
  }
}

/**
 * @schema MonitoringMonitoredProject
 */
export interface MonitoringMonitoredProjectProps {
  /**
   * @schema MonitoringMonitoredProject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringMonitoredProject#spec
   */
  readonly spec: MonitoringMonitoredProjectSpec;

}

/**
 * Converts an object of type 'MonitoringMonitoredProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMonitoredProjectProps(obj: MonitoringMonitoredProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringMonitoredProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringMonitoredProjectSpec
 */
export interface MonitoringMonitoredProjectSpec {
  /**
   * Immutable. Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}
   *
   * @schema MonitoringMonitoredProjectSpec#metricsScope
   */
  readonly metricsScope: string;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema MonitoringMonitoredProjectSpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'MonitoringMonitoredProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringMonitoredProjectSpec(obj: MonitoringMonitoredProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricsScope': obj.metricsScope,
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringNotificationChannel
 */
export class MonitoringNotificationChannel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringNotificationChannel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringNotificationChannel',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringNotificationChannel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringNotificationChannelProps): any {
    return {
      ...MonitoringNotificationChannel.GVK,
      ...toJson_MonitoringNotificationChannelProps(props),
    };
  }

  /**
   * Defines a "MonitoringNotificationChannel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringNotificationChannelProps) {
    super(scope, id, {
      ...MonitoringNotificationChannel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringNotificationChannel.GVK,
      ...toJson_MonitoringNotificationChannelProps(resolved),
    };
  }
}

/**
 * @schema MonitoringNotificationChannel
 */
export interface MonitoringNotificationChannelProps {
  /**
   * @schema MonitoringNotificationChannel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringNotificationChannel#spec
   */
  readonly spec: MonitoringNotificationChannelSpec;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelProps(obj: MonitoringNotificationChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringNotificationChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringNotificationChannelSpec
 */
export interface MonitoringNotificationChannelSpec {
  /**
   * An optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.
   *
   * @schema MonitoringNotificationChannelSpec#description
   */
  readonly description?: string;

  /**
   * Whether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.
   *
   * @schema MonitoringNotificationChannelSpec#enabled
   */
  readonly enabled?: boolean;

  /**
   * If true, the notification channel will be deleted regardless
   * of its use in alert policies (the policies will be updated
   * to remove the channel). If false, channels that are still
   * referenced by an existing alerting policy will fail to be
   * deleted in a delete operation.
   *
   * @schema MonitoringNotificationChannelSpec#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * @schema MonitoringNotificationChannelSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema MonitoringNotificationChannelSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Different notification type behaviors are configured primarily using the the 'labels' field on this
   * resource. This block contains the labels which contain secrets or passwords so that they can be marked
   * sensitive and hidden from plan output. The name of the field, eg: password, will be the key
   * in the 'labels' map in the api request.
   *
   * Credentials may not be specified in both locations and will cause an error. Changing from one location
   * to a different credential configuration in the config will require an apply to update state.
   *
   * @schema MonitoringNotificationChannelSpec#sensitiveLabels
   */
  readonly sensitiveLabels?: MonitoringNotificationChannelSpecSensitiveLabels;

  /**
   * The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as "email", "slack", etc...
   *
   * @schema MonitoringNotificationChannelSpec#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpec(obj: MonitoringNotificationChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enabled': obj.enabled,
    'forceDelete': obj.forceDelete,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceID': obj.resourceId,
    'sensitiveLabels': toJson_MonitoringNotificationChannelSpecSensitiveLabels(obj.sensitiveLabels),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Different notification type behaviors are configured primarily using the the 'labels' field on this
 * resource. This block contains the labels which contain secrets or passwords so that they can be marked
 * sensitive and hidden from plan output. The name of the field, eg: password, will be the key
 * in the 'labels' map in the api request.
 *
 * Credentials may not be specified in both locations and will cause an error. Changing from one location
 * to a different credential configuration in the config will require an apply to update state.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabels
 */
export interface MonitoringNotificationChannelSpecSensitiveLabels {
  /**
   * An authorization token for a notification channel. Channel types that support this field include: slack.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabels#authToken
   */
  readonly authToken?: MonitoringNotificationChannelSpecSensitiveLabelsAuthToken;

  /**
   * An password for a notification channel. Channel types that support this field include: webhook_basicauth.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabels#password
   */
  readonly password?: MonitoringNotificationChannelSpecSensitiveLabelsPassword;

  /**
   * An servicekey token for a notification channel. Channel types that support this field include: pagerduty.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabels#serviceKey
   */
  readonly serviceKey?: MonitoringNotificationChannelSpecSensitiveLabelsServiceKey;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabels(obj: MonitoringNotificationChannelSpecSensitiveLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authToken': toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthToken(obj.authToken),
    'password': toJson_MonitoringNotificationChannelSpecSensitiveLabelsPassword(obj.password),
    'serviceKey': toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKey(obj.serviceKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An authorization token for a notification channel. Channel types that support this field include: slack.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthToken
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsAuthToken {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthToken#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthToken#valueFrom
   */
  readonly valueFrom?: MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthToken(obj: MonitoringNotificationChannelSpecSensitiveLabelsAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An password for a notification channel. Channel types that support this field include: webhook_basicauth.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsPassword
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsPassword {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsPassword#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsPassword#valueFrom
   */
  readonly valueFrom?: MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsPassword(obj: MonitoringNotificationChannelSpecSensitiveLabelsPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An servicekey token for a notification channel. Channel types that support this field include: pagerduty.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKey
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsServiceKey {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKey#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKey#valueFrom
   */
  readonly valueFrom?: MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsServiceKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKey(obj: MonitoringNotificationChannelSpecSensitiveLabelsServiceKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom(obj: MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom(obj: MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom(obj: MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef(obj: MonitoringNotificationChannelSpecSensitiveLabelsAuthTokenValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef(obj: MonitoringNotificationChannelSpecSensitiveLabelsPasswordValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef
 */
export interface MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef(obj: MonitoringNotificationChannelSpecSensitiveLabelsServiceKeyValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringService
 */
export class MonitoringService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringService',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringServiceProps): any {
    return {
      ...MonitoringService.GVK,
      ...toJson_MonitoringServiceProps(props),
    };
  }

  /**
   * Defines a "MonitoringService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringServiceProps) {
    super(scope, id, {
      ...MonitoringService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringService.GVK,
      ...toJson_MonitoringServiceProps(resolved),
    };
  }
}

/**
 * @schema MonitoringService
 */
export interface MonitoringServiceProps {
  /**
   * @schema MonitoringService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringService#spec
   */
  readonly spec: MonitoringServiceSpec;

}

/**
 * Converts an object of type 'MonitoringServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceProps(obj: MonitoringServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringServiceSpec
 */
export interface MonitoringServiceSpec {
  /**
   * Name used for UI elements listing this Service.
   *
   * @schema MonitoringServiceSpec#displayName
   */
  readonly displayName?: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringServiceSpec#projectRef
   */
  readonly projectRef: MonitoringServiceSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema MonitoringServiceSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Configuration for how to query telemetry on a Service.
   *
   * @schema MonitoringServiceSpec#telemetry
   */
  readonly telemetry?: MonitoringServiceSpecTelemetry;

}

/**
 * Converts an object of type 'MonitoringServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceSpec(obj: MonitoringServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'projectRef': toJson_MonitoringServiceSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'telemetry': toJson_MonitoringServiceSpecTelemetry(obj.telemetry),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringServiceSpecProjectRef
 */
export interface MonitoringServiceSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringServiceSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringServiceSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringServiceSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringServiceSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceSpecProjectRef(obj: MonitoringServiceSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration for how to query telemetry on a Service.
 *
 * @schema MonitoringServiceSpecTelemetry
 */
export interface MonitoringServiceSpecTelemetry {
  /**
   * The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
   *
   * @schema MonitoringServiceSpecTelemetry#resourceName
   */
  readonly resourceName?: string;

}

/**
 * Converts an object of type 'MonitoringServiceSpecTelemetry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceSpecTelemetry(obj: MonitoringServiceSpecTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringServiceLevelObjective
 */
export class MonitoringServiceLevelObjective extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringServiceLevelObjective"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringServiceLevelObjective',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringServiceLevelObjective".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringServiceLevelObjectiveProps): any {
    return {
      ...MonitoringServiceLevelObjective.GVK,
      ...toJson_MonitoringServiceLevelObjectiveProps(props),
    };
  }

  /**
   * Defines a "MonitoringServiceLevelObjective" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringServiceLevelObjectiveProps) {
    super(scope, id, {
      ...MonitoringServiceLevelObjective.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringServiceLevelObjective.GVK,
      ...toJson_MonitoringServiceLevelObjectiveProps(resolved),
    };
  }
}

/**
 * @schema MonitoringServiceLevelObjective
 */
export interface MonitoringServiceLevelObjectiveProps {
  /**
   * @schema MonitoringServiceLevelObjective#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringServiceLevelObjective#spec
   */
  readonly spec: MonitoringServiceLevelObjectiveSpec;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveProps(obj: MonitoringServiceLevelObjectiveProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringServiceLevelObjectiveSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringServiceLevelObjectiveSpec
 */
export interface MonitoringServiceLevelObjectiveSpec {
  /**
   * A calendar period, semantically "since the start of the current ``". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and `MONTH` are supported. Possible values: CALENDAR_PERIOD_UNSPECIFIED, DAY, WEEK, FORTNIGHT, MONTH, QUARTER, HALF, YEAR
   *
   * @schema MonitoringServiceLevelObjectiveSpec#calendarPeriod
   */
  readonly calendarPeriod?: string;

  /**
   * Name used for UI elements listing this SLO.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#displayName
   */
  readonly displayName?: string;

  /**
   * The fraction of service that must be good in order for this objective to be met. `0 < goal <= 0.999`.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#goal
   */
  readonly goal: number;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#projectRef
   */
  readonly projectRef: MonitoringServiceLevelObjectiveSpecProjectRef;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * A rolling time period, semantically "in the past ``". Must be an integer multiple of 1 day no larger than 30 days.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#rollingPeriod
   */
  readonly rollingPeriod?: string;

  /**
   * The definition of good service, used to measure and calculate the quality of the `Service`'s performance with respect to a single aspect of service quality.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#serviceLevelIndicator
   */
  readonly serviceLevelIndicator?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicator;

  /**
   * Immutable.
   *
   * @schema MonitoringServiceLevelObjectiveSpec#serviceRef
   */
  readonly serviceRef: MonitoringServiceLevelObjectiveSpecServiceRef;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpec(obj: MonitoringServiceLevelObjectiveSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'calendarPeriod': obj.calendarPeriod,
    'displayName': obj.displayName,
    'goal': obj.goal,
    'projectRef': toJson_MonitoringServiceLevelObjectiveSpecProjectRef(obj.projectRef),
    'resourceID': obj.resourceId,
    'rollingPeriod': obj.rollingPeriod,
    'serviceLevelIndicator': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicator(obj.serviceLevelIndicator),
    'serviceRef': toJson_MonitoringServiceLevelObjectiveSpecServiceRef(obj.serviceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringServiceLevelObjectiveSpecProjectRef
 */
export interface MonitoringServiceLevelObjectiveSpecProjectRef {
  /**
   * The project for the resource
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringServiceLevelObjectiveSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringServiceLevelObjectiveSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringServiceLevelObjectiveSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecProjectRef(obj: MonitoringServiceLevelObjectiveSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The definition of good service, used to measure and calculate the quality of the `Service`'s performance with respect to a single aspect of service quality.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicator
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicator {
  /**
   * Basic SLI on a well-known service type.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicator#basicSli
   */
  readonly basicSli?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli;

  /**
   * Request-based SLIs
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicator#requestBased
   */
  readonly requestBased?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased;

  /**
   * Windows-based SLIs
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicator#windowsBased
   */
  readonly windowsBased?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicator(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicSli': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli(obj.basicSli),
    'requestBased': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased(obj.requestBased),
    'windowsBased': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased(obj.windowsBased),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceRef
 */
export interface MonitoringServiceLevelObjectiveSpecServiceRef {
  /**
   * The service for the resource
   *
   * Allowed value: The Google Cloud resource name of a `MonitoringService` resource (format: `projects/{{project}}/services/{{name}}`).
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceRef(obj: MonitoringServiceLevelObjectiveSpecServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Basic SLI on a well-known service type.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli {
  /**
   * Good service is defined to be the count of requests made to this service that return successfully.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#availability
   */
  readonly availability?: any;

  /**
   * Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#latency
   */
  readonly latency?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency;

  /**
   * OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#location
   */
  readonly location?: string[];

  /**
   * OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#method
   */
  readonly method?: string[];

  /**
   * Good service is defined to be the count of operations performed by this service that return successfully
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#operationAvailability
   */
  readonly operationAvailability?: any;

  /**
   * Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#operationLatency
   */
  readonly operationLatency?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency;

  /**
   * OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli#version
   */
  readonly version?: string[];

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSli | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability': obj.availability,
    'latency': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency(obj.latency),
    'location': obj.location?.map(y => y),
    'method': obj.method?.map(y => y),
    'operationAvailability': obj.operationAvailability,
    'operationLatency': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency(obj.operationLatency),
    'version': obj.version?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Request-based SLIs
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased {
  /**
   * `distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased#distributionCut
   */
  readonly distributionCut?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut;

  /**
   * `good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased#goodTotalRatio
   */
  readonly goodTotalRatio?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBased | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionCut': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut(obj.distributionCut),
    'goodTotalRatio': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio(obj.goodTotalRatio),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Windows-based SLIs
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if any `true` values appear in the window.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased#goodBadMetricFilter
   */
  readonly goodBadMetricFilter?: string;

  /**
   * A window is good if its `performance` is high enough.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased#goodTotalRatioThreshold
   */
  readonly goodTotalRatioThreshold?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold;

  /**
   * A window is good if the metric's value is in a good range, averaged across returned streams.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased#metricMeanInRange
   */
  readonly metricMeanInRange?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange;

  /**
   * A window is good if the metric's value is in a good range, summed across returned streams.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased#metricSumInRange
   */
  readonly metricSumInRange?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange;

  /**
   * Duration over which window quality is evaluated. Must be an integer fraction of a day and at least `60s`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased#windowPeriod
   */
  readonly windowPeriod?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBased | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'goodBadMetricFilter': obj.goodBadMetricFilter,
    'goodTotalRatioThreshold': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold(obj.goodTotalRatioThreshold),
    'metricMeanInRange': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange(obj.metricMeanInRange),
    'metricSumInRange': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange(obj.metricSumInRange),
    'windowPeriod': obj.windowPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency {
  /**
   * A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency#experience
   */
  readonly experience?: string;

  /**
   * Good service is defined to be the count of requests made to this service that return in no more than `threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency#threshold
   */
  readonly threshold?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'experience': obj.experience,
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency {
  /**
   * A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency#experience
   */
  readonly experience?: string;

  /**
   * Good service is defined to be the count of operations that are completed in no more than `threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency#threshold
   */
  readonly threshold?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorBasicSliOperationLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'experience': obj.experience,
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut#distributionFilter
   */
  readonly distributionFilter?: string;

  /**
   * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut#range
   */
  readonly range?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCut | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionFilter': obj.distributionFilter,
    'range': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange(obj.range),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio#badServiceFilter
   */
  readonly badServiceFilter?: string;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying good service provided. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio#goodServiceFilter
   */
  readonly goodServiceFilter?: string;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying total demanded service. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio#totalServiceFilter
   */
  readonly totalServiceFilter?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedGoodTotalRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'badServiceFilter': obj.badServiceFilter,
    'goodServiceFilter': obj.goodServiceFilter,
    'totalServiceFilter': obj.totalServiceFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A window is good if its `performance` is high enough.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold {
  /**
   * `BasicSli` to evaluate to judge window quality.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold#basicSliPerformance
   */
  readonly basicSliPerformance?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance;

  /**
   * `RequestBasedSli` to evaluate to judge window quality.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold#performance
   */
  readonly performance?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance;

  /**
   * If window `performance >= threshold`, the window is counted as good.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold#threshold
   */
  readonly threshold?: number;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicSliPerformance': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance(obj.basicSliPerformance),
    'performance': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance(obj.performance),
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A window is good if the metric's value is in a good range, averaged across returned streams.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange {
  /**
   * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange#range
   */
  readonly range?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange#timeSeries
   */
  readonly timeSeries?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange(obj.range),
    'timeSeries': obj.timeSeries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A window is good if the metric's value is in a good range, summed across returned streams.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange {
  /**
   * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange#range
   */
  readonly range?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange#timeSeries
   */
  readonly timeSeries?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange(obj.range),
    'timeSeries': obj.timeSeries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange {
  /**
   * Range maximum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange#max
   */
  readonly max?: number;

  /**
   * Range minimum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorRequestBasedDistributionCutRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `BasicSli` to evaluate to judge window quality.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance {
  /**
   * Good service is defined to be the count of requests made to this service that return successfully.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#availability
   */
  readonly availability?: any;

  /**
   * Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#latency
   */
  readonly latency?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency;

  /**
   * OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#location
   */
  readonly location?: string[];

  /**
   * OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#method
   */
  readonly method?: string[];

  /**
   * Good service is defined to be the count of operations performed by this service that return successfully
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#operationAvailability
   */
  readonly operationAvailability?: any;

  /**
   * Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#operationLatency
   */
  readonly operationLatency?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency;

  /**
   * OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance#version
   */
  readonly version?: string[];

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability': obj.availability,
    'latency': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency(obj.latency),
    'location': obj.location?.map(y => y),
    'method': obj.method?.map(y => y),
    'operationAvailability': obj.operationAvailability,
    'operationLatency': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency(obj.operationLatency),
    'version': obj.version?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `RequestBasedSli` to evaluate to judge window quality.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance {
  /**
   * `distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance#distributionCut
   */
  readonly distributionCut?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut;

  /**
   * `good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance#goodTotalRatio
   */
  readonly goodTotalRatio?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionCut': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut(obj.distributionCut),
    'goodTotalRatio': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio(obj.goodTotalRatio),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange {
  /**
   * Range maximum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange#max
   */
  readonly max?: number;

  /**
   * Range minimum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricMeanInRangeRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange {
  /**
   * Range maximum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange#max
   */
  readonly max?: number;

  /**
   * Range minimum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedMetricSumInRangeRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency {
  /**
   * A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency#experience
   */
  readonly experience?: string;

  /**
   * Good service is defined to be the count of requests made to this service that return in no more than `threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency#threshold
   */
  readonly threshold?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'experience': obj.experience,
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency {
  /**
   * A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency#experience
   */
  readonly experience?: string;

  /**
   * Good service is defined to be the count of operations that are completed in no more than `threshold`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency#threshold
   */
  readonly threshold?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdBasicSliPerformanceOperationLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'experience': obj.experience,
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut#distributionFilter
   */
  readonly distributionFilter?: string;

  /**
   * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut#range
   */
  readonly range?: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCut | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionFilter': obj.distributionFilter,
    'range': toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange(obj.range),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * `good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio#badServiceFilter
   */
  readonly badServiceFilter?: string;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying good service provided. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio#goodServiceFilter
   */
  readonly goodServiceFilter?: string;

  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying total demanded service. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio#totalServiceFilter
   */
  readonly totalServiceFilter?: string;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceGoodTotalRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'badServiceFilter': obj.badServiceFilter,
    'goodServiceFilter': obj.goodServiceFilter,
    'totalServiceFilter': obj.totalServiceFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Range of values considered "good." For a one-sided range, set one bound to an infinite value.
 *
 * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange
 */
export interface MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange {
  /**
   * Range maximum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange#max
   */
  readonly max?: number;

  /**
   * Range minimum.
   *
   * @schema MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange(obj: MonitoringServiceLevelObjectiveSpecServiceLevelIndicatorWindowsBasedGoodTotalRatioThresholdPerformanceDistributionCutRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema MonitoringUptimeCheckConfig
 */
export class MonitoringUptimeCheckConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MonitoringUptimeCheckConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringUptimeCheckConfig',
  }

  /**
   * Renders a Kubernetes manifest for "MonitoringUptimeCheckConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MonitoringUptimeCheckConfigProps): any {
    return {
      ...MonitoringUptimeCheckConfig.GVK,
      ...toJson_MonitoringUptimeCheckConfigProps(props),
    };
  }

  /**
   * Defines a "MonitoringUptimeCheckConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MonitoringUptimeCheckConfigProps) {
    super(scope, id, {
      ...MonitoringUptimeCheckConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MonitoringUptimeCheckConfig.GVK,
      ...toJson_MonitoringUptimeCheckConfigProps(resolved),
    };
  }
}

/**
 * @schema MonitoringUptimeCheckConfig
 */
export interface MonitoringUptimeCheckConfigProps {
  /**
   * @schema MonitoringUptimeCheckConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema MonitoringUptimeCheckConfig#spec
   */
  readonly spec: MonitoringUptimeCheckConfigSpec;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigProps(obj: MonitoringUptimeCheckConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MonitoringUptimeCheckConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringUptimeCheckConfigSpec
 */
export interface MonitoringUptimeCheckConfigSpec {
  /**
   * The content that is expected to appear in the data returned by the target server against which the check is run.  Currently, only the first entry in the `content_matchers` list is supported, and additional entries will be ignored. This field is optional and should only be specified if a content match is required as part of the/ Uptime check.
   *
   * @schema MonitoringUptimeCheckConfigSpec#contentMatchers
   */
  readonly contentMatchers?: MonitoringUptimeCheckConfigSpecContentMatchers[];

  /**
   * A human-friendly name for the Uptime check configuration. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced. Required.
   *
   * @schema MonitoringUptimeCheckConfigSpec#displayName
   */
  readonly displayName: string;

  /**
   * Contains information needed to make an HTTP or HTTPS check.
   *
   * @schema MonitoringUptimeCheckConfigSpec#httpCheck
   */
  readonly httpCheck?: MonitoringUptimeCheckConfigSpecHttpCheck;

  /**
   * Immutable. The [monitored resource](https://cloud.google.com/monitoring/api/resources) associated with the configuration. The following monitored resource types are supported for Uptime checks:   `uptime_url`,   `gce_instance`,   `gae_app`,   `aws_ec2_instance`,   `aws_elb_load_balancer`
   *
   * @schema MonitoringUptimeCheckConfigSpec#monitoredResource
   */
  readonly monitoredResource?: MonitoringUptimeCheckConfigSpecMonitoredResource;

  /**
   * How often, in seconds, the Uptime check is performed. Currently, the only supported values are `60s` (1 minute), `300s` (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional, defaults to `60s`.
   *
   * @schema MonitoringUptimeCheckConfigSpec#period
   */
  readonly period?: string;

  /**
   * Immutable. The Project that this resource belongs to.
   *
   * @schema MonitoringUptimeCheckConfigSpec#projectRef
   */
  readonly projectRef: MonitoringUptimeCheckConfigSpecProjectRef;

  /**
   * Immutable. The group resource associated with the configuration.
   *
   * @schema MonitoringUptimeCheckConfigSpec#resourceGroup
   */
  readonly resourceGroup?: MonitoringUptimeCheckConfigSpecResourceGroup;

  /**
   * Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.
   *
   * @schema MonitoringUptimeCheckConfigSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * The list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions must be provided to include a minimum of 3 locations.  Not specifying this field will result in Uptime checks running from all available regions.
   *
   * @schema MonitoringUptimeCheckConfigSpec#selectedRegions
   */
  readonly selectedRegions?: string[];

  /**
   * Contains information needed to make a TCP check.
   *
   * @schema MonitoringUptimeCheckConfigSpec#tcpCheck
   */
  readonly tcpCheck?: MonitoringUptimeCheckConfigSpecTcpCheck;

  /**
   * The maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). Required.
   *
   * @schema MonitoringUptimeCheckConfigSpec#timeout
   */
  readonly timeout: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpec(obj: MonitoringUptimeCheckConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentMatchers': obj.contentMatchers?.map(y => toJson_MonitoringUptimeCheckConfigSpecContentMatchers(y)),
    'displayName': obj.displayName,
    'httpCheck': toJson_MonitoringUptimeCheckConfigSpecHttpCheck(obj.httpCheck),
    'monitoredResource': toJson_MonitoringUptimeCheckConfigSpecMonitoredResource(obj.monitoredResource),
    'period': obj.period,
    'projectRef': toJson_MonitoringUptimeCheckConfigSpecProjectRef(obj.projectRef),
    'resourceGroup': toJson_MonitoringUptimeCheckConfigSpecResourceGroup(obj.resourceGroup),
    'resourceID': obj.resourceId,
    'selectedRegions': obj.selectedRegions?.map(y => y),
    'tcpCheck': toJson_MonitoringUptimeCheckConfigSpecTcpCheck(obj.tcpCheck),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringUptimeCheckConfigSpecContentMatchers
 */
export interface MonitoringUptimeCheckConfigSpecContentMatchers {
  /**
   * @schema MonitoringUptimeCheckConfigSpecContentMatchers#content
   */
  readonly content: string;

  /**
   * Possible values: CONTENT_MATCHER_OPTION_UNSPECIFIED, CONTAINS_STRING, NOT_CONTAINS_STRING, MATCHES_REGEX, NOT_MATCHES_REGEX
   *
   * @schema MonitoringUptimeCheckConfigSpecContentMatchers#matcher
   */
  readonly matcher?: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecContentMatchers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecContentMatchers(obj: MonitoringUptimeCheckConfigSpecContentMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'matcher': obj.matcher,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information needed to make an HTTP or HTTPS check.
 *
 * @schema MonitoringUptimeCheckConfigSpecHttpCheck
 */
export interface MonitoringUptimeCheckConfigSpecHttpCheck {
  /**
   * The authentication information. Optional when creating an HTTP check; defaults to empty.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#authInfo
   */
  readonly authInfo?: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo;

  /**
   * The request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all `bytes` fields JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#body
   */
  readonly body?: string;

  /**
   * Immutable. The content type to use for the check.  Possible values: TYPE_UNSPECIFIED, URL_ENCODED
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#contentType
   */
  readonly contentType?: string;

  /**
   * The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Immutable. Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******.`
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#maskHeaders
   */
  readonly maskHeaders?: boolean;

  /**
   * Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the `host` (specified within the `monitored_resource`) and `port` to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#path
   */
  readonly path?: string;

  /**
   * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when `use_ssl` is `true`). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the `monitored_resource`) and `path` to construct the full URL.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#port
   */
  readonly port?: number;

  /**
   * Immutable. The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#requestMethod
   */
  readonly requestMethod?: string;

  /**
   * If `true`, use HTTPS instead of HTTP to run the check.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#useSsl
   */
  readonly useSsl?: boolean;

  /**
   * Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheck#validateSsl
   */
  readonly validateSsl?: boolean;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecHttpCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecHttpCheck(obj: MonitoringUptimeCheckConfigSpecHttpCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authInfo': toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo(obj.authInfo),
    'body': obj.body,
    'contentType': obj.contentType,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maskHeaders': obj.maskHeaders,
    'path': obj.path,
    'port': obj.port,
    'requestMethod': obj.requestMethod,
    'useSsl': obj.useSsl,
    'validateSsl': obj.validateSsl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The [monitored resource](https://cloud.google.com/monitoring/api/resources) associated with the configuration. The following monitored resource types are supported for Uptime checks:   `uptime_url`,   `gce_instance`,   `gae_app`,   `aws_ec2_instance`,   `aws_elb_load_balancer`
 *
 * @schema MonitoringUptimeCheckConfigSpecMonitoredResource
 */
export interface MonitoringUptimeCheckConfigSpecMonitoredResource {
  /**
   * Immutable.
   *
   * @schema MonitoringUptimeCheckConfigSpecMonitoredResource#filterLabels
   */
  readonly filterLabels: { [key: string]: string };

  /**
   * Immutable.
   *
   * @schema MonitoringUptimeCheckConfigSpecMonitoredResource#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecMonitoredResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecMonitoredResource(obj: MonitoringUptimeCheckConfigSpecMonitoredResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterLabels': ((obj.filterLabels) === undefined) ? undefined : (Object.entries(obj.filterLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The Project that this resource belongs to.
 *
 * @schema MonitoringUptimeCheckConfigSpecProjectRef
 */
export interface MonitoringUptimeCheckConfigSpecProjectRef {
  /**
   * The project for this uptime check config.
   *
   * Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).
   *
   * @schema MonitoringUptimeCheckConfigSpecProjectRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringUptimeCheckConfigSpecProjectRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringUptimeCheckConfigSpecProjectRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecProjectRef(obj: MonitoringUptimeCheckConfigSpecProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The group resource associated with the configuration.
 *
 * @schema MonitoringUptimeCheckConfigSpecResourceGroup
 */
export interface MonitoringUptimeCheckConfigSpecResourceGroup {
  /**
   * Immutable.
   *
   * @schema MonitoringUptimeCheckConfigSpecResourceGroup#groupRef
   */
  readonly groupRef?: MonitoringUptimeCheckConfigSpecResourceGroupGroupRef;

  /**
   * Immutable. The resource type of the group members. Possible values: RESOURCE_TYPE_UNSPECIFIED, INSTANCE, AWS_ELB_LOAD_BALANCER
   *
   * @schema MonitoringUptimeCheckConfigSpecResourceGroup#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecResourceGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecResourceGroup(obj: MonitoringUptimeCheckConfigSpecResourceGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupRef': toJson_MonitoringUptimeCheckConfigSpecResourceGroupGroupRef(obj.groupRef),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contains information needed to make a TCP check.
 *
 * @schema MonitoringUptimeCheckConfigSpecTcpCheck
 */
export interface MonitoringUptimeCheckConfigSpecTcpCheck {
  /**
   * The TCP port on the server against which to run the check. Will be combined with host (specified within the `monitored_resource`) to construct the full URL. Required.
   *
   * @schema MonitoringUptimeCheckConfigSpecTcpCheck#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecTcpCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecTcpCheck(obj: MonitoringUptimeCheckConfigSpecTcpCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The authentication information. Optional when creating an HTTP check; defaults to empty.
 *
 * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo
 */
export interface MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo {
  /**
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo#password
   */
  readonly password: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword;

  /**
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo(obj: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword(obj.password),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable.
 *
 * @schema MonitoringUptimeCheckConfigSpecResourceGroupGroupRef
 */
export interface MonitoringUptimeCheckConfigSpecResourceGroupGroupRef {
  /**
   * The group of resources being monitored. Should be only the `[GROUP_ID]`, and not the full-path `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
   *
   * Allowed value: The Google Cloud resource name of a `MonitoringGroup` resource (format: `projects/{{project}}/groups/{{name}}`).
   *
   * @schema MonitoringUptimeCheckConfigSpecResourceGroupGroupRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema MonitoringUptimeCheckConfigSpecResourceGroupGroupRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema MonitoringUptimeCheckConfigSpecResourceGroupGroupRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecResourceGroupGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecResourceGroupGroupRef(obj: MonitoringUptimeCheckConfigSpecResourceGroupGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword
 */
export interface MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword {
  /**
   * Value of the field. Cannot be used if 'valueFrom' is specified.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword#value
   */
  readonly value?: string;

  /**
   * Source for the field's value. Cannot be used if 'value' is specified.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword#valueFrom
   */
  readonly valueFrom?: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword(obj: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
    'valueFrom': toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the field's value. Cannot be used if 'value' is specified.
 *
 * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom
 */
export interface MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom {
  /**
   * Reference to a value with the given key in the given Secret in the resource's namespace.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom(obj: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretKeyRef': toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a value with the given key in the given Secret in the resource's namespace.
 *
 * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef
 */
export interface MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef {
  /**
   * Key that identifies the value to be extracted.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the Secret to extract a value from.
   *
   * @schema MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef(obj: MonitoringUptimeCheckConfigSpecHttpCheckAuthInfoPasswordValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

