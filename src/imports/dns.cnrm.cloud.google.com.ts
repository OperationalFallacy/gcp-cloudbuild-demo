// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema DNSManagedZone
 */
export class DnsManagedZone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DNSManagedZone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.cnrm.cloud.google.com/v1beta1',
    kind: 'DNSManagedZone',
  }

  /**
   * Renders a Kubernetes manifest for "DNSManagedZone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DnsManagedZoneProps): any {
    return {
      ...DnsManagedZone.GVK,
      ...toJson_DnsManagedZoneProps(props),
    };
  }

  /**
   * Defines a "DNSManagedZone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DnsManagedZoneProps) {
    super(scope, id, {
      ...DnsManagedZone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DnsManagedZone.GVK,
      ...toJson_DnsManagedZoneProps(resolved),
    };
  }
}

/**
 * @schema DNSManagedZone
 */
export interface DnsManagedZoneProps {
  /**
   * @schema DNSManagedZone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DNSManagedZone#spec
   */
  readonly spec: DnsManagedZoneSpec;

}

/**
 * Converts an object of type 'DnsManagedZoneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneProps(obj: DnsManagedZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DnsManagedZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsManagedZoneSpec
 */
export interface DnsManagedZoneSpec {
  /**
   * Cloud logging configuration.
   *
   * @schema DnsManagedZoneSpec#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: DnsManagedZoneSpecCloudLoggingConfig;

  /**
   * A textual description field. Defaults to 'Managed by Config Connector'.
   *
   * @default Managed by Config Connector'.
   * @schema DnsManagedZoneSpec#description
   */
  readonly description?: string;

  /**
   * Immutable. The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema DnsManagedZoneSpec#dnsName
   */
  readonly dnsName: string;

  /**
   * DNSSEC configuration.
   *
   * @schema DnsManagedZoneSpec#dnssecConfig
   */
  readonly dnssecConfig?: DnsManagedZoneSpecDnssecConfig;

  /**
   * The presence for this field indicates that outbound forwarding is enabled
   * for this zone. The value of this field contains the set of destinations
   * to forward to.
   *
   * @schema DnsManagedZoneSpec#forwardingConfig
   */
  readonly forwardingConfig?: DnsManagedZoneSpecForwardingConfig;

  /**
   * The presence of this field indicates that DNS Peering is enabled for this
   * zone. The value of this field contains the network to peer with.
   *
   * @schema DnsManagedZoneSpec#peeringConfig
   */
  readonly peeringConfig?: DnsManagedZoneSpecPeeringConfig;

  /**
   * For privately visible zones, the set of Virtual Private Cloud
   * resources that the zone is visible from.
   *
   * @schema DnsManagedZoneSpec#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: DnsManagedZoneSpecPrivateVisibilityConfig;

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema DnsManagedZoneSpec#resourceID
   */
  readonly resourceId?: string;

  /**
   * Immutable. Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
   * lookup queries using automatically configured records for VPC resources. This only applies
   * to networks listed under 'private_visibility_config'.
   *
   * @schema DnsManagedZoneSpec#reverseLookup
   */
  readonly reverseLookup?: boolean;

  /**
   * Immutable. The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
   *
   * @schema DnsManagedZoneSpec#serviceDirectoryConfig
   */
  readonly serviceDirectoryConfig?: DnsManagedZoneSpecServiceDirectoryConfig;

  /**
   * Immutable. The zone's visibility: public zones are exposed to the Internet,
   * while private zones are visible only to Virtual Private Cloud resources. Default value: "public" Possible values: ["private", "public"].
   *
   * @schema DnsManagedZoneSpec#visibility
   */
  readonly visibility?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpec(obj: DnsManagedZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': toJson_DnsManagedZoneSpecCloudLoggingConfig(obj.cloudLoggingConfig),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': toJson_DnsManagedZoneSpecDnssecConfig(obj.dnssecConfig),
    'forwardingConfig': toJson_DnsManagedZoneSpecForwardingConfig(obj.forwardingConfig),
    'peeringConfig': toJson_DnsManagedZoneSpecPeeringConfig(obj.peeringConfig),
    'privateVisibilityConfig': toJson_DnsManagedZoneSpecPrivateVisibilityConfig(obj.privateVisibilityConfig),
    'resourceID': obj.resourceId,
    'reverseLookup': obj.reverseLookup,
    'serviceDirectoryConfig': toJson_DnsManagedZoneSpecServiceDirectoryConfig(obj.serviceDirectoryConfig),
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cloud logging configuration.
 *
 * @schema DnsManagedZoneSpecCloudLoggingConfig
 */
export interface DnsManagedZoneSpecCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema DnsManagedZoneSpecCloudLoggingConfig#enableLogging
   */
  readonly enableLogging: boolean;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecCloudLoggingConfig(obj: DnsManagedZoneSpecCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DNSSEC configuration.
 *
 * @schema DnsManagedZoneSpecDnssecConfig
 */
export interface DnsManagedZoneSpecDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys
   * for this ManagedZone. If you provide a spec for keySigning or zoneSigning,
   * you must also provide one for the other.
   * default_key_specs can only be updated when the state is 'off'.
   *
   * @schema DnsManagedZoneSpecDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: DnsManagedZoneSpecDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is.
   *
   * @schema DnsManagedZoneSpecDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses.
   * non_existence can only be updated when the state is 'off'. Possible values: ["nsec", "nsec3"].
   *
   * @schema DnsManagedZoneSpecDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in Possible values: ["off", "on", "transfer"].
   *
   * @schema DnsManagedZoneSpecDnssecConfig#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecDnssecConfig(obj: DnsManagedZoneSpecDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_DnsManagedZoneSpecDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The presence for this field indicates that outbound forwarding is enabled
 * for this zone. The value of this field contains the set of destinations
 * to forward to.
 *
 * @schema DnsManagedZoneSpecForwardingConfig
 */
export interface DnsManagedZoneSpecForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will
   * select the best available name server if more than
   * one target is given.
   *
   * @schema DnsManagedZoneSpecForwardingConfig#targetNameServers
   */
  readonly targetNameServers: DnsManagedZoneSpecForwardingConfigTargetNameServers[];

}

/**
 * Converts an object of type 'DnsManagedZoneSpecForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecForwardingConfig(obj: DnsManagedZoneSpecForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_DnsManagedZoneSpecForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The presence of this field indicates that DNS Peering is enabled for this
 * zone. The value of this field contains the network to peer with.
 *
 * @schema DnsManagedZoneSpecPeeringConfig
 */
export interface DnsManagedZoneSpecPeeringConfig {
  /**
   * The network with which to peer.
   *
   * @schema DnsManagedZoneSpecPeeringConfig#targetNetwork
   */
  readonly targetNetwork: DnsManagedZoneSpecPeeringConfigTargetNetwork;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPeeringConfig(obj: DnsManagedZoneSpecPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': toJson_DnsManagedZoneSpecPeeringConfigTargetNetwork(obj.targetNetwork),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * For privately visible zones, the set of Virtual Private Cloud
 * resources that the zone is visible from.
 *
 * @schema DnsManagedZoneSpecPrivateVisibilityConfig
 */
export interface DnsManagedZoneSpecPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone.
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters[];

  /**
   * @schema DnsManagedZoneSpecPrivateVisibilityConfig#networks
   */
  readonly networks: DnsManagedZoneSpecPrivateVisibilityConfigNetworks[];

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPrivateVisibilityConfig(obj: DnsManagedZoneSpecPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_DnsManagedZoneSpecPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Immutable. The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
 *
 * @schema DnsManagedZoneSpecServiceDirectoryConfig
 */
export interface DnsManagedZoneSpecServiceDirectoryConfig {
  /**
   * The namespace associated with the zone.
   *
   * @schema DnsManagedZoneSpecServiceDirectoryConfig#namespace
   */
  readonly namespace: DnsManagedZoneSpecServiceDirectoryConfigNamespace;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecServiceDirectoryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecServiceDirectoryConfig(obj: DnsManagedZoneSpecServiceDirectoryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': toJson_DnsManagedZoneSpecServiceDirectoryConfigNamespace(obj.namespace),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsManagedZoneSpecDnssecConfigDefaultKeySpecs
 */
export interface DnsManagedZoneSpecDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key Possible values: ["ecdsap256sha256", "ecdsap384sha384", "rsasha1", "rsasha256", "rsasha512"].
   *
   * @schema DnsManagedZoneSpecDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits.
   *
   * @schema DnsManagedZoneSpecDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone
   * signing key (ZSK). Key signing keys have the Secure Entry
   * Point flag set and, when active, will only be used to sign
   * resource record sets of type DNSKEY. Zone signing keys do
   * not have the Secure Entry Point flag set and will be used
   * to sign all other types of resource record sets. Possible values: ["keySigning", "zoneSigning"].
   *
   * @schema DnsManagedZoneSpecDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is.
   *
   * @schema DnsManagedZoneSpecDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecDnssecConfigDefaultKeySpecs(obj: DnsManagedZoneSpecDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsManagedZoneSpecForwardingConfigTargetNameServers
 */
export interface DnsManagedZoneSpecForwardingConfigTargetNameServers {
  /**
   * Forwarding path for this TargetNameServer. If unset or 'default' Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to 'private', Cloud DNS will always send queries through VPC for this target Possible values: ["default", "private"].
   *
   * @schema DnsManagedZoneSpecForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema DnsManagedZoneSpecForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecForwardingConfigTargetNameServers(obj: DnsManagedZoneSpecForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The network with which to peer.
 *
 * @schema DnsManagedZoneSpecPeeringConfigTargetNetwork
 */
export interface DnsManagedZoneSpecPeeringConfigTargetNetwork {
  /**
   * VPC network to forward queries to.
   *
   * @schema DnsManagedZoneSpecPeeringConfigTargetNetwork#networkRef
   */
  readonly networkRef: DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPeeringConfigTargetNetwork(obj: DnsManagedZoneSpecPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkRef': toJson_DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef(obj.networkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters
 */
export interface DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to.
   * This should be specified in the format like
   * 'projects/_/locations/_/clusters/*'.
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef: DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters(obj: DnsManagedZoneSpecPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterNameRef': toJson_DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworks
 */
export interface DnsManagedZoneSpecPrivateVisibilityConfigNetworks {
  /**
   * VPC network to bind to.
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworks#networkRef
   */
  readonly networkRef: DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPrivateVisibilityConfigNetworks(obj: DnsManagedZoneSpecPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkRef': toJson_DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef(obj.networkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The namespace associated with the zone.
 *
 * @schema DnsManagedZoneSpecServiceDirectoryConfigNamespace
 */
export interface DnsManagedZoneSpecServiceDirectoryConfigNamespace {
  /**
   * The fully qualified or partial URL of the service directory namespace that should be
   * associated with the zone. This should be formatted like
   * 'https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace_id}'
   * or simply 'projects/{project}/locations/{location}/namespaces/{namespace_id}'
   * Ignored for 'public' visibility zones.
   *
   * @schema DnsManagedZoneSpecServiceDirectoryConfigNamespace#namespaceUrl
   */
  readonly namespaceUrl: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecServiceDirectoryConfigNamespace' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecServiceDirectoryConfigNamespace(obj: DnsManagedZoneSpecServiceDirectoryConfigNamespace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceUrl': obj.namespaceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPC network to forward queries to.
 *
 * @schema DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef
 */
export interface DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef(obj: DnsManagedZoneSpecPeeringConfigTargetNetworkNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The resource name of the cluster to bind this ManagedZone to.
 * This should be specified in the format like
 * 'projects/_/locations/_/clusters/*'.
 *
 * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Allowed value: The `selfLink` field of a `ContainerCluster` resource.
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: DnsManagedZoneSpecPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPC network to bind to.
 *
 * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef
 */
export interface DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef(obj: DnsManagedZoneSpecPrivateVisibilityConfigNetworksNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DNSPolicy
 */
export class DnsPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DNSPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.cnrm.cloud.google.com/v1beta1',
    kind: 'DNSPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "DNSPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DnsPolicyProps = {}): any {
    return {
      ...DnsPolicy.GVK,
      ...toJson_DnsPolicyProps(props),
    };
  }

  /**
   * Defines a "DNSPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DnsPolicyProps = {}) {
    super(scope, id, {
      ...DnsPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DnsPolicy.GVK,
      ...toJson_DnsPolicyProps(resolved),
    };
  }
}

/**
 * @schema DNSPolicy
 */
export interface DnsPolicyProps {
  /**
   * @schema DNSPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DNSPolicy#spec
   */
  readonly spec?: DnsPolicySpec;

}

/**
 * Converts an object of type 'DnsPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicyProps(obj: DnsPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DnsPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsPolicySpec
 */
export interface DnsPolicySpec {
  /**
   * Sets an alternative name server for the associated networks.
   * When specified, all DNS queries are forwarded to a name server that you choose.
   * Names such as .internal are not available when an alternative name server is specified.
   *
   * @schema DnsPolicySpec#alternativeNameServerConfig
   */
  readonly alternativeNameServerConfig?: DnsPolicySpecAlternativeNameServerConfig;

  /**
   * A textual description field. Defaults to 'Managed by Config Connector'.
   *
   * @default Managed by Config Connector'.
   * @schema DnsPolicySpec#description
   */
  readonly description?: string;

  /**
   * Allows networks bound to this policy to receive DNS queries sent
   * by VMs or applications over VPN connections. When enabled, a
   * virtual IP address will be allocated from each of the sub-networks
   * that are bound to this policy.
   *
   * @schema DnsPolicySpec#enableInboundForwarding
   */
  readonly enableInboundForwarding?: boolean;

  /**
   * Controls whether logging is enabled for the networks bound to this policy.
   * Defaults to no logging if not set.
   *
   * @default no logging if not set.
   * @schema DnsPolicySpec#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * List of network names specifying networks to which this policy is applied.
   *
   * @schema DnsPolicySpec#networks
   */
  readonly networks?: DnsPolicySpecNetworks[];

  /**
   * Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.
   *
   * @schema DnsPolicySpec#resourceID
   */
  readonly resourceId?: string;

}

/**
 * Converts an object of type 'DnsPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicySpec(obj: DnsPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeNameServerConfig': toJson_DnsPolicySpecAlternativeNameServerConfig(obj.alternativeNameServerConfig),
    'description': obj.description,
    'enableInboundForwarding': obj.enableInboundForwarding,
    'enableLogging': obj.enableLogging,
    'networks': obj.networks?.map(y => toJson_DnsPolicySpecNetworks(y)),
    'resourceID': obj.resourceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sets an alternative name server for the associated networks.
 * When specified, all DNS queries are forwarded to a name server that you choose.
 * Names such as .internal are not available when an alternative name server is specified.
 *
 * @schema DnsPolicySpecAlternativeNameServerConfig
 */
export interface DnsPolicySpecAlternativeNameServerConfig {
  /**
   * Sets an alternative name server for the associated networks. When specified,
   * all DNS queries are forwarded to a name server that you choose. Names such as .internal
   * are not available when an alternative name server is specified.
   *
   * @schema DnsPolicySpecAlternativeNameServerConfig#targetNameServers
   */
  readonly targetNameServers: DnsPolicySpecAlternativeNameServerConfigTargetNameServers[];

}

/**
 * Converts an object of type 'DnsPolicySpecAlternativeNameServerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicySpecAlternativeNameServerConfig(obj: DnsPolicySpecAlternativeNameServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_DnsPolicySpecAlternativeNameServerConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsPolicySpecNetworks
 */
export interface DnsPolicySpecNetworks {
  /**
   * VPC network to bind to.
   *
   * @schema DnsPolicySpecNetworks#networkRef
   */
  readonly networkRef: DnsPolicySpecNetworksNetworkRef;

}

/**
 * Converts an object of type 'DnsPolicySpecNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicySpecNetworks(obj: DnsPolicySpecNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkRef': toJson_DnsPolicySpecNetworksNetworkRef(obj.networkRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsPolicySpecAlternativeNameServerConfigTargetNameServers
 */
export interface DnsPolicySpecAlternativeNameServerConfigTargetNameServers {
  /**
   * Forwarding path for this TargetNameServer. If unset or 'default' Cloud DNS will make forwarding
   * decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go
   * to the Internet. When set to 'private', Cloud DNS will always send queries through VPC for this target Possible values: ["default", "private"].
   *
   * @schema DnsPolicySpecAlternativeNameServerConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address to forward to.
   *
   * @schema DnsPolicySpecAlternativeNameServerConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address: string;

}

/**
 * Converts an object of type 'DnsPolicySpecAlternativeNameServerConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicySpecAlternativeNameServerConfigTargetNameServers(obj: DnsPolicySpecAlternativeNameServerConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPC network to bind to.
 *
 * @schema DnsPolicySpecNetworksNetworkRef
 */
export interface DnsPolicySpecNetworksNetworkRef {
  /**
   * Allowed value: The `selfLink` field of a `ComputeNetwork` resource.
   *
   * @schema DnsPolicySpecNetworksNetworkRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsPolicySpecNetworksNetworkRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsPolicySpecNetworksNetworkRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsPolicySpecNetworksNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsPolicySpecNetworksNetworkRef(obj: DnsPolicySpecNetworksNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 *
 *
 * @schema DNSRecordSet
 */
export class DnsRecordSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DNSRecordSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.cnrm.cloud.google.com/v1beta1',
    kind: 'DNSRecordSet',
  }

  /**
   * Renders a Kubernetes manifest for "DNSRecordSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DnsRecordSetProps): any {
    return {
      ...DnsRecordSet.GVK,
      ...toJson_DnsRecordSetProps(props),
    };
  }

  /**
   * Defines a "DNSRecordSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DnsRecordSetProps) {
    super(scope, id, {
      ...DnsRecordSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DnsRecordSet.GVK,
      ...toJson_DnsRecordSetProps(resolved),
    };
  }
}

/**
 * @schema DNSRecordSet
 */
export interface DnsRecordSetProps {
  /**
   * @schema DNSRecordSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema DNSRecordSet#spec
   */
  readonly spec: DnsRecordSetSpec;

}

/**
 * Converts an object of type 'DnsRecordSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsRecordSetProps(obj: DnsRecordSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DnsRecordSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsRecordSetSpec
 */
export interface DnsRecordSetSpec {
  /**
   * @schema DnsRecordSetSpec#managedZoneRef
   */
  readonly managedZoneRef: DnsRecordSetSpecManagedZoneRef;

  /**
   * Immutable. The DNS name this record set will apply to.
   *
   * @schema DnsRecordSetSpec#name
   */
  readonly name: string;

  /**
   * DEPRECATED. Although this field is still available, there is limited support. We recommend that you use `spec.rrdatasRefs` instead.
   *
   * @schema DnsRecordSetSpec#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * @schema DnsRecordSetSpec#rrdatasRefs
   */
  readonly rrdatasRefs?: DnsRecordSetSpecRrdatasRefs[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema DnsRecordSetSpec#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema DnsRecordSetSpec#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DnsRecordSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsRecordSetSpec(obj: DnsRecordSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZoneRef': toJson_DnsRecordSetSpecManagedZoneRef(obj.managedZoneRef),
    'name': obj.name,
    'rrdatas': obj.rrdatas?.map(y => y),
    'rrdatasRefs': obj.rrdatasRefs?.map(y => toJson_DnsRecordSetSpecRrdatasRefs(y)),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsRecordSetSpecManagedZoneRef
 */
export interface DnsRecordSetSpecManagedZoneRef {
  /**
   * Allowed value: The `name` field of a `DNSManagedZone` resource.
   *
   * @schema DnsRecordSetSpecManagedZoneRef#external
   */
  readonly external?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsRecordSetSpecManagedZoneRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsRecordSetSpecManagedZoneRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsRecordSetSpecManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsRecordSetSpecManagedZoneRef(obj: DnsRecordSetSpecManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DnsRecordSetSpecRrdatasRefs
 */
export interface DnsRecordSetSpecRrdatasRefs {
  /**
   * Allowed value: The `address` field of a `ComputeAddress` resource.
   *
   * @schema DnsRecordSetSpecRrdatasRefs#external
   */
  readonly external?: string;

  /**
   * Kind of the referent. Allowed values: ComputeAddress
   *
   * @schema DnsRecordSetSpecRrdatasRefs#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DnsRecordSetSpecRrdatasRefs#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema DnsRecordSetSpecRrdatasRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'DnsRecordSetSpecRrdatasRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DnsRecordSetSpecRrdatasRefs(obj: DnsRecordSetSpecRrdatasRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'external': obj.external,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

